This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*py, **/*.pyi
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
queryablecollections_tests/numeric/test_q_decimal_iterable.py
queryablecollections_tests/numeric/test_q_float_iterable.py
queryablecollections_tests/numeric/test_q_fraction_iterable.py
queryablecollections_tests/numeric/test_q_int_iterable.py
queryablecollections_tests/q_iterable/test_aggregate_seed_result.py
queryablecollections_tests/q_iterable/test_aggregate_seed.py
queryablecollections_tests/q_iterable/test_aggregate.py
queryablecollections_tests/q_iterable/test_all.py
queryablecollections_tests/q_iterable/test_any.py
queryablecollections_tests/q_iterable/test_as_.py
queryablecollections_tests/q_iterable/test_as_iterable.py
queryablecollections_tests/q_iterable/test_cast_checked_to.py
queryablecollections_tests/q_iterable/test_cast_to.py
queryablecollections_tests/q_iterable/test_chunk.py
queryablecollections_tests/q_iterable/test_concat.py
queryablecollections_tests/q_iterable/test_contains.py
queryablecollections_tests/q_iterable/test_distinct_by.py
queryablecollections_tests/q_iterable/test_distinct.py
queryablecollections_tests/q_iterable/test_element_at_or_none.py
queryablecollections_tests/q_iterable/test_element_at.py
queryablecollections_tests/q_iterable/test_empty.py
queryablecollections_tests/q_iterable/test_first.py
queryablecollections_tests/q_iterable/test_for_each.py
queryablecollections_tests/q_iterable/test_group_by.py
queryablecollections_tests/q_iterable/test_group_join.py
queryablecollections_tests/q_iterable/test_indexer.py
queryablecollections_tests/q_iterable/test_join.py
queryablecollections_tests/q_iterable/test_last_or_none.py
queryablecollections_tests/q_iterable/test_last.py
queryablecollections_tests/q_iterable/test_max_by.py
queryablecollections_tests/q_iterable/test_min_by.py
queryablecollections_tests/q_iterable/test_none.py
queryablecollections_tests/q_iterable/test_not_none.py
queryablecollections_tests/q_iterable/test_of_type.py
queryablecollections_tests/q_iterable/test_order_by.py
queryablecollections_tests/q_iterable/test_prepend.py
queryablecollections_tests/q_iterable/test_qappend.py
queryablecollections_tests/q_iterable/test_qcount_by.py
queryablecollections_tests/q_iterable/test_qcount.py
queryablecollections_tests/q_iterable/test_qexcept.py
queryablecollections_tests/q_iterable/test_qindex.py
queryablecollections_tests/q_iterable/test_qintersect.py
queryablecollections_tests/q_iterable/test_qunion_by.py
queryablecollections_tests/q_iterable/test_qunion.py
queryablecollections_tests/q_iterable/test_range.py
queryablecollections_tests/q_iterable/test_repeat.py
queryablecollections_tests/q_iterable/test_reverse.py
queryablecollections_tests/q_iterable/test_select_index.py
queryablecollections_tests/q_iterable/test_select_many.py
queryablecollections_tests/q_iterable/test_select.py
queryablecollections_tests/q_iterable/test_sequence_equal.py
queryablecollections_tests/q_iterable/test_single_or_none.py
queryablecollections_tests/q_iterable/test_single.py
queryablecollections_tests/q_iterable/test_skip_last.py
queryablecollections_tests/q_iterable/test_skip_while.py
queryablecollections_tests/q_iterable/test_skip.py
queryablecollections_tests/q_iterable/test_take_last.py
queryablecollections_tests/q_iterable/test_take_while.py
queryablecollections_tests/q_iterable/test_take.py
queryablecollections_tests/q_iterable/test_to_.py
queryablecollections_tests/q_iterable/test_to_dict.py
queryablecollections_tests/q_iterable/test_where_key_in.py
queryablecollections_tests/q_iterable/test_where_key_not_in.py
queryablecollections_tests/q_iterable/test_where.py
queryablecollections_tests/q_iterable/test_zip_tuple.py
queryablecollections_tests/q_iterable/test_zip_tuple2.py
queryablecollections_tests/q_iterable/test_zip_tuple3.py
queryablecollections_tests/q_iterable/test_zip.py
queryablecollections_tests/q_iterable/test_zip2.py
queryablecollections_tests/q_iterable/test_zip3.py
queryablecollections_tests/q_list/test_indexer.py
queryablecollections_tests/q_list/test_slicing.py
queryablecollections_tests/test_common_helpers.py
queryablecollections_tests/test_lazyness_and_consuming_behavior.py
src/queryablecollections/_private_implementation_details/immutable_sequence.py
src/queryablecollections/_private_implementation_details/ops/__init__.py
src/queryablecollections/_private_implementation_details/ops/aggregate.py
src/queryablecollections/_private_implementation_details/ops/all.py
src/queryablecollections/_private_implementation_details/ops/any.py
src/queryablecollections/_private_implementation_details/ops/append.py
src/queryablecollections/_private_implementation_details/ops/as_.py
src/queryablecollections/_private_implementation_details/ops/chunk.py
src/queryablecollections/_private_implementation_details/ops/concat.py
src/queryablecollections/_private_implementation_details/ops/contains.py
src/queryablecollections/_private_implementation_details/ops/distinct_by.py
src/queryablecollections/_private_implementation_details/ops/distinct.py
src/queryablecollections/_private_implementation_details/ops/element_at_or_none.py
src/queryablecollections/_private_implementation_details/ops/element_at.py
src/queryablecollections/_private_implementation_details/ops/first_or_none.py
src/queryablecollections/_private_implementation_details/ops/first.py
src/queryablecollections/_private_implementation_details/ops/flatten.py
src/queryablecollections/_private_implementation_details/ops/for_each.py
src/queryablecollections/_private_implementation_details/ops/group_by_q.py
src/queryablecollections/_private_implementation_details/ops/group_join.py
src/queryablecollections/_private_implementation_details/ops/join.py
src/queryablecollections/_private_implementation_details/ops/last_or_none.py
src/queryablecollections/_private_implementation_details/ops/last.py
src/queryablecollections/_private_implementation_details/ops/max_by.py
src/queryablecollections/_private_implementation_details/ops/min_by.py
src/queryablecollections/_private_implementation_details/ops/of_type.py
src/queryablecollections/_private_implementation_details/ops/pipe.py
src/queryablecollections/_private_implementation_details/ops/prepend.py
src/queryablecollections/_private_implementation_details/ops/qcount_by.py
src/queryablecollections/_private_implementation_details/ops/qcount.py
src/queryablecollections/_private_implementation_details/ops/qexcept.py
src/queryablecollections/_private_implementation_details/ops/qindex.py
src/queryablecollections/_private_implementation_details/ops/qintersect.py
src/queryablecollections/_private_implementation_details/ops/qunion_by.py
src/queryablecollections/_private_implementation_details/ops/qunion.py
src/queryablecollections/_private_implementation_details/ops/range.py
src/queryablecollections/_private_implementation_details/ops/repeat.py
src/queryablecollections/_private_implementation_details/ops/reversed.py
src/queryablecollections/_private_implementation_details/ops/select_index.py
src/queryablecollections/_private_implementation_details/ops/select_many.py
src/queryablecollections/_private_implementation_details/ops/select.py
src/queryablecollections/_private_implementation_details/ops/sequence_equal.py
src/queryablecollections/_private_implementation_details/ops/single_or_none.py
src/queryablecollections/_private_implementation_details/ops/single.py
src/queryablecollections/_private_implementation_details/ops/skip_last.py
src/queryablecollections/_private_implementation_details/ops/skip_while.py
src/queryablecollections/_private_implementation_details/ops/skip.py
src/queryablecollections/_private_implementation_details/ops/take_last.py
src/queryablecollections/_private_implementation_details/ops/take_while.py
src/queryablecollections/_private_implementation_details/ops/take.py
src/queryablecollections/_private_implementation_details/ops/to_dict.py
src/queryablecollections/_private_implementation_details/ops/where_key_in.py
src/queryablecollections/_private_implementation_details/ops/where_key_not_in.py
src/queryablecollections/_private_implementation_details/ops/where_not_none.py
src/queryablecollections/_private_implementation_details/ops/where.py
src/queryablecollections/_private_implementation_details/ops/zip_tuple.py
src/queryablecollections/_private_implementation_details/ops/zip.py
src/queryablecollections/_private_implementation_details/q_lazy_iterable.py
src/queryablecollections/_private_implementation_details/q_zero_overhead_collection_contructors.py
src/queryablecollections/_private_implementation_details/sort_by_instructions.py
src/queryablecollections/_private_implementation_details/sort_instruction.py
src/queryablecollections/_private_implementation_details/type_aliases.py
src/queryablecollections/collections/numeric/q_decimal_types.py
src/queryablecollections/collections/numeric/q_float_types.py
src/queryablecollections/collections/numeric/q_fraction_types.py
src/queryablecollections/collections/numeric/q_int_types.py
src/queryablecollections/collections/q_default_dict.py
src/queryablecollections/collections/q_dict.py
src/queryablecollections/collections/q_frozen_set.py
src/queryablecollections/collections/q_immutable_sequence.py
src/queryablecollections/collections/q_key_value_pair.py
src/queryablecollections/collections/q_list.py
src/queryablecollections/collections/q_sequence.py
src/queryablecollections/collections/q_set.py
src/queryablecollections/q_cast.py
src/queryablecollections/q_errors.py
src/queryablecollections/q_grouping.py
src/queryablecollections/q_iterable.py
src/queryablecollections/q_ordered_iterable.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="queryablecollections_tests/numeric/test_q_decimal_iterable.py">
from __future__ import annotations

from decimal import Decimal

import pytest
from queryablecollections.collections.numeric.q_decimal_types import QDecimalList
from queryablecollections.q_errors import EmptyIterableError
from test_common_helpers import throws_test, value_test_including_unordered_collections


def test_typing() -> None:
    QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).where(lambda item: True).sum()

def test_cast_decimal_returns_an_q_iterable_decimal_with_the_same_elements() -> None:
    value_test_including_unordered_collections([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")], lambda x: x.cast.decimal().to_list(), [Decimal("1.1"), Decimal("2.1"), Decimal("3.1")])

def test_cast_checked_decimal_returns_a_q_iterable_decimal_with_the_same_elements() -> None:
    value_test_including_unordered_collections([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")], lambda x: x.cast.checked.decimal().to_list(), [Decimal("1.1"), Decimal("2.1"), Decimal("3.1")])

def test_cast_checked_decimal_raises_type_error_if_collection_contains_non_decimal() -> None:
    throws_test([Decimal("1.1"), "2.1", Decimal("3.1")], lambda x: x.cast.checked.decimal().to_list(), TypeError)

def test_sum_returns_sum_of_the_values() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).sum() == Decimal("6.3")
def test_sum_returns_zero_on_on_empty_collection() -> None: assert QDecimalList().sum() == Decimal(0)

def test_min_returns_min_of_the_values() -> None: assert QDecimalList([Decimal("6.1"), Decimal("2.1"), Decimal("5.1"), Decimal("3.1")]).min() == Decimal("2.1")
def test_min_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QDecimalList().min()

def test_min_or_default_returns_min_of_the_values() -> None: assert QDecimalList([Decimal("6.1"), Decimal("2.1"), Decimal("5.1"), Decimal("3.1")]).min_or_default() == Decimal("2.1")
def test_min_or_default_returns_0_on_on_empty_collection() -> None: assert QDecimalList().min_or_default() == Decimal(0)

def test_max_returns_max_of_the_values() -> None: assert QDecimalList([Decimal("1.1"), Decimal("5.1"), Decimal("3.1")]).max() == Decimal("5.1")
def test_max_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QDecimalList().max()

def test_max_or_default_returns_max_of_the_values() -> None: assert QDecimalList([Decimal("1.1"), Decimal("5.1"), Decimal("3.1")]).max_or_default() == Decimal("5.1")
def test_max_or_default_returns_0_on_on_empty_collection() -> None: assert QDecimalList().max_or_default() == Decimal(0)

def test_average_returns_average_of_the_values() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).average() == Decimal("2.1")
def test_average_throws_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QDecimalList().average()

def test_average_or_default_returns_average_of_the_values() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).average_or_default() == Decimal("2.1")
def test_average_or_default_returns_0_on_on_empty_collection() -> None: assert QDecimalList().average_or_default() == Decimal(0)

def test_to_list_returns_a_list_with_the_same_elements() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).to_list() == [Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]
def test_to_set_returns_a_set_with_the_same_elements() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).to_set() == {Decimal("1.1"), Decimal("2.1"), Decimal("3.1")}
def test_to_frozenset_returns_a_frozenset_with_the_same_elements() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).to_frozenset() == frozenset({Decimal("1.1"), Decimal("2.1"), Decimal("3.1")})
def test_to_sequence_returns_a_sequence_with_the_same_elements() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).to_sequence().to_list() == [Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]
</file>

<file path="queryablecollections_tests/numeric/test_q_float_iterable.py">
from __future__ import annotations

import pytest
from queryablecollections.collections.numeric.q_float_types import QFloatList
from queryablecollections.q_errors import EmptyIterableError
from test_common_helpers import *


def test_cast_float_returns_an_q_iterable_float_with_the_same_elements() -> None:
    value_test_including_unordered_collections([1.1, 2.1, 3.1], lambda x: x.cast.float().to_list(), [1.1, 2.1, 3.1])

def test_cast_checked_float_returns_a_q_iterable_float_with_the_same_elements() -> None:
    value_test_including_unordered_collections([1.1, 2.1, 3.1], lambda x: x.cast.checked.float().to_list(), [1.1, 2.1, 3.1])

def test_cast_checked_float_raises_type_error_if_collection_contains_non_float() -> None:
    throws_test([1.1, "2.1", 3.1], lambda x: x.cast.checked.float().to_list(), TypeError)

def test_sum_returns_sum_of_the_values() -> None: assert QFloatList([1.1, 2.1, 3.1]).sum() == pytest.approx(6.3)  # pyright: ignore [reportUnknownMemberType]
def test_sum_returns_zero_on_on_empty_collection() -> None: assert QFloatList().sum() == 0

def test_min_returns_min_of_the_values() -> None: assert QFloatList([6.1, 2.1, 5.1, 3.1]).min() == 2.1
def test_min_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QFloatList().min()

def test_min_or_default_returns_min_of_the_values() -> None: assert QFloatList([6.1, 2.1, 5.1, 3.1]).min_or_default() == 2.1
def test_min_or_default_returns_0_on_on_empty_collection() -> None: assert QFloatList().min_or_default() == 0

def test_max_returns_max_of_the_values() -> None: assert QFloatList([1.1, 5.1, 3.1]).max() == 5.1
def test_max_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QFloatList().max()

def test_max_or_default_returns_max_of_the_values() -> None: assert QFloatList([1.1, 5.1, 3.1]).max_or_default() == 5.1
def test_max_or_default_returns_0_on_on_empty_collection() -> None: assert QFloatList().max_or_default() == 0

def test_average_returns_average_of_the_values() -> None: assert QFloatList([1.1, 2.1, 3.1]).average() == 2.1
def test_average_throws_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QFloatList().average()

def test_average_or_default_returns_average_of_the_values() -> None: assert QFloatList([1.1, 2.1, 3.1]).average_or_default() == 2.1
def test_average_or_default_returns_0_on_on_empty_collection() -> None: assert QFloatList().average_or_default() == 0

def test_to_list_returns_a_list_with_the_same_elements() -> None: assert QFloatList([1.1, 2.1, 3.1]).to_list() == [1.1, 2.1, 3.1]
def test_to_set_returns_a_set_with_the_same_elements() -> None: assert QFloatList([1.1, 2.1, 3.1]).to_set() == {1.1, 2.1, 3.1}
def test_to_frozenset_returns_a_frozenset_with_the_same_elements() -> None: assert QFloatList([1.1, 2.1, 3.1]).to_frozenset() == frozenset({1.1, 2.1, 3.1})
def test_to_sequence_returns_a_sequence_with_the_same_elements() -> None: assert QFloatList([1.1, 2.1, 3.1]).to_sequence().to_list() == [1.1, 2.1, 3.1]
</file>

<file path="queryablecollections_tests/numeric/test_q_fraction_iterable.py">
from __future__ import annotations

from fractions import Fraction

from queryablecollections.collections.numeric.q_fraction_types import QFractionList
from queryablecollections.q_errors import EmptyIterableError
from test_common_helpers import *


def test_cast_fraction_returns_an_q_iterable_fraction_with_the_same_elements() -> None:
    value_test_including_unordered_collections([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)], lambda x: x.cast.fraction().to_list(), [Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)])

def test_cast_checked_fraction_returns_a_q_iterable_fraction_with_the_same_elements() -> None:
    value_test_including_unordered_collections([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)], lambda x: x.cast.checked.fraction().to_list(), [Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)])

def test_cast_checked_fraction_raises_type_error_if_collection_contains_non_fraction() -> None:
    throws_test([Fraction(11, 10), "2.1", Fraction(31, 10)], lambda x: x.cast.checked.fraction().to_list(), TypeError)

def test_sum_returns_sum_of_the_values() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).sum() == Fraction(63, 10)
def test_sum_returns_zero_on_on_empty_collection() -> None: assert QFractionList().sum() == Fraction(0)

def test_min_returns_min_of_the_values() -> None: assert QFractionList([Fraction(61, 10), Fraction(21, 10), Fraction(51, 10), Fraction(31, 10)]).min() == Fraction(21, 10)
def test_min_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QFractionList().min()

def test_min_or_default_returns_min_of_the_values() -> None: assert QFractionList([Fraction(61, 10), Fraction(21, 10), Fraction(51, 10), Fraction(31, 10)]).min_or_default() == Fraction(21, 10)
def test_min_or_default_returns_0_on_on_empty_collection() -> None: assert QFractionList().min_or_default() == Fraction(0)

def test_max_returns_max_of_the_values() -> None: assert QFractionList([Fraction(11, 10), Fraction(51, 10), Fraction(31, 10)]).max() == Fraction(51, 10)
def test_max_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QFractionList().max()

def test_max_or_default_returns_max_of_the_values() -> None: assert QFractionList([Fraction(11, 10), Fraction(51, 10), Fraction(31, 10)]).max_or_default() == Fraction(51, 10)
def test_max_or_default_returns_0_on_on_empty_collection() -> None: assert QFractionList().max_or_default() == Fraction(0)

def test_average_returns_average_of_the_values() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).average() == Fraction(21, 10)
def test_average_throws_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QFractionList().average()

def test_average_or_default_returns_average_of_the_values() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).average_or_default() == Fraction(21, 10)
def test_average_or_default_returns_0_on_on_empty_collection() -> None: assert QFractionList().average_or_default() == Fraction(0)

def test_to_list_returns_a_list_with_the_same_elements() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).to_list() == [Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]
def test_to_set_returns_a_set_with_the_same_elements() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).to_set() == {Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)}
def test_to_frozenset_returns_a_frozenset_with_the_same_elements() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).to_frozenset() == frozenset({Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)})
def test_to_sequence_returns_a_sequence_with_the_same_elements() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).to_sequence().to_list() == [Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]
</file>

<file path="queryablecollections_tests/numeric/test_q_int_iterable.py">
from __future__ import annotations

from queryablecollections.collections.numeric.q_int_types import QIntList
from queryablecollections.q_errors import EmptyIterableError
from test_common_helpers import *


def test_cast_int_returns_an_q_iterable_int_with_the_same_elements() -> None:
    value_test_including_unordered_collections([1, 2, 3], lambda x: x.cast.int().to_list(), [1, 2, 3])

def test_cast_checked_int_returns_a_q_iterable_int_with_the_same_elements() -> None:
    value_test_including_unordered_collections([1, 2, 3], lambda x: x.cast.checked.int().to_list(), [1, 2, 3])

def test_cast_checked_int_raises_type_error_if_collection_contains_non_int() -> None:
    throws_test([1, "2", 3], lambda x: x.cast.checked.int().to_list(), TypeError)

def test_sum_returns_sum_of_the_values() -> None: assert QIntList([1, 2, 3]).sum() == 6
def test_sum_returns_zero_on_on_empty_collection() -> None: assert QIntList().sum() == 0

def test_min_returns_min_of_the_values() -> None: assert QIntList([6, 2, 5, 3]).min() == 2
def test_min_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QIntList().min()

def test_min_or_default_returns_min_of_the_values() -> None: assert QIntList([6, 2, 5, 3]).min_or_default() == 2
def test_min_or_default_returns_0_on_on_empty_collection() -> None: assert QIntList().min_or_default() == 0

def test_max_returns_max_of_the_values() -> None: assert QIntList([1, 5, 3]).max() == 5
def test_max_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QIntList().max()

def test_max_or_default_returns_max_of_the_values() -> None: assert QIntList([1, 5, 3]).max_or_default() == 5
def test_max_or_default_returns_0_on_on_empty_collection() -> None: assert QIntList().max_or_default() == 0

def test_average_returns_average_of_the_values() -> None: assert QIntList([1, 2, 3]).average() == 2
def test_average_throws_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QIntList().average()

def test_average_or_default_returns_average_of_the_values() -> None: assert QIntList([1, 2, 3]).average_or_default() == 2
def test_average_or_default_returns_0_on_on_empty_collection() -> None: assert QIntList().average_or_default() == 0

def test_to_list_returns_a_list_with_the_same_elements() -> None: assert QIntList([1, 2, 3]).to_list() == [1, 2, 3]
def test_to_set_returns_a_set_with_the_same_elements() -> None: assert QIntList([1, 2, 3]).to_set() == {1, 2, 3}
def test_to_frozenset_returns_a_frozenset_with_the_same_elements() -> None: assert QIntList([1, 2, 3]).to_frozenset() == frozenset({1, 2, 3})
def test_to_sequence_returns_a_sequence_with_the_same_elements() -> None: assert QIntList([1, 2, 3]).to_sequence().to_list() == [1, 2, 3]
</file>

<file path="queryablecollections_tests/q_iterable/test_aggregate_seed_result.py">
from __future__ import annotations

from test_common_helpers import lists_value_test


def test_aggregate_seed_result_sums_and_formats() -> None:
    lists_value_test([1, 2, 3, 4, 5],
                     lambda x: x.aggregate(lambda acc, item: acc + item, 0, lambda result: f"Sum: {result}"),
                     "Sum: 15")

def test_aggregate_seed_result_builds_dict_and_gets_count() -> None:
    lists_value_test(["apple", "banana", "apple", "cherry", "banana", "apple"],
                     lambda x: x.aggregate(lambda acc, item: {**acc, item: acc.get(item, 0) + 1}, dict[str, int](), lambda result: result.get("apple", 0)),
                     3)

def test_aggregate_seed_result_collects_and_joins() -> None:
    lists_value_test([1, 2, 3, 4, 5],
                     lambda x: x.aggregate(lambda acc, item: acc + [str(item * item)], list[str](), lambda squares: " + ".join(squares)),
                     "1 + 4 + 9 + 16 + 25")

def test_aggregate_seed_result_works_with_empty_sequence() -> None:
    lists_value_test(list[int](),
                     lambda x: x.aggregate(lambda acc, item: acc + item, 0, lambda result: f"Result: {result}"),
                     "Result: 0")

def test_aggregate_seed_result_calculates_average() -> None:
    lists_value_test([2, 4, 6, 8],
                     lambda x: x.aggregate(lambda acc, item: {"sum": acc["sum"] + item, "count": acc["count"] + 1}, {"sum": 0, "count": 0}, lambda result: result["sum"] / result["count"] if result["count"] > 0 else 0),
                     5.0)

def test_aggregate_with_different_types() -> None:
    lists_value_test([1, 2, 3, 4, 5],
                     lambda x: x.aggregate(lambda acc, item: acc + str(item), "", lambda result: int(result)),
                     12345)
</file>

<file path="queryablecollections_tests/q_iterable/test_aggregate_seed.py">
from __future__ import annotations

from test_common_helpers import lists_value_test


def test_aggregate_maintains_order() -> None:
    lists_value_test([1, 2, 3, 4],
                     lambda x: x.aggregate(lambda acc, item: [item] + acc, []),
                     [4, 3, 2, 1])

def test_aggregate_seed_sums_with_initial_value() -> None:
    lists_value_test([1, 2, 3, 4, 5],
                     lambda x: x.aggregate(lambda acc, item: acc + item, 10),
                     25)

def test_aggregate_seed_builds_list() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.aggregate(lambda acc, item: acc + [item * 2], list[int]()),
                     [2, 4, 6])

def test_aggregate_seed_counts_elements() -> None:
    lists_value_test(["a", "bb", "ccc"],
                     lambda x: x.aggregate(lambda count, _: count + 1, 0),
                     3)

def test_aggregate_seed_works_with_empty_sequence() -> None:
    lists_value_test(list[str](),
                     lambda x: x.aggregate(lambda acc, item: acc + item, "initial"),
                     "initial")

def test_aggregate_seed_concatenates_with_separator() -> None:
    lists_value_test(["apple", "banana", "cherry"],
                     lambda x: x.aggregate(lambda acc, item: acc + (", " if acc else "") + item, ""),
                     "apple, banana, cherry")
</file>

<file path="queryablecollections_tests/q_iterable/test_aggregate.py">
from __future__ import annotations

from queryablecollections.q_errors import EmptyIterableError
from test_common_helpers import QList, lists_value_test, throws_test


def test_summing_numbers_returns_sum_of_the_elements() -> None:
    lists_value_test([1, 2, 3, 4, 5],
                     lambda x: x.aggregate(lambda acc, item: acc + item),
                     15)

def test_concatenates_strings_returns_all_strings_combined() -> None:
    lists_value_test(["hello", " ", "world", "!"],
                     lambda x: x.aggregate(lambda acc, item: acc + item),
                     "hello world!")

def test_aggregate_single_element_returns_that_element() -> None:
    lists_value_test([42],
                     lambda x: x.aggregate(lambda acc, item: acc + item),
                     42)

def test_aggregate_throws_on_empty_sequence() -> None:
    throws_test(QList[int](),
                lambda x: x.aggregate(lambda acc, item: acc + item),
                EmptyIterableError)
</file>

<file path="queryablecollections_tests/q_iterable/test_all.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_returns_true_if_all_elements_match_predicate() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.all(lambda y: y != 0),
                                               True)

def test_eturns_false_if_any_element_does_not_match_predicate() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.all(lambda y: y != 1),
                                               False)
</file>

<file path="queryablecollections_tests/q_iterable/test_any.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_any_returns_true_if_there_are_elements() -> None:
    value_test_including_unordered_collections([1],
                                               lambda x: x.any(),
                                               True)

def test_any_returns_false_if_there_are_no_elements() -> None:
    value_test_including_unordered_collections([],
                                               lambda x: x.any(),
                                               False)
</file>

<file path="queryablecollections_tests/q_iterable/test_as_.py">
from __future__ import annotations

from decimal import Decimal
from fractions import Fraction

from queryablecollections.collections.numeric.q_decimal_types import QDecimalIterable
from queryablecollections.collections.numeric.q_float_types import QFloatIterable
from queryablecollections.collections.numeric.q_fraction_types import QFractionIterable
from queryablecollections.collections.numeric.q_int_types import QIntIterable
from queryablecollections.collections.q_list import QList


def test_iterable_of_int_returns_an_int_iterable_with_all_the_values_in_order() -> None:
    test = QList(("1", "2", "3")).select(int).as_ints()

    assert test.to_list() == [1, 2, 3]
    assert isinstance(test, QIntIterable)

def test_iterable_of_float_returns_a_float_iterable_with_all_the_values_in_order() -> None:
    test = QList(("1.1", "2.1", "3.1")).select(float).as_floats()

    assert test.to_list() == [1.1, 2.1, 3.1]
    assert isinstance(test, QFloatIterable)

def test_iterable_of_fraction_returns_a_fraction_iterable_with_all_the_values_in_order() -> None:
    test = QList((Fraction(1, 2), Fraction(2, 3))).as_fractions()

    assert test.to_list() == [Fraction(1, 2), Fraction(2, 3)]
    assert isinstance(test, QFractionIterable)

def test_iterable_of_decimal_returns_a_decimal_iterable_with_all_the_values_in_order() -> None:
    test = QList((Decimal("1.2"), Decimal("2.1"))).as_decimals()

    assert test.to_list() == [Decimal("1.2"), Decimal("2.1")]
    assert isinstance(test, QDecimalIterable)
</file>

<file path="queryablecollections_tests/q_iterable/test_as_iterable.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_returns_self() -> None:
    iterable = query([1, 2, 3])
    assert iterable.as_iterable() is iterable
</file>

<file path="queryablecollections_tests/q_iterable/test_cast_checked_to.py">
from __future__ import annotations

from decimal import Decimal
from fractions import Fraction

from test_common_helpers import lists_value_test, throws_test


def test_to_int_returns_q_iterable_with_same_elements_when_types_match() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.cast.checked.to(int).to_list(),
                     [1, 2, 3])

def test_to_str_returns_q_iterable_with_same_elements() -> None:
    lists_value_test(["hello", "world"],
                     lambda x: x.cast.checked.to(str).to_list(),
                     ["hello", "world"])

def test_to_fraction_returns_q_iterable_with_same_elements() -> None:
    lists_value_test([Fraction(1, 3), Fraction(2, 5)],
                     lambda x: x.cast.checked.to(Fraction).to_list(),
                     [Fraction(1, 3), Fraction(2, 5)])

def test_to_decimal_returns_q_iterable_with_same_elements() -> None:
    lists_value_test([Decimal("1.23"), Decimal("4.56")],
                     lambda x: x.cast.checked.to(Decimal).to_list(),
                     [Decimal("1.23"), Decimal("4.56")])

def test_raises_type_error_when_types_dont_match() -> None:
    throws_test([1, "2", 3],
                lambda x: x.cast.checked.to(int).to_list(),
                TypeError)

def test_raises_type_error_for_mixed_string_int() -> None:
    throws_test(["hello", 42],
                lambda x: x.cast.checked.to(str).to_list(),
                TypeError)

def test_raises_type_error_for_mixed_fraction_float() -> None:
    throws_test([Fraction(1, 3), 0.5],
                lambda x: x.cast.checked.to(Fraction).to_list(),
                TypeError)

def test_raises_type_error_for_mixed_decimal_float() -> None:
    throws_test([Decimal("1.23"), 4.56],
                lambda x: x.cast.checked.to(Decimal).to_list(),
                TypeError)
</file>

<file path="queryablecollections_tests/q_iterable/test_cast_to.py">
from __future__ import annotations

from decimal import Decimal
from fractions import Fraction

from test_common_helpers import lists_value_test


def test_to_int_returns_q_iterable_with_same_elements() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.cast.to(int).to_list(),
                     [1, 2, 3])

def test_to_str_returns_q_iterable_with_same_elements() -> None:
    lists_value_test(["a", "b", "c"],
                     lambda x: x.cast.to(str).to_list(),
                     ["a", "b", "c"])

def test_to_fraction_q_iterable_with_same_elements() -> None:
    lists_value_test([Fraction(1, 2), Fraction(3, 4)],
                     lambda x: x.cast.to(Fraction).to_list(),
                     [Fraction(1, 2), Fraction(3, 4)])

def test_to_decimal_returns_q_iterable_with_same_elements() -> None:
    lists_value_test([Decimal("1.5"), Decimal("2.7")],
                     lambda x: x.cast.to(Decimal).to_list(),
                     [Decimal("1.5"), Decimal("2.7")])
</file>

<file path="queryablecollections_tests/q_iterable/test_chunk.py">
from __future__ import annotations

from queryablecollections.q_errors import ArgumentError
from test_common_helpers import throws_test, value_test_including_unordered_collections


def test_divides_evenly_into_chunks_of_the_given_size_preserving_order() -> None:
    value_test_including_unordered_collections([1, 2, 3, 4, 5, 6],
                                               lambda x: x.chunk(2).to_list(),
                                               [[1, 2], [3, 4], [5, 6]],
                                               skip_sets=True)

def test_chunk_can_be_queried() -> None:
    value_test_including_unordered_collections([1, 2, 3, 4, 5, 6],
                                               lambda x: x.chunk(2).first().element_at(1),
                                               2,
                                               skip_sets=True)

def test_with_remainder_includes_partial_last_chunk() -> None:
    value_test_including_unordered_collections([1, 2, 3, 4, 5],
                                               lambda x: x.chunk(2).to_list(),
                                               [[1, 2], [3, 4], [5]],
                                               skip_sets=True)

def test_with_size_larger_than_collection_returns_single_chunk() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.chunk(5).to_list(),
                                               [[1, 2, 3]],
                                               skip_sets=True)

def test_with_chunk_size_one_returns_individual_elements() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.chunk(1).to_list(),
                                               [[1], [2], [3]],
                                               skip_sets=True)

def test_with_empty_collection_returns_empty() -> None:
    value_test_including_unordered_collections(list[int](),
                                               lambda x: x.chunk(2).to_list(),
                                               list[int](),
                                               skip_sets=True)

def test_chunk_with_mixed_types() -> None:
    value_test_including_unordered_collections([1, "a", 2.5, True, None],
                                               lambda x: x.chunk(2).to_list(),
                                               [[1, "a"], [2.5, True], [None]],
                                               skip_sets=True)

def test_chunk_size_zero_raises_argument_error() -> None:
    throws_test([1, 2, 3],
                lambda x: x.chunk(0).to_list(),
                ArgumentError,
                skip_sets=True)

def test_chunk_negative_size_raises_argument_error() -> None:
    throws_test([1, 2, 3],
                lambda x: x.chunk(-1).to_list(),
                ArgumentError,
                skip_sets=True)

def test_chunk_with_single_element_returns_single_chunk() -> None:
    value_test_including_unordered_collections([42],
                                               lambda x: x.chunk(1).to_list(),
                                               [[42]],
                                               skip_sets=True)
</file>

<file path="queryablecollections_tests/q_iterable/test_concat.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_concat_appends_second_sequence_to_first() -> None:
    value_test_including_unordered_collections([1, 2],
                                               lambda x: x.concat([3, 4]).to_list(),
                                               [1, 2, 3, 4])
</file>

<file path="queryablecollections_tests/q_iterable/test_contains.py">
# tests/test_contains.py
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_true_for_present_value() -> None:
    data = query([1, 2, 3, 4])
    assert data.contains(3) is True

def test_false_for_absent_value() -> None:
    data = query([1, 2, 3, 4])
    assert data.contains(5) is False

def test_contains_after_filtering() -> None:
    data = query([1, 2, 3, 4, 5]).where(lambda x: x % 2 == 0)
    assert data.contains(2) is True
    assert data.contains(1) is False

def test_contains_with_custom_equality_like_tuples() -> None:
    items = query([("a", 1), ("b", 2)])
    assert items.contains(("a", 1)) is True
    assert items.contains(("a", 2)) is False

def test_contains_for_iterable_without_fast_membership() -> None:
    # Use a generator to ensure fallback to iteration works
    gen_data = query(x for x in range(5))
    assert gen_data.contains(4) is True
    assert gen_data.contains(10) is False
</file>

<file path="queryablecollections_tests/q_iterable/test_distinct_by.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_distinct_by_removes_duplicates_by_selected_key_while_retaining_order_keeping_the_first_matched_value() -> None:
    value_test_including_unordered_collections([("a", 1),
                                                ("a", 2),
                                                ("b", 3),
                                                ("a", 4),
                                                ("b", 5)],
                                               lambda x: x.distinct_by(lambda y: y[0]).to_list(),
                                               [("a", 1),
                ("b", 3)],
                                               skip_sets=True)
</file>

<file path="queryablecollections_tests/q_iterable/test_distinct.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_distinct_removes_duplicates_while_retaining_order() -> None:
    value_test_including_unordered_collections([1, 2, 2, 3, 3],
                                               lambda x: x.distinct().to_list(),
                                               [1, 2, 3])
</file>

<file path="queryablecollections_tests/q_iterable/test_element_at_or_none.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_0_test_returns_element_1() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.element_at_or_none(0),
                                               1)

def test_1_return_element_2() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.element_at_or_none(1),
                                               2)

def test_2_returns_element_3() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.element_at_or_none(2),
                                               3)

def test_returns_none_if_index_is_out_of_range() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.element_at_or_none(3),
                                               None)
</file>

<file path="queryablecollections_tests/q_iterable/test_element_at.py">
from __future__ import annotations

from test_common_helpers import throws_test, value_test_including_unordered_collections


def test_0_returns_element_1() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.element_at(0),
                                               1)

def test_1_return_element_2() -> None: value_test_including_unordered_collections(
        [1, 2, 3],
        lambda x: x.element_at(1),
        2)

def test_2_returns_element_3() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.element_at(2),
                                               3)

def test_throws_if_index_is_out_of_range() -> None:
    throws_test((1, 2, 3),
                lambda x: x.element_at(3),
                IndexError)
</file>

<file path="queryablecollections_tests/q_iterable/test_empty.py">
from __future__ import annotations

from queryablecollections.collections.q_frozen_set import QFrozenSet
from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_sequence import QSequence
from queryablecollections.q_iterable import QIterable


def test_iterable_empty_returns_empty_sequence_the_same_instance_each_time() -> None:
    assert QIterable[str].empty() is not None
    assert QIterable[str].empty() is QIterable.empty()

def test_sequence_empty_returns_empty_sequence_the_same_instance_each_time() -> None:
    assert QSequence[str].empty() is not None
    assert QSequence[str].empty() is QSequence.empty()

def test_frozen_set_empty_returns_empty_set_same_instance_each_time() -> None:
    assert QFrozenSet[str].empty() is not None
    assert QFrozenSet[str].empty() is QFrozenSet.empty()

def test_immutable_sequence_empty_returns_empty_set_same_instance_each_time() -> None:
    assert QImmutableSequence[str].empty() is not None
    assert QImmutableSequence[str].empty() is QImmutableSequence.empty()
</file>

<file path="queryablecollections_tests/q_iterable/test_first.py">
from __future__ import annotations

from test_common_helpers import throws_test, value_test_including_unordered_collections


def test_first_returns_first_value() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.first(),
                                               1)

def test_first_returns_single_none_value() -> None:
    value_test_including_unordered_collections([None],
                                               lambda x: x.first(),
                                               None)

def test_first_or_none_returns_first_value() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.first_or_none(),
                                               1)

def test_first_or_none_return_none_if_no_values() -> None:
    value_test_including_unordered_collections([],
                                               lambda x: x.first_or_none(),
                                               None)

def test_first_or_none_returns_single_none_value() -> None:
    value_test_including_unordered_collections([None],
                                               lambda x: x.first_or_none(),
                                               None)

def test_first_throws_if_no_values() -> None:
    throws_test([], lambda x: x.first())
</file>

<file path="queryablecollections_tests/q_iterable/test_for_each.py">
from __future__ import annotations

from test_common_helpers import CallCounter, value_test_including_unordered_collections


def test_executes_action_for_each_element() -> None:
    value_test_including_unordered_collections(lambda: [CallCounter(), CallCounter(), CallCounter()],
                                               lambda x: x.for_each(lambda y: y.increment()).select(lambda y: y.call_count).to_list(),
                                               [1, 1, 1])
</file>

<file path="queryablecollections_tests/q_iterable/test_group_by.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


def test_group_by_first_character_of_string_returns_one_group_per_unique_first_character_in_the_order_encountered() -> None:
    data = ["apple", "apricot", "banana", "blueberry", "cherry"]

    groups = query(data).group_by(lambda string: string[0]).to_list()

    assert len(groups) == 3

    a_group = groups.single(lambda group: group.key == "a")
    assert a_group == groups[0]
    b_group = groups.single(lambda group: group.key == "b")
    assert b_group == groups[1]
    c_group = groups.single(lambda group: group.key == "c")
    assert c_group == groups[2]

    assert a_group == ["apple", "apricot"]
    assert b_group == ["banana", "blueberry"]
    assert c_group == ["cherry"]

def test_group_by_first_character_of_string_with_element_selector_returns_one_group_per_unique_first_character_in_the_order_encountered_and_the_values_are_the_selected_value() -> None:
    data = ["apple", "apricot", "banana", "blueberry", "cherry"]

    groups = (query(data)
              .group_by(lambda element: element[0], lambda element: len(element))
              .to_list())

    assert len(groups) == 3

    a_group = groups.single(lambda group: group.key == "a")
    assert a_group == groups[0]
    b_group = groups.single(lambda group: group.key == "b")
    assert b_group == groups[1]
    c_group = groups.single(lambda group: group.key == "c")
    assert c_group == groups[2]
    assert a_group.order_by(lambda x: x).to_list() == [len("apple"), len("apricot")]  # apple=5, apricot=7
    assert b_group == [len("banana"), len("blueberry")]
    assert c_group == [len("cherry")]

def test_group_by_empty_returns_no_groups() -> None:
    result = QList[int]([]).group_by(lambda element: element).to_list()
    assert result == []
</file>

<file path="queryablecollections_tests/q_iterable/test_group_join.py">
from __future__ import annotations

from dataclasses import dataclass

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


@dataclass
class Person:
    id: int | None
    name: str

@dataclass
class Order:
    id: int
    person_id: int | None
    amount: float

def test_returns_groups_with_all_matching_items_in_the_order_found_for_both_inner_and_outer_items() -> None:
    people = [Person(1, "Alice"), Person(2, "Bob"), Person(3, "Charlie")]
    orders = [
            Order(101, 1, 100.0), Order(102, 1, 150.0),  # Alice's orders
            Order(103, 2, 200.0),  # Bob's order
            Order(104, 3, 75.0), Order(105, 3, 300.0)  # Charlie's orders
    ]

    result = (query(people)
              .group_join(orders,
                          lambda person: person.id,
                          lambda order: order.person_id,
                          lambda person, person_orders: f"""{person.name}: {", ".join(str(order) for order in person_orders)}""")
              .to_list())

    expected = ["Alice: Order(id=101, person_id=1, amount=100.0), Order(id=102, person_id=1, amount=150.0)",
                "Bob: Order(id=103, person_id=2, amount=200.0)",
                "Charlie: Order(id=104, person_id=3, amount=75.0), Order(id=105, person_id=3, amount=300.0)"]
    assert result == expected

def test_with_no_matching_keys_returns_empty_groups() -> None:
    people = [Person(1, "Alice"), Person(2, "Bob")]
    orders = [Order(101, 3, 100.0), Order(102, 4, 200.0)]  # No matching person IDs

    result = (query(people)
              .group_join(orders,
                          lambda person: person.id,
                          lambda order: order.person_id,
                          lambda person, person_orders: f"{person.name}: {len(list(person_orders))} orders")
              .to_list())

    expected = ["Alice: 0 orders", "Bob: 0 orders"]
    assert result == expected

def test_with_empty_outer_sequence_returns_empty_result() -> None:
    people = QList[Person]()
    orders = [Order(101, 1, 100.0), Order(102, 2, 200.0)]

    result = (query(people)
              .group_join(orders,
                          lambda person: person.id,
                          lambda order: order.person_id,
                          lambda person, person_orders: f"{person.name}: {len(list(person_orders))} orders")
              .to_list())

    assert result == []

def test_with_empty_inner_sequence_returns_all_outer_with_empty_groups() -> None:
    people = [Person(1, "Alice"), Person(2, "Bob")]
    orders = QList[Order]()

    result = (query(people)
              .group_join(orders,
                          lambda person: person.id,
                          lambda order: order.person_id,
                          lambda person, person_orders: f"{person.name}: {len(list(person_orders))} orders")
              .to_list())

    expected = ["Alice: 0 orders", "Bob: 0 orders"]
    assert result == expected

def test_with_both_empty_sequences_returns_empty_result() -> None:
    people = QList[Person]()
    orders = QList[Order]()

    result = (query(people)
              .group_join(orders,
                          lambda person: person.id,
                          lambda order: order.person_id,
                          lambda person, person_orders: f"{person.name}: {len(list(person_orders))} orders")
              .to_list())

    assert result == []

def test_items_with_none_keys_match_each_other() -> None:
    people = [Person(1, "Alice"), Person(None, "Unknown")]
    orders = [Order(101, 1, 100.0), Order(102, None, 200.0)]

    result = (query(people)
              .group_join(orders,
                          lambda person: person.id,
                          lambda order: order.person_id,
                          lambda person, person_orders: f"{person.name}: {len(list(person_orders))} orders")
              .to_list())

    expected = ["Alice: 1 orders", "Unknown: 1 orders"]
    assert result == expected

def test_duplicate_keys_in_outer_sequence_stay_duplicated_and_the_same_group_appears_in_each() -> None:
    people = [Person(1, "Alice1"), Person(1, "Alice2"), Person(2, "Bob")]
    orders = [Order(101, 1, 100.0), Order(102, 2, 200.0), Order(103, 1, 100.0)]

    result = (query(people)
              .group_join(orders,
                          lambda person: person.id,
                          lambda order: order.person_id,
                          lambda person, person_orders: f"{person.name}: {len(list(person_orders))} orders")
              .to_list())

    expected = ["Alice1: 2 orders", "Alice2: 2 orders", "Bob: 1 orders"]
    assert result == expected
</file>

<file path="queryablecollections_tests/q_iterable/test_indexer.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_indexer_returns_first_value() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.to_list()[0],
                                               1)

def test_indexer_returns_middle_value() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.to_list()[1],
                                               2)

def test_indexer_returns_last_value() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.to_list()[2],
                                               3)
</file>

<file path="queryablecollections_tests/q_iterable/test_join.py">
from __future__ import annotations

from dataclasses import dataclass

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


@dataclass
class Person:
    id: int | None
    name: str

@dataclass
class Order:
    id: int
    person_id: int | None
    amount: float

class TestJoin:
    def test_join_with_matching_keys_returns_combined_results(self) -> None:
        people = [Person(1, "Alice"), Person(2, "Bob")]
        orders = [Order(101, 1, 100.0), Order(102, 2, 200.0), Order(103, 1, 150.0)]

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        expected = ["Alice: $100.0", "Alice: $150.0", "Bob: $200.0"]
        assert result == expected

    def test_join_with_no_matching_keys_returns_empty_sequence(self) -> None:
        people = [Person(1, "Alice"), Person(2, "Bob")]
        orders = [Order(101, 3, 100.0), Order(102, 4, 200.0)]

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        assert result == []

    def test_join_with_empty_outer_sequence_returns_empty_sequence(self) -> None:
        people = QList[Person]()
        orders = [Order(101, 1, 100.0), Order(102, 2, 200.0)]

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        assert result == []

    def test_join_with_empty_inner_sequence_returns_empty_sequence(self) -> None:
        people = [Person(1, "Alice"), Person(2, "Bob")]
        orders = QList[Order]()

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        assert result == []

    def test_join_with_both_empty_sequences_returns_empty_sequence(self) -> None:
        people = QList[Person]()
        orders = QList[Order]()

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        assert result == []

    def test_join_with_simple_types_works_correctly(self) -> None:
        numbers = [1, 2, 3, 2]
        letters = ["a", "1a", "c", "3a", "2a", "4a"]

        result = (query(numbers)
                  .join(letters,
                        lambda this: str(this),
                        lambda other: other[0],
                        lambda this, other: f"{this}-{other}")
                  .to_list())

        assert result == ["1-1a", "2-2a", "3-3a", "2-2a"]

    def test_join_with_different_key_types_works_correctly(self) -> None:
        # Test with string keys
        categories = [("tech", "Technology"), ("health", "Health")]
        products = [("laptop", "tech"), ("tablet", "tech"), ("vitamins", "health")]

        result = (query(categories)
                  .join(products,
                        lambda this: this[0],  # category id
                        lambda other: other[1],  # product category
                        lambda this, other: f"{other[0]} in {this[1]}")
                  .to_list())

        expected = ["laptop in Technology", "tablet in Technology", "vitamins in Health"]
        assert result == expected

    def test_join_is_lazy(self) -> None:
        call_count = 0

        def counting_result_selector(p: Person, o: Order) -> str:
            nonlocal call_count
            call_count += 1
            return f"{p.name}: ${o.amount}"

        people = [Person(1, "Alice"), Person(2, "Bob")]
        orders = [Order(101, 1, 100.0), Order(102, 2, 200.0)]

        joined = query(people).join(orders,
                                    lambda this: this.id,
                                    lambda other: other.person_id,
                                    counting_result_selector)

        assert call_count == 0

        result = joined.to_list()
        assert call_count == 2
        assert result == ["Alice: $100.0", "Bob: $200.0"]

    def test_join_with_none_keys_match_each_other(self) -> None:
        people = [Person(1, "Alice"), Person(None, "Bob")]
        orders = [Order(101, 1, 100.0), Order(102, None, 200.0)]  # type: ignore

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        expected = ["Alice: $100.0", "Bob: $200.0"]
        assert result == expected

    def test_join_with_duplicate_keys_in_outer_sequence(self) -> None:
        people = [Person(1, "Alice"), Person(1, "Alice2"), Person(2, "Bob")]
        orders = [Order(101, 1, 100.0), Order(102, 2, 200.0)]

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        expected = ["Alice: $100.0", "Alice2: $100.0", "Bob: $200.0"]
        assert result == expected
</file>

<file path="queryablecollections_tests/q_iterable/test_last_or_none.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_returns_last_value() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.last_or_none(),
                                               3)

def test_return_none_if_no_values() -> None:
    value_test_including_unordered_collections([],
                                               lambda x: x.last_or_none(),
                                               None)

def test_returns_none_when_no_match_to_predicate() -> None:
    value_test_including_unordered_collections([1, 3, 5],
                                               lambda x: x.last_or_none(lambda y: y % 2 == 0),
                                               None)
</file>

<file path="queryablecollections_tests/q_iterable/test_last.py">
from __future__ import annotations

from queryablecollections.q_errors import EmptyIterableError
from test_common_helpers import throws_test, value_test_including_unordered_collections


def test_returns_last_value() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.last(),
                                               3)

def test_returns_single_none_value() -> None:
    value_test_including_unordered_collections([None],
                                               lambda x: x.last(),
                                               None)

def test_with_predicate_returns_last_matching_value() -> None:
    value_test_including_unordered_collections([1, 2, 3, 4, 5],
                                               lambda x: x.last(lambda y: y < 5),
                                               4)

def test_with_predicate_raises_if_no_match() -> None:
    throws_test([1, 3, 5],
                lambda x: x.last(lambda y: y > 5),
                EmptyIterableError)

def test_throws_if_no_values() -> None:
    throws_test([],
                lambda x: x.last(),
                EmptyIterableError)

def test_throws_if_no_match_for_predicate() -> None:
    throws_test([1, 3, 5],
                lambda x: x.last(lambda y: y % 2 == 0),
                EmptyIterableError)
</file>

<file path="queryablecollections_tests/q_iterable/test_max_by.py">
from __future__ import annotations

import pytest
from queryablecollections.q_errors import EmptyIterableError
from test_common_helpers import lists_value_test, throws_test


def test_max_by_returns_item_with_largest_key() -> None:
    lists_value_test(
        ["apple", "banana", "cherry", "fig"],
        lambda x: x.max_by(len),
        "banana"  # "banana" and "cherry" have len 6, first wins
    )

def test_max_by_raises_on_empty() -> None:
    with pytest.raises(EmptyIterableError):
        lists_value_test(list[str](), lambda x: x.max_by(len), None)  # value ignored due to exception


def test_max_by_with_ties_returns_first_encountered() -> None:
    lists_value_test(
        ["aa", "bbb", "cc", "ddd", "e"],
        lambda x: x.max_by(len),
        "bbb"  # len 3 tie with "ddd", first wins
    )

def test_raises_type_error_if_selector_returns_non_comparable() -> None:
    class NonComparable:
        def __init__(self, value: str) -> None:
            self.value = value

    throws_test(
            ["a", "b", "c"],
            lambda x: x.max_by(lambda y: NonComparable(y)),  # pyright: ignore [reportArgumentType]
            TypeError
    )
</file>

<file path="queryablecollections_tests/q_iterable/test_min_by.py">
from __future__ import annotations

import pytest
from queryablecollections.q_errors import EmptyIterableError
from test_common_helpers import lists_value_test, throws_test


def test_min_by_returns_item_with_smallest_key() -> None:
    lists_value_test(
            ["apple", "banana", "cherry", "fig"],
            lambda x: x.min_by(len),
            "fig"
    )

def test_min_by_raises_on_empty() -> None:
    with pytest.raises(EmptyIterableError):
        lists_value_test(list[str](), lambda x: x.min_by(len), None)  # value ignored due to exception

def test_min_by_with_ties_returns_first_encountered() -> None:
    lists_value_test(
            ["a1", "b2", "c", "d", "ee", "ff"],
            lambda x: x.min_by(len),
            "c"  # len 1 appears at "c" first among length-1 items ("c", "d")
    )

def test_raises_type_error_if_selector_returns_non_comparable() -> None:
    class NonComparable:
        def __init__(self, value: str) -> None:
            self.value = value

    throws_test(
            ["a", "b", "c"],
            lambda x: x.min_by(lambda y: NonComparable(y)),  # pyright: ignore [reportArgumentType]
            TypeError
    )
</file>

<file path="queryablecollections_tests/q_iterable/test_none.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_none_returns_false_if_there_are_elements() -> None:
    value_test_including_unordered_collections([1],
                                               lambda x: x.none(),
                                               False)

def test_none_returns_true_if_there_are_no_elements() -> None:
    value_test_including_unordered_collections([],
                                               lambda x: x.none(),
                                               True)
</file>

<file path="queryablecollections_tests/q_iterable/test_not_none.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from test_common_helpers import value_test_including_unordered_collections


def test_not_none_returns_only_elements_that_are_not_none() -> None:
    value_test_including_unordered_collections([1, None],
                                               lambda x: x.where_not_none().to_list(),
                                               [1])

def test_not_none_returns_empty_list_if_all_elements_are_none() -> None:
    value_test_including_unordered_collections(QList[str | None]([None, None]),
                                               lambda x: x.where_not_none().to_list(),
                                               list[str]())
</file>

<file path="queryablecollections_tests/q_iterable/test_of_type.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_of_type_filters_by_type() -> None:
    mixed_type_values = query([1, "hello", 2.5, "world", 42, 3.14, True, False])

    assert mixed_type_values.of_type(str).to_list() == ["hello", "world"]
    assert mixed_type_values.of_type(int).to_list() == [1, 42, True, False]  # note: bool is a subclass of int in Python
    assert mixed_type_values.of_type(float).to_list() == [2.5, 3.14]

def test_of_type_with_inheritance() -> None:
    class Animal:
        def __init__(self, name: str) -> None:
            self.name = name

    class Dog(Animal): pass

    class Cat(Animal): pass

    mixed_animals = query([Dog("Buddy"),
                           Cat("Whiskers"),
                           Dog("Rex"),
                           Animal("Generic"),
                           Cat("Mittens")])

    dogs = mixed_animals.of_type(Dog).to_list()
    assert len(dogs) == 2
    assert all(isinstance(dog, Dog) for dog in dogs)
    assert dogs.select(lambda dog: dog.name).to_list() == ["Buddy", "Rex"]

    cats = mixed_animals.of_type(Cat).to_list()
    assert len(cats) == 2
    assert all(isinstance(cat, Cat) for cat in cats)
    assert cats.select(lambda cat: cat.name).to_list() == ["Whiskers", "Mittens"]

    all_animals = mixed_animals.of_type(Animal).to_list()
    assert len(all_animals) == 5
    assert all(isinstance(animal, Animal) for animal in all_animals)

def test_if_there_are_no_floats_of_type_float_returns_no_elements() -> None:
    assert (query([1, 2, 3, "hello", "world"]).of_type(float)
            .to_list()) == []

def test_of_type_string_returns_all_strings() -> None:
    assert (query(["apple", "banana", "cherry"])
            .of_type(str).to_list() == ["apple", "banana", "cherry"])

def test_of_type_with_none_values_only_returns_none_values_if_the_given_type_was_none() -> None:
    list_including_none_values = [1, None, "hello", None, 2.5, None]

    assert query(list_including_none_values).of_type(str).to_list() == ["hello"]

    assert query(list_including_none_values).of_type(int).to_list() == [1]

    assert query(list_including_none_values).of_type(type(None)).to_list() == [None, None, None]
</file>

<file path="queryablecollections_tests/q_iterable/test_order_by.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_order_by_sorts_in_ascending_order() -> None:
    value_test_including_unordered_collections([3, 2, 1],
                                               lambda input: input.order_by(lambda y: y).to_list(),
                                               [1, 2, 3])

def test_order_by_descending_sorts_in_descending_order() -> None:
    value_test_including_unordered_collections([3, 2, 1],
                                               lambda input: input.order_by_descending(lambda y: y).to_list(),
                                               [3, 2, 1])

def test_then_by_sorts_in_ascending_order() -> None:
    value_test_including_unordered_collections([3, 2, 1],
                                               lambda input: input
                                               .order_by(lambda item: item)
                                               .then_by(lambda item: item).to_list(),
                                               [1, 2, 3])

    value_test_including_unordered_collections([3, 2, 1],
                                               lambda iterable: iterable
                                               .order_by(lambda item: item)
                                               .then_by(lambda item: 1 if item == 1 else 0).to_list(),
                                               [2, 3, 1])

def test_then_by_descending_sorts_in_descending_order() -> None:
    value_test_including_unordered_collections([3, 2, 1],
                                               lambda x: x.order_by(lambda y: y).then_by_descending(lambda y: y).to_list(), [3, 2, 1])
    value_test_including_unordered_collections([3, 2, 1],
                                               lambda x: x.order_by(lambda y: y).then_by_descending(lambda y: 1 if y == 2 else 0).to_list(), [2, 1, 3])
</file>

<file path="queryablecollections_tests/q_iterable/test_prepend.py">
from __future__ import annotations

from test_common_helpers import lists_value_test


def test_adds_single_element_to_beginning() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.prepend(0).to_list(),
                     [0, 1, 2, 3])

def test_to_empty_collection_returns_single_element() -> None:
    lists_value_test([],
                     lambda x: x.prepend(42).to_list(),
                     [42])

def test_works_with_none_value() -> None:
    lists_value_test([1, None, 3],
                     lambda x: x.prepend(None).to_list(),
                     [None, 1, None, 3])

def test_different_type_to_mixed_collection() -> None:
    lists_value_test([1, "hello", 3.14],
                     lambda x: x.prepend(True).to_list(),
                     [True, 1, "hello", 3.14])

def test_multiple_prepends_chain_correctly() -> None:
    lists_value_test([3, 4],
                     lambda x: x.prepend(2).prepend(1).prepend(0).to_list(),
                     [0, 1, 2, 3, 4])

def test_works_with_single_element_collection() -> None:
    lists_value_test([42],
                     lambda x: x.prepend(24).to_list(),
                     [24, 42])

def test_prepend_and_append_work_together() -> None:
    lists_value_test([2, 3],
                     lambda x: x.prepend(1).qappend(4).to_list(),
                     [1, 2, 3, 4])

def test_preserves_order_with_strings() -> None:
    lists_value_test(["world"],
                     lambda x: x.prepend("hello").to_list(),
                     ["hello", "world"])

def test_works_with_duplicate_values() -> None:
    lists_value_test([1, 2, 1],
                     lambda x: x.prepend(1).to_list(),
                     [1, 1, 2, 1])
</file>

<file path="queryablecollections_tests/q_iterable/test_qappend.py">
from __future__ import annotations

from test_common_helpers import lists_value_test


def test_adds_single_element_to_end() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.qappend(4).to_list(),
                     [1, 2, 3, 4])

def test_to_empty_collection_returns_single_element() -> None:
    lists_value_test([],
                     lambda x: x.qappend(42).to_list(),
                     [42])

def test_works_with_none_value() -> None:
    lists_value_test([1, None, 3],
                     lambda x: x.qappend(None).to_list(),
                     [1, None, 3, None])

def test_different_type_to_mixed_collection() -> None:
    lists_value_test([1, "hello", 3.14],
                     lambda x: x.qappend(True).to_list(),
                     [1, "hello", 3.14, True])

def test_multiple_appends_chain_correctly() -> None:
    lists_value_test([1, 2],
                     lambda x: x.qappend(3).qappend(4).qappend(5).to_list(),
                     [1, 2, 3, 4, 5])

def test_works_with_single_element_collection() -> None:
    lists_value_test([42],
                     lambda x: x.qappend(24).to_list(),
                     [42, 24])
</file>

<file path="queryablecollections_tests/q_iterable/test_qcount_by.py">
from __future__ import annotations

from queryablecollections.collections.q_key_value_pair import KeyValuePair
from test_common_helpers import QList, lists_value_test, query


def to_tuple[TKey, TValue](x: KeyValuePair[TKey, TValue]) -> tuple[TKey, TValue]:
    return x.key, x.value


def test_count_by_returns_count_of_each_key() -> None:
    lists_value_test([1, 2, 2, 3, 3, 3],
                     lambda x: x.qcount_by(lambda y: y).select(to_tuple).to_list(),
                     [(1, 1), (2, 2), (3, 3)])

def test_count_by_with_string_keys() -> None:
    lists_value_test(["apple", "banana", "apple", "cherry", "banana", "apple"],
                     lambda x: x.qcount_by(lambda y: y).select(to_tuple).to_list(),
                     [("apple", 3), ("banana", 2), ("cherry", 1)])

def test_count_by_with_key_selector_function() -> None:
    lists_value_test(["apple", "apricot", "banana", "blueberry", "cherry"],
                     lambda x: x.qcount_by(lambda word: word[0]).select(to_tuple).to_list(),
                     [("a", 2), ("b", 2), ("c", 1)])

def test_count_by_with_length_selector() -> None:
    lists_value_test(["cat", "dog", "elephant", "ant", "bee"],
                     lambda x: x.qcount_by(lambda word: len(word)).select(to_tuple).to_list(),
                     [(3, 4), (8, 1)])

def test_count_by_empty_collection_returns_empty_result() -> None:
    lists_value_test(QList[int](),
                     lambda x: x.qcount_by(lambda y: y).select(to_tuple).to_list(),
                     QList[int]())

def test_count_by_single_element_returns_single_count() -> None:
    lists_value_test([42],
                     lambda x: x.qcount_by(lambda y: y).select(to_tuple).to_list(),
                     [(42, 1)])

def test_count_by_all_same_elements_returns_single_entry() -> None:
    lists_value_test([5, 5, 5, 5],
                     lambda x: x.qcount_by(lambda y: y).select(to_tuple).to_list(),
                     [(5, 4)])

def test_count_by_with_none_values() -> None:
    lists_value_test([1, None, 2, None, None],
                     lambda x: x.qcount_by(lambda y: y).select(to_tuple).to_list(),
                     [(1, 1), (None, 3), (2, 1)])

def test_count_by_with_boolean_selector() -> None:
    lists_value_test([1, 2, 3, 4, 5, 6],
                     lambda x: x.qcount_by(lambda y: y % 2 == 0).select(to_tuple).to_list(),
                     [(False, 3), (True, 3)])

def test_count_by_preserves_key_order_of_first_occurrence() -> None:
    lists_value_test([3, 1, 2, 1, 3, 2],
                     lambda x: x.qcount_by(lambda y: y).select(to_tuple).to_list(),
                     [(3, 2), (1, 2), (2, 2)])

def test_count_by_with_mixed_types() -> None:
    lists_value_test([1, "hello", 2.5, "hello", 1, True],
                     lambda x: x.qcount_by(lambda y: type(y).__name__).select(to_tuple).to_list(),
                     [("int", 2), ("str", 2), ("float", 1), ("bool", 1)])

def test_count_by_maintains_insertion_order() -> None:
    lists_value_test(["z", "a", "z", "b", "a", "z"],
                     lambda x: x.qcount_by(lambda x: x).select(to_tuple).to_list(),
                     [("z", 3), ("a", 2), ("b", 1)])

def test_count_by_can_be_chained_with_other_operations() -> None:
    lists_value_test([1, 2, 2, 3, 3, 3],
                     lambda x: x.qcount_by(lambda x: x).where(lambda kv: kv.value > 1).select(to_tuple).to_list(),
                     [(2, 2), (3, 3)])

def test_count_by_with_duplicate_consecutive_values() -> None:
    lists_value_test([1, 1, 2, 2, 2, 1],
                     lambda x: x.qcount_by(lambda x: x).select(to_tuple).to_list(),
                     [(1, 3), (2, 3)])

def test_count_by_with_complex_objects() -> None:
    class Person:
        def __init__(self, name: str, age: int) -> None:
            self.name = name
            self.age = age

    people = [Person("Alice", 25), Person("Bob", 30), Person("Charlie", 25), Person("Diana", 30)]
    lists_value_test(people,
                     lambda x: x.qcount_by(lambda p: p.age).select(to_tuple).to_list(),
                     [(25, 2), (30, 2)])

def test_count_by_returns_proper_key_value_pairs() -> None:
    result = query([1, 2, 2, 3]).qcount_by(lambda x: x).first()
    assert isinstance(result, KeyValuePair)
    assert result.key == 1
    assert result.value == 1
</file>

<file path="queryablecollections_tests/q_iterable/test_qcount.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_returns_element_count_of_sequence() -> None:
    value_test_including_unordered_collections([0], lambda x: x.qcount(), 1)
    value_test_including_unordered_collections([0, 3], lambda x: x.qcount(), 2)
    value_test_including_unordered_collections([0, 3, 5], lambda x: x.qcount(), 3)
</file>

<file path="queryablecollections_tests/q_iterable/test_qexcept.py">
from __future__ import annotations

from test_common_helpers import lists_value_test


def test_removes_elements_present_in_other_collection_without_changing_the_order() -> None:
    lists_value_test([1, 2, 3, 4, 5],
                     lambda x: x.qexcept([3, 4, 6, 7]).to_list(),
                     [1, 2, 5])

def test_removes_duplicates_from_result() -> None:
    lists_value_test([1, 2, 2, 3, 3, 4],
                     lambda x: x.qexcept([3, 4]).to_list(),
                     [1, 2])

def test_with_empty_other_returns_distinct_elements_from_first() -> None:
    lists_value_test([1, 2, 2, 3],
                     lambda x: x.qexcept([]).to_list(),
                     [1, 2, 3])

def test_with_empty_first_returns_empty() -> None:
    lists_value_test([],
                     lambda x: x.qexcept([1, 2, 3]).to_list(),
                     list[int]())

def test_with_no_matching_elements_returns_distinct_elements_from_first() -> None:
    lists_value_test([1, 2, 3, 3],
                     lambda x: x.qexcept([4, 5, 6]).to_list(),
                     [1, 2, 3])

def test_with_all_matching_elements_returns_empty() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.qexcept([1, 2, 3, 4]).to_list(),
                     list[int]())

def test_works_with_strings() -> None:
    lists_value_test(["apple", "banana", "cherry", "date"],
                     lambda x: x.qexcept(["banana", "date", "elderberry"]).to_list(),
                     ["apple", "cherry"])

def test_works_with_bool_types() -> None:
    lists_value_test([True, False, True, False],
                     lambda x: x.qexcept([False]).to_list(),
                     [True])

def test_works_with_mixed_types() -> None:
    lists_value_test([1, "hello", 2.5, True, None, False, 0],
                     lambda x: x.qexcept(["hello", 2.5, False]).to_list(),
                     [1, None]) #note, python considers 1 and True to be equal and False and 0 to be equal, that's why the True, and the 0 are gone. It's not a bug in this implementation, it's unfixable in python.

def test_with_none_values() -> None:
    lists_value_test([1, None, 2, None, 3],
                     lambda x: x.qexcept([None, 2]).to_list(),
                     [1, 3])

def test_with_none_values_retain_none_values_unless_excluded() -> None:
    lists_value_test([1, None, 2, None, 3],
                     lambda x: x.qexcept([2]).to_list(),
                     [1, None, 3])
</file>

<file path="queryablecollections_tests/q_iterable/test_qindex.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_returns_tuple_of_index_and_item() -> None:
    value_test_including_unordered_collections([10, 20, 30],
                                               lambda x: x.qindex().to_list(),
                                               [(0, 10), (1, 20), (2, 30)],
                                               skip_sets=True)

def test_with_empty_collection_returns_empty() -> None:
    value_test_including_unordered_collections(list[int](),
                                               lambda x: x.qindex().to_list(),
                                               list[tuple[int, int]](),
                                               skip_sets=True)
</file>

<file path="queryablecollections_tests/q_iterable/test_qintersect.py">
from __future__ import annotations

from test_common_helpers import lists_value_test


def test_returns_common_elements_preserving_first_order_and_distinct() -> None:
    lists_value_test([1, 2, 2, 3, 4, 5],
                     lambda x: x.qintersect([2, 3, 6, 2]).to_list(),
                     [2, 3])

def test_returns_common_elements_preserving_first_order_and_distinct_another_verification_of_order_since_we_seem_to_have_some_issue() -> None:
    lists_value_test([5, 4, 3, 2, 1],
                     lambda x: x.qintersect([1, 2, 3, 4, 5]).to_list(),
                     [5, 4, 3, 2, 1])

def test_with_empty_first_returns_empty() -> None:
    lists_value_test([],
                     lambda x: x.qintersect([1, 2, 3]).to_list(),
                     list[int]())

def test_with_empty_second_returns_empty() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.qintersect([]).to_list(),
                     list[int]())

def test_with_no_common_elements_returns_empty() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.qintersect([4, 5, 6]).to_list(),
                     list[int]())

def test_with_strings() -> None:
    lists_value_test(["apple", "banana", "cherry", "banana"],
                     lambda x: x.qintersect(["banana", "date"]).to_list(),
                     ["banana"])

def test_with_mixed_types() -> None:
    lists_value_test([1, "hello", 2.5, True, None, False, 0],
                     # since in python True equals 1 and False equals 0 we cannot reliably assert using any of True, False, 1, 0, so we get to convert to strings to see what is actually happening....
                     lambda x: x.qintersect([True, "hello", 3.14, 0, False]).select(str).to_list(),
                     ["1", "hello", "False"])

def test_with_none_values() -> None:
    lists_value_test([1, None, 2, None, 3],
                     lambda x: x.qintersect([None, 2]).to_list(),
                     [None, 2])  # Note: True equals 1 in Python and False equals 0. Thus this assertion and the one adev are equivalent.
</file>

<file path="queryablecollections_tests/q_iterable/test_qunion_by.py">
from __future__ import annotations

from test_common_helpers import lists_value_test


def get_id(item: tuple[int, str]) -> int: return item[0]

def test_combines_unique_items_from_both_sequences_by_id_retaining_the_order_from_both_sequences_keeping_the_first_encountered_duplicate() -> None:
    lists_value_test(
            [(1, "apple"), (2, "banana"), (3, "cherry")],
            lambda x: x.qunion_by([(1, "avocado"), (4, "blueberry"), (5, "apricot")], get_id).to_list(),  # ID 1 conflicts with "apple"
            [(1, "apple"), (2, "banana"), (3, "cherry"), (4, "blueberry"), (5, "apricot")]
    )

def test_removes_duplicates_within_first_sequence() -> None:
    lists_value_test(
            [(1, "apple"), (1, "apricot"), (2, "banana")],
            lambda x: x.qunion_by([(3, "cherry"), (4, "date")], get_id).to_list(),
            [(1, "apple"), (2, "banana"), (3, "cherry"), (4, "date")]
    )

def test_removes_duplicates_within_second_sequence() -> None:
    lists_value_test(
            [(1, "apple"), (2, "banana")],
            lambda x: x.qunion_by([(3, "cherry"), (3, "coconut"), (4, "date")], get_id).to_list(),
            [(1, "apple"), (2, "banana"), (3, "cherry"), (4, "date")]
    )

def test_second_sequence_items_excluded_when_ids_already_exist() -> None:
    lists_value_test(
            [(1, "apple"), (2, "banana"), (3, "cherry")],
            lambda x: x.qunion_by([(1, "avocado"), (2, "blueberry"), (3, "coconut")], get_id).to_list(),
            [(1, "apple"), (2, "banana"), (3, "cherry")]
    )

def test_empty_first_sequence_returns_deduplicated_second_sequence() -> None:
    lists_value_test(
            [],
            lambda x: x.qunion_by([(1, "apple"), (1, "apricot"), (2, "banana")], get_id).to_list(),
            [(1, "apple"), (2, "banana")]
    )

def test_empty_second_sequence_returns_deduplicated_first_sequence() -> None:
    lists_value_test(
            [(1, "apple"), (1, "apricot"), (2, "banana")],
            lambda x: x.qunion_by([], get_id).to_list(),
            [(1, "apple"), (2, "banana")]
    )

def test_both_sequences_empty_returns_empty() -> None:
    lists_value_test(
            [],
            lambda x: x.qunion_by([], lambda item: item).to_list(),
            list[int]())

def test_preserves_order_first_sequence_then_second() -> None:
    lists_value_test(
            [(10, "zebra"), (1, "apple"), (5, "mango")],
            lambda x: x.qunion_by([(7, "elderberry"), (2, "banana"), (1, "apricot")], get_id).to_list(),
            [(10, "zebra"), (1, "apple"), (5, "mango"), (7, "elderberry"), (2, "banana")]
    )

def test_handles_none_ids_correctly() -> None:
    lists_value_test(
            [(None, "unknown1"), (1, "apple"), (2, "banana")],
            lambda x: x.qunion_by([(None, "unknown2"), (3, "cherry"), (4, "date")], lambda item: item[0]).to_list(),
            [(None, "unknown1"), (1, "apple"), (2, "banana"), (3, "cherry"), (4, "date")]
    )

def test_identical_sequences_removes_duplicates() -> None:
    lists_value_test(
            [(1, "apple"), (1, "apricot"), (2, "banana")],
            lambda x: x.qunion_by([(1, "apple"), (1, "apricot"), (2, "banana")], get_id).to_list(),
            [(1, "apple"), (2, "banana")]
    )

def test_completely_different_ids_includes_all_items() -> None:
    lists_value_test(
            [(1, "apple"), (2, "banana"), (3, "cherry")],
            lambda x: x.qunion_by([(4, "date"), (5, "elderberry"), (6, "fig")], get_id).to_list(),
            [(1, "apple"), (2, "banana"), (3, "cherry"), (4, "date"), (5, "elderberry"), (6, "fig")]
    )

def test_single_element_sequences() -> None:
    lists_value_test(
            [(1, "apple")],
            lambda x: x.qunion_by([(2, "banana")], get_id).to_list(),
            [(1, "apple"), (2, "banana")]
    )

def test_single_elements_with_duplicate_ids() -> None:
    lists_value_test(
            [(1, "apple")],
            lambda x: x.qunion_by([(1, "avocado")], get_id).to_list(),
            [(1, "apple")]
    )

def test_numeric_items_with_identity_key() -> None:
    lists_value_test(
            [1, 2, 3],
            lambda x: x.qunion_by([1, 4, 5], lambda item: item).to_list(),
            [1, 2, 3, 4, 5]
    )
</file>

<file path="queryablecollections_tests/q_iterable/test_qunion.py">
from __future__ import annotations

from test_common_helpers import lists_value_test


def test_combines_distinct_elements_from_both_sequences_preserving_order() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.qunion([3, 4, 5]).to_list(),
                     [1, 2, 3, 4, 5])

def test_removes_duplicates_within_first_sequence() -> None:
    lists_value_test([1, 2, 2, 3],
                     lambda x: x.qunion([4, 5]).to_list(),
                     [1, 2, 3, 4, 5])

def test_removes_duplicates_within_second_sequence() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.qunion([4, 4, 5]).to_list(),
                     [1, 2, 3, 4, 5])

def test_removes_duplicates_between_sequences() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.qunion([2, 3, 4]).to_list(),
                     [1, 2, 3, 4])

def test_with_empty_first_returns_distinct_elements_from_second() -> None:
    lists_value_test([],
                     lambda x: x.qunion([1, 2, 2, 3]).to_list(),
                     [1, 2, 3])

def test_with_empty_second_returns_distinct_elements_from_first() -> None:
    lists_value_test([1, 2, 2, 3],
                     lambda x: x.qunion([]).to_list(),
                     [1, 2, 3])

def test_with_both_empty_returns_empty() -> None:
    lists_value_test([],
                     lambda x: x.qunion([]).to_list(),
                     list[int]())

def test_preserves_order_from_first_sequence_then_second() -> None:
    lists_value_test([3, 1, 2],
                     lambda x: x.qunion([5, 4, 1]).to_list(),
                     [3, 1, 2, 5, 4])

def test_works_with_strings() -> None:
    lists_value_test(["apple", "banana"],
                     lambda x: x.qunion(["banana", "cherry"]).to_list(),
                     ["apple", "banana", "cherry"])

def test_works_with_mixed_types() -> None:
    lists_value_test([1, "hello", 2.5],
                     lambda x: x.qunion([2.5, True, "world"]).to_list(),
                     [1, "hello", 2.5, "world"]) # Note that the True disappears because it is considered equal to 1 in pythn.

def test_with_none_values() -> None:
    lists_value_test([1, None, 2],
                     lambda x: x.qunion([None, 3, 4]).to_list(),
                     [1, None, 2, 3, 4])

def test_with_identical_sequences_returns_distinct_elements() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.qunion([1, 2, 3]).to_list(),
                     [1, 2, 3])

def test_with_completely_different_sequences() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.qunion([4, 5, 6]).to_list(),
                     [1, 2, 3, 4, 5, 6])

def test_maintains_insertion_order() -> None:
    lists_value_test(["z", "a", "m"],
                     lambda x: x.qunion(["b", "z", "c"]).to_list(),
                     ["z", "a", "m", "b", "c"])

def test_with_single_element_sequences() -> None:
    lists_value_test([42],
                     lambda x: x.qunion([24]).to_list(),
                     [42, 24])

def test_with_duplicate_single_elements() -> None:
    lists_value_test([42],
                     lambda x: x.qunion([42]).to_list(),
                     [42])
</file>

<file path="queryablecollections_tests/q_iterable/test_range.py">
from __future__ import annotations

import pytest
from queryablecollections.q_iterable import QIterable


def test_single_argument_creates_range_from_0_to_end_minus_one() -> None:
    assert QIterable.range(5).to_list() == [0, 1, 2, 3, 4]

def test_start_and_stop_returns_start_to_end_minus_1() -> None:
    assert QIterable.range(1, 5).to_list() == [1, 2, 3, 4]

def test_with_positive_step_each_element_is_step_larger_than_the_previous() -> None:
    assert QIterable.range(0, 10, 2).to_list() == [0, 2, 4, 6, 8]

def test_with_negative_step_each_element_is_step_smaller_than_the_previous() -> None:
    assert QIterable.range(5, 0, -1).to_list() == [5, 4, 3, 2, 1]

def test_empty_when_start_equals_stop() -> None:
    assert QIterable.range(3, 3).to_list() == []

def test_step_zero_raises_value_error() -> None:
    with pytest.raises(ValueError):
        QIterable.range(0, 10, 0).to_list()

def test_returns_qintiterable_supporting_numeric_ops() -> None:
    assert QIterable.range(1, 6).sum() == 15
</file>

<file path="queryablecollections_tests/q_iterable/test_repeat.py">
# queryablecollections/queryablecollections_tests/q_iterable/test.py
from __future__ import annotations

import pytest
from queryablecollections.q_errors import ArgumentError
from queryablecollections.q_iterable import QIterable


def test_repeats_element_specified_number_of_times() -> None:
    assert QIterable.repeat("x", 4).to_list() == ["x", "x", "x", "x"]

def test_with_zero_returns_empty_sequence() -> None:
    assert QIterable.repeat(42, 0).to_list() == []

def test_works_with_none() -> None:
    assert QIterable.repeat(None, 3).to_list() == [None, None, None]

def test_negative_count_raises_argument_error() -> None:
    with pytest.raises(ArgumentError):
        QIterable.repeat("x", -1).to_list()
</file>

<file path="queryablecollections_tests/q_iterable/test_reverse.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_reverse_returns_reversed_sequence() -> None:
    value_test_including_unordered_collections([1, 2, 3],
                                               lambda x: x.reversed().to_list(),
                                               [3, 2, 1])
</file>

<file path="queryablecollections_tests/q_iterable/test_select_index.py">
from __future__ import annotations

from test_common_helpers import lists_value_test


def test_combines_items_with_their_index() -> None:
    lists_value_test([10, 20, 30],
               lambda x: x.select_index(lambda item, index: (index, item)).to_list(),
               [(0, 10), (1, 20), (2, 30)])

def test_with_empty_collection_returns_empty() -> None:
    lists_value_test(list[str](),
               lambda x: x.select_index(lambda item, index: f"{index}:{item}").to_list(),
               list[str]())


def test_with_single_element() -> None:
    lists_value_test(["hello"],
               lambda x: x.select_index(lambda item, index: f"{index}:{item}").to_list(),
               ["0:hello"])
</file>

<file path="queryablecollections_tests/q_iterable/test_select_many.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_select_many_flattens_nested_sequences() -> None:
    value_test_including_unordered_collections([[1, 2], [3, 4]],
                                               lambda x: x.select_many(lambda y: y).to_list(),
                                               [1, 2, 3, 4], skip_sets=True)
</file>

<file path="queryablecollections_tests/q_iterable/test_select.py">
from __future__ import annotations

from test_common_helpers import select_test


def test_select() -> None:
    select_test((1, 2, 3),
                lambda x: x * 2,
                [2, 4, 6])
</file>

<file path="queryablecollections_tests/q_iterable/test_sequence_equal.py">
from __future__ import annotations

from test_common_helpers import lists_value_test


def test_equal_sequences_return_true() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.sequence_equal([1, 2, 3]),
                     True)

def test_different_order_returns_false() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.sequence_equal([3, 2, 1]),
                     False)

def test_first_longer_returns_false() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.sequence_equal([1, 2]),
                     False)

def test_second_longer_returns_false() -> None:
    lists_value_test([1, 2],
                     lambda x: x.sequence_equal([1, 2, 3]),
                     False)

def test_both_empty_return_true() -> None:
    lists_value_test(list[int](),
                     lambda x: x.sequence_equal([]),
                     True)

def test_single_element_equal_returns_true() -> None:
    lists_value_test([42],
                     lambda x: x.sequence_equal([42]),
                     True)

def test_single_element_different_returns_false() -> None:
    lists_value_test([42],
                     lambda x: x.sequence_equal([24]),
                     False)

def test_with_none_values_compares_positionally() -> None:
    lists_value_test([1, None, 3],
                     lambda x: x.sequence_equal([1, None, 3]),
                     True)

def test_with_none_values_not_equal_when_positions_differ() -> None:
    lists_value_test([None, 1, 3],
                     lambda x: x.sequence_equal([1, None, 3]),
                     False)
</file>

<file path="queryablecollections_tests/q_iterable/test_single_or_none.py">
from __future__ import annotations

from queryablecollections.q_errors import InvalidOperationError
from test_common_helpers import throws_test, value_test_including_unordered_collections


def test_single_or_none_returns_single_value() -> None:
    value_test_including_unordered_collections([1],
                                               lambda x: x.single_or_none(),
                                               1)

def test_single_or_none_returns_none_if_no_values() -> None:
    value_test_including_unordered_collections([],
                                               lambda x: x.single_or_none(),
                                               None)

def test_single_or_none_throws_if_multiple_values() -> None:
    throws_test([1, 2],
                lambda x: x.single_or_none(),
                InvalidOperationError)
</file>

<file path="queryablecollections_tests/q_iterable/test_single.py">
from __future__ import annotations

from test_common_helpers import throws_test, value_test_including_unordered_collections


def test_single_returns_single_value() -> None:
    value_test_including_unordered_collections([1],
                                               lambda x: x.single(),
                                               1)

def test_single_throws_if_no_values() -> None:
    throws_test([],
                lambda x: x.single())

def test_single_throws_if_multiple_values() -> None:
    throws_test([1, 2],
                lambda x: x.single())

def test_single_returns_single_none_value() -> None:
    value_test_including_unordered_collections([None],
                                               lambda x: x.single(),
                                               None)
</file>

<file path="queryablecollections_tests/q_iterable/test_skip_last.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_skip_last_skips_the_last_x_elements() -> None:
    assert query([1, 2, 3, 4, 5]).skip_last(2).to_list() == [1, 2, 3]

def test_skip_last_zero_returns_all_elements() -> None:
    assert query([1, 2, 3, 4, 5]).skip_last(0).to_list() == [1, 2, 3, 4, 5]

def test_skip_last_negative_returns_all_elements() -> None:
    assert query([1, 2, 3, 4, 5]).skip_last(-3).to_list() == [1, 2, 3, 4, 5]

def test_skip_last_more_than_available_returns_no_elements() -> None:
    assert query([1, 2, 3]).skip_last(10).to_list() == []

def test_skip_last_from_empty_returns_no_elements() -> None:
    assert query([]).skip_last(5).to_list() == []

def test_skip_last_single_element_returns_no_elements() -> None:
    assert query([42]).skip_last(1).to_list() == []
</file>

<file path="queryablecollections_tests/q_iterable/test_skip_while.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_skip_while_skips_elements_until_predicate_becomes_false() -> None:
    assert (query([1, 2, 3, 4, 5]).skip_while(
            lambda x: x < 3).to_list()
            == [3, 4, 5])

def test_skip_while_with_always_true_predicate_returns_no_elements() -> None:
    assert (query([1, 2, 3, 4, 5]).skip_while(
            lambda _: True).to_list()
            == [])

def test_skip_while_with_always_false_predicate_returns_all_elements() -> None:
    assert (query([1, 2, 3, 4, 5]).skip_while(
            lambda _: False).to_list()
            == [1, 2, 3, 4, 5])

def test_skip_while_with_first_element_failing_predicate_returns_all() -> None:
    assert (query([1, 2, 3]).skip_while(
            lambda x: x < 1).to_list()
            == [1, 2, 3])

def test_skip_while_from_empty_collection_returns_empty() -> None:
    assert (query(list[int]([])).skip_while(
            lambda _: True).to_list()
            == [])

def test_skip_while_with_single_element_matching_predicate_returns_no_elements() -> None:
    assert (query([1]).skip_while(
            lambda x: x == 1).to_list()
            == [])

def test_skip_while_with_single_element_not_matching_predicate_returns_the_element() -> None:
    assert (query([1]).skip_while(
            lambda x: x == 2).to_list()
            == [1])
</file>

<file path="queryablecollections_tests/q_iterable/test_skip.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_skip_skips_the_specified_number_of_elements() -> None:
    assert query([1, 2, 3, 4, 5]).skip(2).to_list() == [3, 4, 5]

def test_skip_zero_returns_all_elements() -> None:
    assert query([1, 2, 3, 4, 5]).skip(0).to_list() == [1, 2, 3, 4, 5]

def test_skip_negative_count_returns_all_elements() -> None:
    assert query([1, 2, 3, 4, 5]).skip(-3).to_list() == [1, 2, 3, 4, 5]

def test_skip_more_than_available_returns_no_elements() -> None:
    assert query([1, 2, 3]).skip(10).to_list() == []

def test_skip_from_empty_returns_no_elements() -> None:
    assert query([]).skip(5).to_list() == []
</file>

<file path="queryablecollections_tests/q_iterable/test_take_last.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_take_last_returns_the_last_x_elements() -> None:
    assert query([1, 2, 3, 4, 5]).take_last(3).to_list() == [3, 4, 5]

def test_take_last_zero_returns_no_elements() -> None:
    assert query([1, 2, 3, 4, 5]).take_last(0).to_list() == []

def test_take_last_negative_count_returns_no_elements() -> None:
    assert query([1, 2, 3, 4, 5]).take_last(-5).to_list() == []

def test_take_last_more_than_available_returns_all_elements() -> None:
    assert query([1, 2, 3]).take_last(10).to_list() == [1, 2, 3]

def test_take_last_from_empty_returns_no_elements() -> None:
    assert query([]).take_last(5).to_list() == []

def test_take_last_single_element_returns_the_single_element() -> None:
    assert query([42]).take_last(1).to_list() == [42]
</file>

<file path="queryablecollections_tests/q_iterable/test_take_while.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_take_while_returns_elements_until_predicate_becomes_false() -> None:
    assert query([1, 2, 3, 4, 5]).take_while(lambda x: x < 4).to_list() == [1, 2, 3]

def test_take_while_with_always_true_predicate_returns_all_elements() -> None:
    assert query([1, 2, 3, 4, 5]).take_while(lambda x: x > 0).to_list() == [1, 2, 3, 4, 5]

def test_take_while_with_always_false_predicate_returns_no_elements() -> None:
    assert query([1, 2, 3, 4, 5]).take_while(lambda x: x < 0).to_list() == []

def test_take_while_with_first_element_failing_predicate_returns_empty() -> None:
    assert query([5, 1, 2, 3]).take_while(lambda x: x < 3).to_list() == []

def test_take_while_from_empty_collection_returns_empty() -> None:
    assert query(list[int]([])).take_while(lambda x: True).to_list() == []

def test_take_while_with_single_element_matching_predicate_returns_the_element() -> None:
    assert query([42]).take_while(lambda x: x > 0).to_list() == [42]

def test_take_while_with_single_element_not_matching_predicate_returns_no_elements() -> None:
    assert query([42]).take_while(lambda x: x < 0).to_list() == []

def test_take_while_is_lazy() -> None:
    call_count = 0

    def expensive_operation(_: int) -> int:
        nonlocal call_count
        call_count += 1
        return 0

    query([1, 2, 3, 4]).select(expensive_operation).take_while(lambda x: x < 6)
    assert call_count == 0

def test_take_while_stops_processing_at_the_first_element_that_fails_the_predidate() -> None:
    processed_values: list[int] = []

    def track_processing(x: int) -> int:
        processed_values.append(x)
        return x

    result = query([1, 2, 3, 4, 5]).select(track_processing).take_while(lambda x: x < 4).to_list()

    assert result == [1, 2, 3]
    assert processed_values == [1, 2, 3, 4]
</file>

<file path="queryablecollections_tests/q_iterable/test_take.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_take_returns_the_specified_number_of_elements_from_the_start() -> None:
    assert query([1, 2, 3, 4, 5]).take(3).to_list() == [1, 2, 3]

def test_take_zero_returns_empty_iterable() -> None:
    assert query([1, 2, 3, 4, 5]).take(0).to_list() == []

def test_take_negative_returns_empty_iterable() -> None:
    assert query([1, 2, 3, 4, 5]).take(-5).to_list() == []

def test_take_more_than_available_returns_the_full_iterable() -> None:
    assert query([1, 2, 3]).take(10).to_list() == [1, 2, 3]

def test_take_from_empty_returns_empty_iterable() -> None:
    assert query([]).take(5).to_list() == []
</file>

<file path="queryablecollections_tests/q_iterable/test_to_.py">
from __future__ import annotations

from test_common_helpers import value_test_including_unordered_collections


def test_to_list() -> None: value_test_including_unordered_collections([1, 2, 3], lambda x: x.to_list(), [1, 2, 3])
def test_to_sequence() -> None: value_test_including_unordered_collections([1, 2, 3], lambda x: x.to_sequence(), [1, 2, 3])
def test_to_builtin_list() -> None: value_test_including_unordered_collections([1, 2, 3], lambda x: x.to_built_in_list(), [1, 2, 3])
def test_to_set() -> None: value_test_including_unordered_collections([1, 2, 3], lambda x: x.to_set(), {1, 2, 3})
def test_to_frozenset() -> None: value_test_including_unordered_collections([1, 2, 3], lambda x: x.to_frozenset(), frozenset({1, 2, 3}))
</file>

<file path="queryablecollections_tests/q_iterable/test_to_dict.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


class DummyObj:
    def __init__(self, name: str, val: int) -> None:
        self.name: str = name
        self.val: int = val

    def __eq__(self, other: object) -> bool:
        return isinstance(other, DummyObj) and self.name == other.name and self.val == other.val

def test_to_dict_with_selectors_returns_a_dict_combining_the_selected_keys_and_values() -> None:
    assert (query([DummyObj("x", 10),
                   DummyObj("y", 14),
                   DummyObj("z", 16)])
            .to_dict(lambda o: o.name, lambda o: o.val) == {"x": 10,
                                                            "y": 14,
                                                            "z": 16})

def test_to_dict_with_selectors_on_empty_sequence_returns_empty_dict() -> None:
    assert QList[int]([]).to_dict(lambda x: x, lambda x: x) == {}

def test_to_dict_with_selectors_on_single_item_returns_single_entry_dict() -> None:
    assert (query([(DummyObj("test", 42))])
            .to_dict(lambda o: o.name, lambda o: o.val) == {"test": 42})

def test_to_dict_with_selectors_and_duplicate_keys_uses_last_value() -> None:
    assert (query([DummyObj("same", 1),
                   DummyObj("same", 2),
                   DummyObj("same", 3)])
            .to_dict(lambda o: o.name, lambda o: o.val) == {"same": 3})
</file>

<file path="queryablecollections_tests/q_iterable/test_where_key_in.py">
from __future__ import annotations

from test_common_helpers import lists_value_test


def test_returns_common_elements_by_key_preserving_first_order_and_distinct_by_key() -> None:
    lists_value_test([("a", 1), ("b", 2), ("a", 3), ("c", 4), ("b", 5)],
                     lambda x: x.where_key_in(["c", "a"], lambda item: item[0]).to_list(),
                     [("a", 1), ("c", 4)])

def test_intersect_by_with_empty_first_returns_empty() -> None:
    lists_value_test([],
                     lambda x: x.where_key_in(["a", "b"], lambda item: item).to_list(),
                     list[str]())

def test_intersect_by_with_empty_keys_returns_empty() -> None:
    lists_value_test([("a", 1), ("b", 2)],
                     lambda x: x.where_key_in([], lambda item: item[0]).to_list(),
                     list[tuple[str, int]]())

def test_intersect_by_with_no_common_keys_returns_empty() -> None:
    lists_value_test([("a", 1), ("b", 2)],
                     lambda x: x.where_key_in(["x", "y"], lambda item: item[0]).to_list(),
                     list[tuple[str, int]]())

def test_intersect_by_handles_none_keys() -> None:
    lists_value_test([("a", 1), (None, 2), ("b", 3), (None, 4)],
                     lambda x: x.where_key_in([None], lambda item: item[0]).to_list(),
                     [(None, 2)])

def test_intersect_by_duplicate_keys_in_second_do_not_affect_result() -> None:
    lists_value_test([(1, "x"), (2, "y"), (3, "z"), (2, "y2")],
                     lambda x: x.where_key_in([2, 2, 3], lambda item: item[0]).to_list(),
                     [(2, "y"), (3, "z")])
</file>

<file path="queryablecollections_tests/q_iterable/test_where_key_not_in.py">
from __future__ import annotations

from test_common_helpers import lists_value_test


def test_excludes_elements_whose_keys_are_present_in_other_without_changing_order() -> None:
    data = [(1, "a"), (2, "b"), (3, "c"), (4, "d"), (5, "e")]
    lists_value_test(data,
                     lambda x: x.where_key_not_in([3, 4, 6, 7], lambda item: item[0]).to_list(),
                     [(1, "a"), (2, "b"), (5, "e")],
                     )

def test_removes_duplicates_by_key_from_result_keeping_the_first_encountered() -> None:
    data = [("apple", 1), ("apricot", 2), ("banana", 3), ("avocado", 4)]
    # key is the first character
    lists_value_test(data,
                     lambda x: x.where_key_not_in(["b"], lambda item: item[0][0]).to_list(),
                     [("apple", 1)],  # only the first 'a*' remains, 'banana' excluded, 'avocado' removed as duplicate key 'a'
                     )

def test_with_empty_other_returns_distinct_by_key_of_first() -> None:
    data = [(1, "x"), (2, "y"), (2, "z"), (3, "w")]
    lists_value_test(data,
                     lambda x: x.where_key_not_in([], lambda item: item[0]).to_list(),
                     [(1, "x"), (2, "y"), (3, "w")])

def test_with_empty_first_returns_empty() -> None:
    lists_value_test(list[tuple[int, str]](),
                     lambda x: x.where_key_not_in([1, 2, 3], lambda item: item[0]).to_list(),
                     list[tuple[int, str]]())

def test_with_no_matching_keys_returns_distinct_by_key_from_first() -> None:
    data = [(1, "one"), (2, "two"), (2, "two2"), (3, "three")]
    lists_value_test(data,
                     lambda x: x.where_key_not_in([4, 5, 6], lambda item: item[0]).to_list(),
                     [(1, "one"), (2, "two"), (3, "three")])

def test_with_all_matching_keys_returns_empty() -> None:
    data = [(1, "a"), (2, "b"), (3, "c")]
    lists_value_test(data,
                     lambda x: x.where_key_not_in([1, 2, 3, 4], lambda item: item[0]).to_list(),
                     list[tuple[int, str]]())

def test_works_with_strings_and_string_keys() -> None:
    data = ["apple", "banana", "cherry", "date", "apricot"]
    lists_value_test(data,
                     lambda x: x.where_key_not_in(["b", "d"], lambda s: s[0]).to_list(),
                     ["apple", "cherry"])  # 'apricot' removed because duplicate key 'a'

def test_handles_none_keys() -> None:
    data = [("a", 1), (None, 2), ("b", 3), (None, 4)]
    lists_value_test(data,
                     lambda x: x.where_key_not_in([None], lambda item: item[0]).to_list(),
                     [("a", 1), ("b", 3)])

def test_none_keys_are_distinct_by_key_when_not_excluded() -> None:
    data = [("a", 1), (None, 2), ("b", 3), (None, 4)]
    lists_value_test(data,
                     lambda x: x.where_key_not_in([], lambda item: item[0]).to_list(),
                     [("a", 1), (None, 2), ("b", 3)])
</file>

<file path="queryablecollections_tests/q_iterable/test_where.py">
from __future__ import annotations

from test_common_helpers import where_test


def test_where_first_element_returns_only_first_element() -> None:
    where_test((1, 2, 3),
               lambda x: x == 1,
               [1])

def test_where_middle_element_returns_only_middle_element() -> None:
    where_test((1, 2, 3),
               lambda x: x == 2,
               [2])

def test_where_last_element_returns_only_last_element() -> None:
    where_test((1, 2, 3),
               lambda x: x == 3,
               [3])

def test_where_excluding_first_element() -> None:
    where_test((1, 2, 3),
               lambda x: x != 1,
               [2, 3])

def test_where_excluding_middle_element() -> None:
    where_test((1, 2, 3),
               lambda x: x != 2,
               [1, 3])

def test_where_excluding_end_element() -> None:
    where_test((1, 2, 3),
               lambda x: x != 3,
               [1, 2])
</file>

<file path="queryablecollections_tests/q_iterable/test_zip_tuple.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


def test_zip_tuple_with_equal_length_sequences_returns_each_combination() -> None:
    assert (query([1, 2, 3])
            .zip_tuple([10, 20, 30])
            .to_list() == [(1, 10), (2, 20), (3, 30)])

def test_zip_tuple_with_single_element_sequences_returns_that_element() -> None:
    assert query([42]).zip_tuple([100]).to_list() == [(42, 100)]

def test_zip_tuple_with_shorter_first_sequence_returns_the_number_of_elements_in_the_first_sequence() -> None:
    assert (query([1, 2])
            .zip_tuple([10, 20, 30, 40])
            .to_list() == [(1, 10), (2, 20)])

def test_zip_tuple_with_second_sequence_shorter_returns_the_number_of_elements_in_the_second_sequence() -> None:
    assert (query([1, 2, 3, 4])
            .zip_tuple([10, 20])
            .to_list() == [(1, 10), (2, 20)])

def test_zip_tuple_with_empty_first_sequence_returns_no_elements() -> None:
    assert (query(list[int]([]))
            .zip_tuple([1, 2, 3])
            .to_list() == [])

def test_zip_tuple_with_empty_second_sequence_returns_no_elements() -> None:
    assert (query([1, 2, 3])
            .zip_tuple(list[int]())
            .to_list() == [])

def test_zip_tuple_with_both_empty_sequences_returns_no_elements() -> None:
    assert (QList[int]()
            .zip_tuple(QList[int]())
            .to_list() == [])
</file>

<file path="queryablecollections_tests/q_iterable/test_zip_tuple2.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


def test_zip_tuple2_with_equal_length_sequences_returns_each_combination() -> None:
    assert (
            query([1, 2, 3])
            .zip_tuple2([10, 20, 30], [100, 200, 300])
            .to_list()
            == [(1, 10, 100), (2, 20, 200), (3, 30, 300)]
    )

def test_zip_tuple2_with_single_element_sequences_returns_that_element() -> None:
    assert query([1]).zip_tuple2([10], [100]).to_list() == [(1, 10, 100)]

def test_zip_tuple2_with_shorter_first_sequence_returns_number_of_elements_in_first_sequence() -> None:
    assert (
            query([1, 2])
            .zip_tuple2([10, 20, 30, 40], [100, 200, 300, 400])
            .to_list()
            == [(1, 10, 100), (2, 20, 200)]
    )

def test_zip_tuple2_with_second_sequence_shorter_returns_number_of_elements_in_second_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip_tuple2([10, 20], [100, 200, 300, 400])
            .to_list()
            == [(1, 10, 100), (2, 20, 200)]
    )

def test_zip_tuple2_with_third_sequence_shorter_returns_number_of_elements_in_third_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip_tuple2([10, 20, 30, 40], [100, 200])
            .to_list()
            == [(1, 10, 100), (2, 20, 200)]
    )

def test_zip_tuple2_with_empty_first_sequence_returns_no_elements() -> None:
    assert (
            query(list[int]([]))
            .zip_tuple2([1, 2, 3], [10, 20, 30])
            .to_list()
            == []
    )

def test_zip_tuple2_with_empty_second_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip_tuple2(list[int](), [10, 20, 30])
            .to_list()
            == []
    )

def test_zip_tuple2_with_empty_third_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip_tuple2([10, 20, 30], list[int]())
            .to_list()
            == []
    )

def test_zip_tuple2_with_all_empty_sequences_returns_no_elements() -> None:
    assert (
            QList[int]()
            .zip_tuple2(QList[int](), QList[int]())
            .to_list()
            == []
    )
</file>

<file path="queryablecollections_tests/q_iterable/test_zip_tuple3.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


def test_zip_tuple3_with_equal_length_sequences_returns_each_combination() -> None:
    assert (
            query([1, 2, 3])
            .zip_tuple3([10, 20, 30],
                        [100, 200, 300],
                        [1000, 2000, 3000])
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000), (3, 30, 300, 3000)]
    )

def test_zip_tuple3_with_single_element_sequences_returns_that_element() -> None:
    assert query([1]).zip_tuple3([10], [100], [1000]).to_list() == [(1, 10, 100, 1000)]

def test_zip_tuple3_with_shorter_first_sequence_returns_number_of_elements_in_first_sequence() -> None:
    assert (
            query([1, 2])
            .zip_tuple3([10, 20, 30, 40],
                        [100, 200, 300, 400],
                        [1000, 2000, 3000, 4000])
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000)]
    )

def test_zip_tuple3_with_second_sequence_shorter_returns_number_of_elements_in_second_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip_tuple3([10, 20],
                        [100, 200, 300, 400],
                        [1000, 2000, 3000, 4000])
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000)]
    )

def test_zip_tuple3_with_third_sequence_shorter_returns_number_of_elements_in_third_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip_tuple3([10, 20, 30, 40],
                        [100, 200],
                        [1000, 2000, 3000, 4000])
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000)]
    )

def test_zip_tuple3_with_fourth_sequence_shorter_returns_number_of_elements_in_fourth_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip_tuple3([10, 20, 30, 40],
                        [100, 200, 300, 400],
                        [1000, 2000])
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000)]
    )

def test_zip_tuple3_with_empty_first_sequence_returns_no_elements() -> None:
    assert (
            query(list[int]([]))
            .zip_tuple3([1, 2, 3],
                        [10, 20, 30],
                        [100, 200, 300])
            .to_list()
            == []
    )

def test_zip_tuple3_with_empty_second_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip_tuple3(list[int](),
                        [10, 20, 30],
                        [100, 200, 300])
            .to_list()
            == []
    )

def test_zip_tuple3_with_empty_third_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip_tuple3([10, 20, 30],
                        list[int](),
                        [100, 200, 300])
            .to_list()
            == []
    )

def test_zip_tuple3_with_empty_fourth_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip_tuple3([10, 20, 30],
                        [100, 200, 300],
                        list[int]())
            .to_list()
            == []
    )

def test_zip_tuple3_with_all_empty_sequences_returns_no_elements() -> None:
    assert (
            QList[int]()
            .zip_tuple3(QList[int](),
                        QList[int](),
                        QList[int]())
            .to_list()
            == []
    )
</file>

<file path="queryablecollections_tests/q_iterable/test_zip.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


def test_zip_with_equal_length_sequences_returns_each_combination() -> None:
    assert (query([1, 2, 3])
            .zip([10, 20, 30], lambda x, y: (x, y))
            .to_list() == [(1, 10), (2, 20), (3, 30)])

def test_zip_with_single_element_sequences_returns_that_element() -> None:
    assert query([42]).zip([100], lambda x, y: (x, y)).to_list() == [(42, 100)]

def test_zip_with_shorter_first_sequence_returns_the_number_of_elements_in_the_first_sequence() -> None:
    assert (query([1, 2])
            .zip([10, 20, 30, 40], lambda x, y: (x, y))
            .to_list() == [(1, 10), (2, 20)])

def test_zip_with_second_sequence_shorter_returns_the_number_of_elements_in_the_second_sequence() -> None:
    assert (query([1, 2, 3, 4])
            .zip([10, 20], lambda x, y: (x, y))
            .to_list() == [(1, 10), (2, 20)])

def test_zip_with_empty_first_sequence_returns_no_elements() -> None:
    assert (query(list[int]([]))
            .zip([1, 2, 3], lambda x, y: (x, y))
            .to_list() == [])

def test_zip_with_empty_second_sequence_returns_no_elements() -> None:
    assert (query([1, 2, 3])
            .zip(list[int](), lambda x, y: (x, y))
            .to_list() == [])

def test_zip_with_both_empty_sequences_returns_no_elements() -> None:
    assert (QList[int]()
            .zip(QList[int](), lambda x, y: (x, y))
            .to_list() == [])
</file>

<file path="queryablecollections_tests/q_iterable/test_zip2.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


def test_zip2_with_equal_length_sequences_returns_each_combination() -> None:
    assert (
            query([1, 2, 3])
            .zip2([10, 20, 30],
                  [100, 200, 300],
                  lambda x, y, z: (x, y, z))
            .to_list()
            == [(1, 10, 100), (2, 20, 200), (3, 30, 300)]
    )

def test_zip2_with_single_element_sequences_returns_that_element() -> None:
    assert query([1]).zip2([10], [100], lambda x, y, z: (x, y, z)).to_list() == [(1, 10, 100)]

def test_zip2_with_shorter_first_sequence_returns_number_of_elements_in_first_sequence() -> None:
    assert (
            query([1, 2])
            .zip2([10, 20, 30, 40], [100, 200, 300, 400], lambda x, y, z: (x, y, z))
            .to_list()
            == [(1, 10, 100), (2, 20, 200)]
    )

def test_zip2_with_second_sequence_shorter_returns_number_of_elements_in_second_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip2([10, 20], [100, 200, 300, 400], lambda x, y, z: (x, y, z))
            .to_list()
            == [(1, 10, 100), (2, 20, 200)]
    )

def test_zip2_with_third_sequence_shorter_returns_number_of_elements_in_third_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip2([10, 20, 30, 40], [100, 200], lambda x, y, z: (x, y, z))
            .to_list()
            == [(1, 10, 100), (2, 20, 200)]
    )

def test_zip2_with_empty_first_sequence_returns_no_elements() -> None:
    assert (
            query(list[int]([]))
            .zip2([1, 2, 3], [10, 20, 30], lambda x, y, z: (x, y, z))
            .to_list()
            == []
    )

def test_zip2_with_empty_second_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip2(list[int](), [10, 20, 30], lambda x, y, z: (x, y, z))
            .to_list()
            == []
    )

def test_zip2_with_empty_third_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip2([10, 20, 30], list[int](), lambda x, y, z: (x, y, z))
            .to_list()
            == []
    )

def test_zip2_with_all_empty_sequences_returns_no_elements() -> None:
    assert (
            QList[int]()
            .zip2(QList[int](), QList[int](), lambda x, y, z: (x, y, z))
            .to_list()
            == []
    )
</file>

<file path="queryablecollections_tests/q_iterable/test_zip3.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


def test_zip3_with_equal_length_sequences_returns_each_combination() -> None:
    assert (
            query([1, 2, 3])
            .zip3([10, 20, 30],
                  [100, 200, 300],
                  [1000, 2000, 3000],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000), (3, 30, 300, 3000)]
    )

def test_zip3_with_single_element_sequences_returns_that_element() -> None:
    assert query([1]).zip3([10], [100], [1000], lambda a, b, c, d: (a, b, c, d)).to_list() == [(1, 10, 100, 1000)]

def test_zip3_with_shorter_first_sequence_returns_number_of_elements_in_first_sequence() -> None:
    assert (
            query([1, 2])
            .zip3([10, 20, 30, 40],
                  [100, 200, 300, 400],
                  [1000, 2000, 3000, 4000],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000)]
    )

def test_zip3_with_second_sequence_shorter_returns_number_of_elements_in_second_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip3([10, 20],
                  [100, 200, 300, 400],
                  [1000, 2000, 3000, 4000],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000)]
    )

def test_zip3_with_third_sequence_shorter_returns_number_of_elements_in_third_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip3([10, 20, 30, 40],
                  [100, 200],
                  [1000, 2000, 3000, 4000],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000)]
    )

def test_zip3_with_fourth_sequence_shorter_returns_number_of_elements_in_fourth_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip3([10, 20, 30, 40],
                  [100, 200, 300, 400],
                  [1000, 2000],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000)]
    )

def test_zip3_with_empty_first_sequence_returns_no_elements() -> None:
    assert (
            query(list[int]([]))
            .zip3([1, 2, 3],
                  [10, 20, 30]
                  , [100, 200, 300],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == []
    )

def test_zip3_with_empty_second_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip3(list[int](),
                  [10, 20, 30],
                  [100, 200, 300],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == []
    )

def test_zip3_with_empty_third_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip3([10, 20, 30],
                  list[int](),
                  [100, 200, 300],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == []
    )

def test_zip3_with_empty_fourth_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip3([10, 20, 30],
                  [100, 200, 300],
                  list[int](),
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == []
    )

def test_zip3_with_all_empty_sequences_returns_no_elements() -> None:
    assert (
            QList[int]()
            .zip3(QList[int](),
                  QList[int](),
                  QList[int](),
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == []
    )
</file>

<file path="queryablecollections_tests/q_list/test_indexer.py">
from __future__ import annotations

from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList


def test_list_indexer_returns_element_at_index() -> None:
    values = QList((0, 1, 2))
    assert values[0] == 0
    assert values[1] == 1
    assert values[2] == 2

def test_sequence_indexer_returns_element_at_index() -> None:
    values = QImmutableSequence((0, 1, 2))
    assert values[0] == 0
    assert values[1] == 1
    assert values[2] == 2
</file>

<file path="queryablecollections_tests/q_list/test_slicing.py">
from __future__ import annotations

from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList


def test_list_slice_from_start_returns_the_specified_slice() -> None:
    assert QList((1, 2, 3, 4, 5, 6, 7))[:2] == QList([1, 2])

def test_sequence_slice_from_start_returns_the_specified_slice() -> None:
    assert QImmutableSequence((1, 2, 3, 4, 5, 6, 7))[:2].to_list() == QList([1, 2])

def test_list_slice_middle__returns_the_specified_slice() -> None:
    assert QList((1, 2, 3, 4, 5))[2:4] == QList([3, 4])

def test_sequence_slice_middle_returns_the_specified_slice() -> None:
    assert QImmutableSequence((1, 2, 3, 4, 5))[2:4].to_list() == QList([3, 4])

def test_list_slice_end_returns_the_specified_slice() -> None:
    assert QList((1, 2, 3, 4, 5))[3:] == QList([4, 5])

def test_sequence_slice_end_returns_the_specified_slice() -> None:
    assert QImmutableSequence((1, 2, 3, 4, 5))[3:].to_list() == QList([4, 5])

def test_list_slice_returns_qlist() -> None:
    value = QList((1, 2, 3))[1:]
    assert isinstance(value, QList)
    assert value.element_at(0) == 2

def test_sequence_slice_returns_qimmutable_sequence() -> None:
    value = QImmutableSequence((1, 2, 3))[1:]
    assert isinstance(value, QImmutableSequence)
    assert value.element_at(0) == 2
</file>

<file path="queryablecollections_tests/test_common_helpers.py">
from __future__ import annotations

from collections.abc import Callable, Iterable, Iterator
from contextlib import contextmanager
from typing import cast

import pytest
from queryablecollections.collections.q_frozen_set import QFrozenSet
from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList
from queryablecollections.collections.q_set import QSet
from queryablecollections.q_iterable import QIterable, query


@contextmanager
def sane_asserting() -> Iterator[None]:
    try:
        yield
    except AssertionError as e:
        print(f"""
Failure message: {str(e).split("\n")[0]}
""")
        raise

def create_sequences[T](iterable: Iterable[T] | Callable[[], Iterable[T]], skip_sets: bool = False) -> list[tuple[str, QIterable[T]]]:
    factory: Callable[[], Iterable[T]] = (iterable
                                          if not isinstance(iterable, Iterable)
                                          else lambda: cast(Iterable[T], iterable))  # pyright: ignore[reportUnnecessaryCast] while basedpyright understands it is not needed, pyright does not

    values = [
            ("query", query(factory())),
            ("QList", QList(factory())),
            ("QImmutableSequence", QImmutableSequence(list(factory()))),
    ]
    if not skip_sets:
        values += [("QSet", QSet(factory())),
                   ("QFRozenSet", QFrozenSet(factory()))]
    return values

def where_test[TIn, TOut](input: Iterable[TIn],
                          predicate: Callable[[TIn], bool],
                          output: list[TOut],
                          skip_sets: bool = False) -> None:
    for name, sequence in create_sequences(input, skip_sets):
        result = sequence.where(predicate)
        assert result.to_list() == output, name

def select_test[TIn, TOut](input: Iterable[TIn],
                           select: Callable[[TIn], TOut],
                           output: list[TOut],
                           skip_sets: bool = False) -> None:
    for name, sequence in create_sequences(input, skip_sets):
        result = sequence.select(select)
        assert result.to_list() == output, name

def lists_value_test[TIn, TOut](input: list[TIn] | Callable[[], Iterable[TIn]],
                                operation: Callable[[QIterable[TIn]], TOut],
                                output: TOut) -> None:
    value_test_including_unordered_collections(input, operation, output, skip_sets=True)

def value_test_including_unordered_collections[TIn, TOut](input: list[TIn] | Callable[[], Iterable[TIn]],
                                                          operation: Callable[[QIterable[TIn]], TOut],
                                                          output: TOut,
                                                          skip_sets: bool = False) -> None:
    for _name, sequence in create_sequences(input, skip_sets):
        with sane_asserting():
            result = operation(sequence)
            assert result == output, f"Test failed for {_name}"

def throws_test[TIn, TOut](input: Iterable[TIn],
                           operation: Callable[[QIterable[TIn]], TOut],
                           exception: type[Exception] = Exception,
                           skip_sets: bool = False) -> None:
    for name, sequence in create_sequences(input, skip_sets):
        with pytest.raises(exception):  # noqa: PT012
            operation(sequence)
            pytest.fail(f"{name}: Expected {exception} to be raised")

class CallCounter:
    def __init__(self) -> None:
        self.call_count: int = 0

    def increment(self) -> None:
        self.call_count += 1
</file>

<file path="queryablecollections_tests/test_lazyness_and_consuming_behavior.py">
from __future__ import annotations

from collections.abc import Callable, Iterable
from decimal import Decimal
from fractions import Fraction
from typing import Any

from queryablecollections.q_iterable import QIterable, query


def swallow_exception_decorator(inner: ScalarOrActionOperator) -> ScalarOrActionOperator:
    def wrapper(argument: QIterable[int]) -> Any:  # noqa: ANN401
        # noinspection PyBroadException
        try:
            return inner(argument)
        except:  # noqa: E722
            pass

    return wrapper

type CollectionReturningOperator = Callable[[QIterable[int]], Iterable[object]]
type ScalarOrActionOperator = Callable[[QIterable[int]], Any]
iterator_generating_operators: list[tuple[str, CollectionReturningOperator]] = [
        ("qappend", lambda x1: x1.qappend(999)),
        ("as_decimals", lambda x1: x1.select(Decimal).as_decimals()),
        ("as_floats", lambda x1: x1.select(float).as_floats()),
        ("as_fractions", lambda x1: x1.select(Fraction).as_fractions()),
        ("as_ints", lambda x1: x1.as_ints()),
        ("as_iterable", lambda x1: x1.as_iterable()),
        ("cast", lambda x1: x1.cast.checked.to(int)),
        ("chunk", lambda x1: x1.chunk(2)),
        ("distinct", lambda x1: x1.distinct()),
        ("distinct_by", lambda x1: x1.distinct_by(lambda x2: x2)),
        ("group_by", lambda x1: x1.group_by(lambda x2: x2)),
        ("group_join", lambda x1: x1.group_join([1, 2, 3, 4], lambda key1: key1, lambda key2: key2, lambda val1, val2: (val1, list(val2)))),
        ("join", lambda x1: x1.join([1, 2, 3, 4], lambda key1: key1, lambda key2: key2, lambda val1, val2: val1 + val2)),
        ("of_type", lambda x1: x1.of_type(int)),
        ("order_by", lambda x1: x1.order_by(lambda x2: x2)),
        ("order_by_descending", lambda x1: x1.order_by_descending(lambda x2: x2)),
        ("prepend", lambda x1: x1.prepend(999)),
        ("qexcept", lambda x1: x1.qexcept([1, 2, 3, 4])),
        ("qexcept_by", lambda x1: x1.qexcept_by([1, 2, 3, 4], lambda x2: x2)),
        ("where_key_not_in", lambda x1: x1.where_key_not_in([1, 2, 3, 4], lambda x2: x2)),
        ("qindex", lambda x1: x1.qindex()),
        ("qunion", lambda x1: x1.qunion([1, 2, 3, 4])),
        ("qunion_by", lambda x1: x1.qunion_by([1, 2, 3, 4], lambda x2: x2)),
        ("qintersect", lambda x1: x1.qintersect([1, 2, 3, 4])),
        ("qintersect_by", lambda x1: x1.qintersect_by([1, 2, 3, 4], lambda x2: x2)),
        ("where_key_in", lambda x1: x1.where_key_in([1, 2, 3, 4], lambda x2: x2)),
        ("reversed", lambda x1: x1.reversed()),
        ("select", lambda x1: x1.select(lambda x2: x2)),
        ("select_index", lambda x1: x1.select_index(lambda index, element: (index, element))),
        ("select_many", lambda x1: x1.select_many(lambda _: [1, 2, 3])),
        ("skip", lambda x1: x1.skip(1)),
        ("skip_while", lambda x1: x1.skip_while(lambda val: val < 2)),
        ("skip_last", lambda x1: x1.skip_last(1)),
        ("take", lambda x1: x1.take(10)),
        ("take_last", lambda x1: x1.take_last(1)),
        ("take_while", lambda x1: x1.take_while(lambda _: True)),
        ("where", lambda x1: x1.where(lambda _: True)),
        ("where_not_none", lambda x1: x1.where_not_none()),
        ("zip", lambda x1: x1.zip([1, 2, 3, 4], lambda x2, x3: (x2, x3))),
        ("zip2", lambda x1: x1.zip2([1, 2, 3], [1, 2, 3], lambda x2, x3, x4: (x2, x3, x4))),
        ("zip3", lambda x1: x1.zip3([1, 2, 3], [1, 2, 3], [1, 2, 3], lambda x2, x3, x4, x5: (x2, x3, x4, x5))),
        ("zip_tuple", lambda x1: x1.zip_tuple([1, 2, 3])),
        ("zip_tuple2", lambda x1: x1.zip_tuple2([1, 2, 3], [1, 2, 3])),
        ("zip_tuple3", lambda x1: x1.zip_tuple3([1, 2, 3], [1, 2, 3], [1, 2, 3])),
]

scalar_or_action_operators: list[tuple[str, ScalarOrActionOperator]] = [
        ("all", lambda x1: x1.all(lambda _: True)),
        ("aggregate", lambda x1: x1.aggregate(lambda acc, item: acc + item)),
        ("aggregate_seed", lambda x1: x1.aggregate(lambda acc, item: acc + item, 0)),
        ("aggregate_seed_result", lambda x1: x1.aggregate(lambda acc, item: acc + item, 0, lambda acc: acc)),
        ("any", lambda x1: x1.any()),
        ("contains", lambda x1: x1.contains(1)),
        ("element_at", lambda x1: x1.element_at(0)),
        ("element_at_or_none", lambda x1: x1.element_at_or_none(0)),
        ("first", lambda x1: x1.first()),
        ("first_or_none", lambda x1: x1.first_or_none()),
        ("last", lambda x1: x1.last()),
        ("last_or_none", lambda x1: x1.last_or_none()),
        ("max_by", lambda x1: x1.max_by(lambda v: v)),
        ("min_by", lambda x1: x1.min_by(lambda v: v)),
        ("for_each", lambda x1: x1.for_each(null_op)),
        ("none", lambda x1: x1.none()),
        ("pipe", lambda x1: x1.pipe(lambda iterator: iterator.for_each(null_op))),
        ("qcount", lambda x1: x1.qcount()),
        ("qcount_by", lambda x1: x1.qcount_by(lambda x: x)),
        ("single", swallow_exception_decorator(lambda x1: x1.single())),
        ("single_or_none", swallow_exception_decorator(lambda x1: x1.single_or_none())),
        ("to_built_in_list", lambda x1: x1.to_built_in_list()),
        ("to_dict", lambda x1: x1.to_dict(lambda x2: x2, lambda x2: x2)),
        ("to_frozenset", lambda x1: x1.to_frozenset()),
        ("to_list", lambda x1: x1.to_list()),
        ("to_sequence", lambda x1: x1.to_sequence()),
        ("to_set", lambda x1: x1.to_set()),
        ("sequence_equal", lambda x1: x1.sequence_equal([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])),
]

def assert_has_10_elements[T](iterable: QIterable[T]) -> QIterable[T]:
    assert sum(1 for _ in iterable) == 10
    return iterable

def assert_is_empty[T](iterable: QIterable[T]) -> QIterable[T]:
    assert sum(1 for _ in iterable) == 0
    return iterable

def generate_10_ints() -> QIterable[int]:
    return query(i for i in collection_10_ints())

def collection_10_ints() -> QIterable[int]:
    return query([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

def test_query_can_only_enumerate_once_given_a_generator() -> None:
    generator_query = query(i for i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    assert_has_10_elements(generator_query)
    assert_is_empty(generator_query)

def test_query_can_iterate_again_given_a_collection() -> None:
    generator_query = query([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    assert_has_10_elements(generator_query)
    assert_has_10_elements(generator_query)

def null_op(_: object) -> None: pass

exceptional_operators: set[str] = {"concat"}

all_tested_operator_names: set[str] = query(iterator_generating_operators).select(lambda x: x[0]).to_set() | query(scalar_or_action_operators).select(lambda x: x[0]).to_set()

def get_all_operator_names_defined_in__q_iterable_mixin() -> set[str]:
    return (query(QIterable.__dict__.items())
            .where(lambda x: not isinstance(x[1], (staticmethod, classmethod)))
            .select(lambda x: x[0])  # member names
            .where(lambda x: not x.startswith("_"))
            .to_set())

def test_all_operators_are_tested() -> None:
    missing_tests = get_all_operator_names_defined_in__q_iterable_mixin() - all_tested_operator_names - exceptional_operators
    if missing_tests: raise AssertionError(f"Missing tests for operators: {missing_tests}")

def test_no_iterator_generating_operator_consumes_elements_on_call_without_iteration() -> None:
    for operator_name, operator in iterator_generating_operators:
        original_iterator = generate_10_ints()
        operator(original_iterator)
        if original_iterator.qcount() != 10: raise AssertionError(f"Operator {operator_name} consumed elements on first call")

def test_all_iterator_generating_operators_when_called_on_generator_backed_iterable_consume_elements_but_only_once_iterated_and_the_results_they_return_change_on_second_iteration() -> None:
    for operator_name, operator in iterator_generating_operators:
        original_iterator = generate_10_ints()
        result = operator(original_iterator)
        length_of_iterable_returned_by_operator = sum(1 for _ in result)
        length_of_iterator_returned_by_operator_on_second_iteration = sum(1 for _ in result)

        assert length_of_iterable_returned_by_operator != 0, f"Operator {operator_name} did not return any elements"
        assert length_of_iterator_returned_by_operator_on_second_iteration != length_of_iterable_returned_by_operator, f"Operator {operator_name} returned the same results on second call"
        assert original_iterator.qcount() != 10, f"Operator {operator_name} did not consume any elements from source generator"

def test_no_iterator_generating_operators_when_called_on_collection_backed_iterator_consume_elements_and_they_return_the_same_result_repeatedly() -> None:
    for operator_name, operator in iterator_generating_operators:
        original_iterator = collection_10_ints()
        result_iterator = operator(original_iterator)
        length_of_iterable_returned_by_operator = sum(1 for _ in result_iterator)
        length_of_iterator_returned_by_operator_on_second_iteration = sum(1 for _ in result_iterator)
        assert length_of_iterable_returned_by_operator != 0, f"Operator {operator_name} did not return any elements"
        assert length_of_iterator_returned_by_operator_on_second_iteration == length_of_iterable_returned_by_operator, f"Operator {operator_name} consumed elements"
        assert original_iterator.qcount() == 10, f"Operator {operator_name} mutated source collection"

def test_all_scalar_or_action_operators_when_called_on_generator_backed_iterable_consume_elements() -> None:
    for operator_name, operator in scalar_or_action_operators:
        original_iterator = generate_10_ints()
        operator(original_iterator)
        assert original_iterator.qcount() != 10, f"Operator {operator_name} consumed no elements"

def test_no_scalar_or_action_operators_when_called_on_collection_backed_iterator_consume_elements() -> None:
    for operator_name, operator in scalar_or_action_operators:
        original_iterator = collection_10_ints()
        operator(original_iterator)
        assert original_iterator.qcount() == 10, f"Operator {operator_name} mutated source collection"
</file>

<file path="src/queryablecollections/_private_implementation_details/immutable_sequence.py">
from __future__ import annotations

from collections.abc import Sequence
from typing import overload, override


class ImmutableSequence[TItem](Sequence[TItem]):
    __slots__: tuple[str, ...] = ("_items",)
    def __init__(self, items: Sequence[TItem] = ()) -> None:
        self._items: Sequence[TItem] = items  # Direct reference - no copying

    @override
    def __len__(self) -> int:
        return len(self._items)

    @overload
    def __getitem__(self, index: int) -> TItem: ...

    @overload
    def __getitem__(self, index: slice) -> ImmutableSequence[TItem]: ...

    @override
    def __getitem__(self, index: int | slice) -> TItem | ImmutableSequence[TItem]:
        if isinstance(index, slice):
            return ImmutableSequence(self._items[index])
        return self._items[index]

    @override
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Sequence):
            return False
        if len(self) != len(other):  # pyright: ignore [reportUnknownArgumentType]
            return False
        return all(self_item == other_item for self_item, other_item in zip(self._items, other, strict=False))  # pyright: ignore [reportUnknownArgumentType, reportUnknownVariableType]

    @override
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({list(self._items)!r})"
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/__init__.py">
from __future__ import annotations

from queryablecollections._private_implementation_details.sort_by_instructions import sort_by_instructions

from .aggregate import aggregate
from .all import all
from .any import any
from .append import append
from .as_ import as_decimals, as_floats, as_fractions, as_ints
from .chunk import chunk
from .concat import concat
from .contains import contains
from .distinct import distinct
from .distinct_by import distinct_by
from .element_at import element_at
from .element_at_or_none import element_at_or_none
from .first import first
from .first_or_none import first_or_none
from .flatten import flatten
from .for_each import for_each
from .group_by_q import group_by_q
from .group_join import group_join
from .join import join
from .last import last
from .last_or_none import last_or_none
from .max_by import max_by
from .min_by import min_by
from .of_type import of_type
from .pipe import pipe
from .prepend import prepend
from .qcount import qcount
from .qcount_by import qcount_by
from .qexcept import qexcept
from .qindex import qindex
from .qintersect import qintersect
from .qunion import qunion
from .qunion_by import qunion_by
from .range import range
from .repeat import repeat
from .reversed import reversed
from .select import select
from .select_index import select_index
from .select_many import select_many
from .sequence_equal import sequence_equal
from .single import single
from .single_or_none import single_or_none
from .skip import skip
from .skip_last import skip_last
from .skip_while import skip_while
from .take import take
from .take_last import take_last
from .take_while import take_while
from .to_dict import to_dict
from .where import where
from .where_key_in import where_key_in
from .where_key_not_in import where_key_not_in
from .where_not_none import where_not_none
from .zip import zip, zip2, zip3
from .zip_tuple import zip_tuple, zip_tuple2, zip_tuple3

__all__ = [
        "aggregate",
        "all",
        "any",
        "append",
        "as_decimals",
        "as_floats",
        "as_fractions",
        "as_ints",
        "chunk",
        "concat",
        "contains",
        "distinct",
        "distinct_by",
        "element_at",
        "element_at_or_none",
        "first",
        "first_or_none",
        "flatten",
        "for_each",
        "group_by_q",
        "group_join",
        "join",
        "last",
        "last_or_none",
        "of_type",
        "pipe",
        "prepend",
        "qcount",
        "max_by",
        "min_by",
        "qcount_by",
        "qexcept",
        "where_key_not_in",
        "qindex",
        "qintersect",
        "where_key_in",
        "qunion",
        "qunion_by",
        "range",
        "reversed",
        "select",
        "select_index",
        "select_many",
        "single",
        "single_or_none",
        "skip",
        "skip_last",
        "sort_by_instructions",
        "take",
        "take_last",
        "take_while",
        "to_dict",
        "where",
        "where_not_none",
        "zip",
        "zip2",
        "zip3",
        "zip_tuple",
        "zip_tuple2",
        "zip_tuple3",
        "skip_while",
        "sequence_equal",
        "repeat"
]
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/aggregate.py">
from __future__ import annotations

from collections.abc import Callable
from typing import TYPE_CHECKING, cast

from queryablecollections.q_errors import EmptyIterableError

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Selector

def aggregate_simple[TItem](self: Iterable[TItem], func: Callable[[TItem, TItem], TItem]) -> TItem:
    iterator = iter(self)
    try:
        accumulated_value = next(iterator)
    except StopIteration:
        raise EmptyIterableError() from None

    for item in iterator:
        accumulated_value = func(accumulated_value, item)

    return accumulated_value

def aggregate_seed[TItem, TAccumulate](
        self: Iterable[TItem],
        seed: TAccumulate,
        func: Callable[[TAccumulate, TItem], TAccumulate]
) -> TAccumulate:
    accumulated_value = seed
    for item in self:
        accumulated_value = func(accumulated_value, item)
    return accumulated_value

def aggregate[T, TAccumulate, TResult](self: Iterable[T], func: Callable[[T, T], T] | Callable[[TAccumulate, T], TAccumulate],
                                       seed: TAccumulate | None = None,
                                       result_selector: Selector[TAccumulate, TResult] | None = None) -> T | TAccumulate | TResult:
    if seed is None:
        return aggregate_simple(self, cast(Callable[[T, T], T], func))

    aggregated_value = aggregate_seed(self, seed, cast(Callable[[TAccumulate, T], TAccumulate], func))
    if result_selector is None:
        return aggregated_value

    return result_selector(aggregated_value)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/all.py">
from __future__ import annotations

import builtins
from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details import ops

if TYPE_CHECKING:
    from queryablecollections._private_implementation_details.type_aliases import Predicate
    from queryablecollections.q_iterable import QIterable


def all[TItem](self: QIterable[TItem], predicate: Predicate[TItem]) -> bool:
    return builtins.all(ops.select(self, predicate))
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/any.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from queryablecollections._private_implementation_details.type_aliases import Predicate
    from queryablecollections.q_iterable import QIterable


def any[TItem](self: QIterable[TItem], predicate: Predicate[TItem] | None = None) -> bool:
    if predicate is not None:
        self = self.where(predicate)

    iterator = iter(self)
    try:
        next(iterator)
        return True  # noqa: TRY300
    except StopIteration:
        return False
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/append.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

def append[TItem](self: Iterable[TItem], item: TItem) -> Iterable[TItem]:
    yield from self
    yield item
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/as_.py">
from __future__ import annotations

from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C

if TYPE_CHECKING:
    from decimal import Decimal
    from fractions import Fraction

    from queryablecollections.collections.numeric.q_decimal_types import QDecimalIterable
    from queryablecollections.collections.numeric.q_float_types import QFloatIterable
    from queryablecollections.collections.numeric.q_fraction_types import QFractionIterable
    from queryablecollections.collections.numeric.q_int_types import QIntIterable
    from queryablecollections.q_iterable import QIterable

def as_ints(self: QIterable[int]) -> QIntIterable: return C.int_iterable(lambda: self)
def as_floats(self: QIterable[float]) -> QFloatIterable: return C.float_iterable(lambda: self)
def as_decimals(self: QIterable[Decimal]) -> QDecimalIterable: return C.decimal_iterable(lambda: self)
def as_fractions(self: QIterable[Fraction]) -> QFractionIterable: return C.fraction_iterable(lambda: self)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/chunk.py">
from __future__ import annotations

from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C
from queryablecollections.q_errors import ArgumentError

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections.collections.q_list import QList

def chunk[TItem](self: Iterable[TItem], size: int) -> Iterable[QList[TItem]]:
    if size <= 0:
        raise ArgumentError("Chunk size must be greater than 0")

    iterator = iter(self)
    while True:
        chunk_items: QList[TItem] = C.list()
        for _ in range(size):
            try:
                chunk_items.append(next(iterator))
            except StopIteration:
                if chunk_items:
                    yield chunk_items
                return
        yield chunk_items
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/concat.py">
from __future__ import annotations

import itertools
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable


def concat[T](self: Iterable[T], *others: Iterable[T]) -> Iterable[T]:
    return itertools.chain(self, *others)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/contains.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

def contains[T](self: Iterable[T], item: T) -> bool:
    return item in self
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/distinct_by.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Selector


def distinct_by[TItem, TKey](self: Iterable[TItem], key_selector: Selector[TItem, TKey]) -> Iterable[TItem]:
    seen: dict[TKey, TItem] = {}
    for item in self:
        key = key_selector(item)
        if key not in seen:
            seen[key] = item
    return seen.values()
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/distinct.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable


def distinct[TItem](self: Iterable[TItem]) -> Iterable[TItem]:
    return dict.fromkeys(self)  # highly optimized and guaranteed to keep ordering
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/element_at_or_none.py">
from __future__ import annotations

import itertools
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable


def element_at_or_none[TItem](self: Iterable[TItem],
                              index: int) -> TItem | None:
    return next(itertools.islice(self, index, index + 1), None)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/element_at.py">
from __future__ import annotations

import itertools
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable


def element_at[TItem](self: Iterable[TItem], index: int) -> TItem:
    try:
        return next(itertools.islice(self, index, index + 1))
    except StopIteration:
        raise IndexError(f"Index {index} was outside the bounds of the collection.") from None
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/first_or_none.py">
from __future__ import annotations

from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details import ops

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Predicate


def first_or_none[TItem](self: Iterable[TItem],
                         predicate: Predicate[TItem] | None = None) -> TItem | None:
    if predicate is not None:
        self = ops.where(self, predicate)
    try:
        return next(iter(self))
    except StopIteration:
        return None
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/first.py">
from __future__ import annotations

from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details import ops
from queryablecollections.q_errors import EmptyIterableError

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Predicate

def first[TItem](self: Iterable[TItem],
                 predicate: Predicate[TItem] | None = None) -> TItem:
    if predicate is not None:
        self = ops.where(self, predicate)
    try:
        return next(iter(self))
    except StopIteration:
        raise EmptyIterableError() from None
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/flatten.py">
from __future__ import annotations

import itertools
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

def flatten[T](self: Iterable[Iterable[T]]) -> Iterable[T]:
    return itertools.chain.from_iterable(self)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/for_each.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from queryablecollections._private_implementation_details.type_aliases import Action1
    from queryablecollections.q_iterable import QIterable


def for_each[TItem](self: QIterable[TItem], action: Action1[TItem]) -> QIterable[TItem]:
    for item in self: action(item)
    return self
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/group_by_q.py">
from __future__ import annotations

from typing import TYPE_CHECKING

# noinspection PyPep8Naming
from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Selector
    from queryablecollections.collections.q_default_dict import QDefaultDict
    from queryablecollections.q_grouping import QGrouping
    from queryablecollections.q_iterable import QIterable

def _group_by[TElement, TKey](self: Iterable[TElement], key_selector: Selector[TElement, TKey]) -> Iterable[QGrouping[TKey, TElement]]:
    from queryablecollections.collections.q_list import QList
    groups: QDefaultDict[TKey, QList[TElement]] = C.default_dict(QList[TElement])

    for item in self:
        groups[key_selector(item)].append(item)

    return groups.qitems().select(C.grouping)

def _group_by_with_element_selector[TSourceElement, TKey, TGroupElement](self: Iterable[TSourceElement],
                                                                         key_selector: Selector[TSourceElement, TKey],
                                                                         element_selector: Selector[TSourceElement, TGroupElement]) -> Iterable[QGrouping[TKey, TGroupElement]]:
    from queryablecollections.collections.q_list import QList
    groups: QDefaultDict[TKey, QList[TGroupElement]] = C.default_dict(QList[TGroupElement])

    for item in self:
        groups[key_selector(item)].append(element_selector(item))

    return groups.qitems().select(C.grouping)


def group_by_q[TItem, TKey, TElement](self: QIterable[TItem], key: Selector[TItem, TKey], element: Selector[TItem, TElement] | None = None) -> QIterable[QGrouping[TKey, TItem]] | QIterable[QGrouping[TKey, TElement]]:
    return (C.lazy_iterable(lambda: _group_by(self, key))
            if element is None
            else C.lazy_iterable(lambda: _group_by_with_element_selector(self, key, element)))
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/group_join.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Callable, Iterable

    from queryablecollections._private_implementation_details.type_aliases import Selector

def group_join[TOuter, TInner, TKey, TResult](
        self: Iterable[TOuter],
        other: Iterable[TInner],
        self_key: Selector[TOuter, TKey],
        group_key: Selector[TInner, TKey],
        select: Callable[[TOuter, Iterable[TInner]], TResult]
) -> Iterable[TResult]:
    groups_by_key: dict[TKey, list[TInner]] = {}
    for other_item in other:
        key = group_key(other_item)
        if key not in groups_by_key:
            groups_by_key[key] = []
        groups_by_key[key].append(other_item)

    for self_item in self:
        self_key_value = self_key(self_item)
        yield select(self_item, groups_by_key.get(self_key_value, []))
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/join.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Callable, Iterable

    from queryablecollections._private_implementation_details.type_aliases import Selector

def join[TOuter, TInner, TKey, TResult](
        first: Iterable[TOuter],
        second: Iterable[TInner],
        first_key: Selector[TOuter, TKey],
        second_key: Selector[TInner, TKey],
        select: Callable[[TOuter, TInner], TResult]
) -> Iterable[TResult]:
    inner_lookup: dict[TKey, list[TInner]] = {}
    for inner_item in second:
        key = second_key(inner_item)
        if key not in inner_lookup:
            inner_lookup[key] = []
        inner_lookup[key].append(inner_item)

    # For each outer element, find matching inner elements and yield results
    for outer_item in first:
        outer_key = first_key(outer_item)
        if outer_key in inner_lookup:
            for inner_item in inner_lookup[outer_key]:
                yield select(outer_item, inner_item)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/last_or_none.py">
from __future__ import annotations

from typing import TYPE_CHECKING, cast

from queryablecollections._private_implementation_details import ops

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Predicate

def last_or_none[TItem](self: Iterable[TItem], predicate: Predicate[TItem] | None = None) -> TItem | None:
    if predicate is not None:
        self = ops.where(self, predicate)

    sentinel = object()
    last_item: TItem | object = sentinel
    for item in self:
        last_item = item

    if last_item is sentinel:
        return None

    return cast(TItem, last_item)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/last.py">
from __future__ import annotations

from typing import TYPE_CHECKING, cast

from queryablecollections._private_implementation_details import ops
from queryablecollections.q_errors import EmptyIterableError

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Predicate

def last[TItem](self: Iterable[TItem], predicate: Predicate[TItem] | None = None) -> TItem:
    if predicate is not None:
        self = ops.where(self, predicate)

    sentinel = object()
    last_item: TItem | object = sentinel
    for item in self:
        last_item = item

    if last_item is sentinel:
        raise EmptyIterableError()

    return cast(TItem, last_item)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/max_by.py">
from __future__ import annotations

from typing import TYPE_CHECKING

from queryablecollections.q_errors import EmptyIterableError

if TYPE_CHECKING:
    from collections.abc import Iterable

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Selector


def max_by[TItem, TKey: SupportsRichComparison](self: Iterable[TItem], key_selector: Selector[TItem, TKey]) -> TItem:
    iterator = iter(self)
    try:
        best_item = next(iterator)
        best_key = key_selector(best_item)
    except StopIteration:
        raise EmptyIterableError() from None

    for item in iterator:
        key = key_selector(item)
        if key > best_key:  # pyright: ignore [reportOperatorIssue]
            best_key = key
            best_item = item
    return best_item
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/min_by.py">
from __future__ import annotations

from typing import TYPE_CHECKING

from queryablecollections.q_errors import EmptyIterableError

if TYPE_CHECKING:
    from collections.abc import Iterable

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Selector


def min_by[TItem, TKey: SupportsRichComparison](self: Iterable[TItem], key_selector: Selector[TItem, TKey]) -> TItem:
    iterator = iter(self)
    try:
        best_item = next(iterator)
        best_key = key_selector(best_item)
    except StopIteration:
        raise EmptyIterableError() from None

    for item in iterator:
        key = key_selector(item)
        if key < best_key:  # pyright: ignore [reportOperatorIssue]
            best_key = key
            best_item = item
    return best_item
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/of_type.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections.q_iterable import QIterable


class _TypeTester:
    def __init__(self, type_: type) -> None:
        self.type_:type = type_
    def __call__(self, value: object) -> bool:
        return isinstance(value, self.type_)


def of_type[TItem, TResult](self: QIterable[TItem], type_: type[TResult]) -> Iterable[TResult]:
    return self.where(_TypeTester(type_)).cast.to(type_)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/pipe.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from queryablecollections._private_implementation_details.type_aliases import Selector
    from queryablecollections.q_iterable import QIterable

def pipe[TItem, TReturn](self: QIterable[TItem],
                         action: Selector[QIterable[TItem], TReturn]) -> TReturn:
    return action(self)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/prepend.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

def prepend[TItem](self: Iterable[TItem], item: TItem) -> Iterable[TItem]:
    yield item
    yield from self
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/qcount_by.py">
from __future__ import annotations

from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Selector
    from queryablecollections.collections.q_dict import QDict
    from queryablecollections.collections.q_key_value_pair import KeyValuePair
    from queryablecollections.q_iterable import QIterable

def qcount_by[TItem, TKey](self: Iterable[TItem], key_selector: Selector[TItem, TKey]) -> QIterable[KeyValuePair[TKey, int]]:
    counts: QDict[TKey, int] = C.dict()

    for item in self:
        key = key_selector(item)
        counts[key] = counts.get(key, 0) + 1

    return counts.qitems()
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/qcount.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from queryablecollections._private_implementation_details.type_aliases import Predicate
    from queryablecollections.q_iterable import QIterable


def qcount[TItem](self: QIterable[TItem], predicate: Predicate[TItem] | None = None) -> int:
    if predicate is not None:
        self = self.where(predicate)

    return self._optimized_length()  # pyright: ignore [reportPrivateUsage]
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/qexcept.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable


def qexcept[TItem](self: Iterable[TItem], other: Iterable[TItem]) -> Iterable[TItem]:
    other_set = set(other)
    seen: set[TItem] = set()
    for item in self:
        if item not in other_set and item not in seen:
            seen.add(item)
            yield item
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/qindex.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

def qindex[TItem](self: Iterable[TItem]) -> Iterable[tuple[int, TItem]]: return enumerate(self)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/qintersect.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable


def qintersect[TItem](self: Iterable[TItem], other: Iterable[TItem]) -> Iterable[TItem]:
    other_set = set(other)
    seen: set[TItem] = set()
    for item in self:
        if item in other_set and item not in seen:
            seen.add(item)
            yield item
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/qunion_by.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Selector

def qunion_by[TItem, TKey](self: Iterable[TItem], other: Iterable[TItem], key_selector: Selector[TItem, TKey]) -> Iterable[TItem]:
    seen_keys: set[TKey] = set()

    # First, yield distinct items from self based on key
    for item in self:
        item_key = key_selector(item)
        if item_key not in seen_keys:
            seen_keys.add(item_key)
            yield item

    # Then, yield items from other that have keys not seen in self
    for item in other:
        item_key = key_selector(item)
        if item_key not in seen_keys:
            seen_keys.add(item_key)
            yield item
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/qunion.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

def qunion[TItem](self: Iterable[TItem], other: Iterable[TItem]) -> Iterable[TItem]:
    seen: set[TItem] = set()
    for item in self:
        if item not in seen:
            seen.add(item)
            yield item

    for item in other:
        if item not in seen:
            seen.add(item)
            yield item
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/range.py">
from __future__ import annotations

import builtins
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

    pass

def range(start_or_stop_before: int, stop_before: int | None = None, step: int = 1, /) -> Iterable[int]:
    return (builtins.range(start_or_stop_before)
            if stop_before is None
            else builtins.range(start_or_stop_before, stop_before, step))
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/repeat.py">
# src/queryablecollections/_private_implementation_details/ops/repeat.py
from __future__ import annotations

import itertools
from typing import TYPE_CHECKING

from queryablecollections.q_errors import ArgumentError

if TYPE_CHECKING:
    from collections.abc import Iterable


def repeat[T](element: T, count: int) -> Iterable[T]:
    if count < 0:
        raise ArgumentError("Count must be greater than or equal to 0")
    return itertools.repeat(element, count)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/reversed.py">
from __future__ import annotations

import builtins
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable


def reversed[TItem](self: Iterable[TItem]) -> Iterable[TItem]:
    return builtins.reversed(list(self))
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/select_index.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Callable, Iterable

def select_index[T, TResult](self: Iterable[T], selector: Callable[[T, int], TResult]) -> Iterable[TResult]:
    return (selector(item, index) for index, item in enumerate(self))
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/select_many.py">
from __future__ import annotations

from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details import ops as ops

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Selector


def select_many[T, TSubItem](self: Iterable[T], selector: Selector[T, Iterable[TSubItem]]) -> Iterable[TSubItem]:
    return ops.flatten(ops.select(self, selector))
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/select.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Selector

def select[T, TResult](self: Iterable[T], selector: Selector[T, TResult]) -> Iterable[TResult]:
    return (selector(item) for item in self)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/sequence_equal.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

def sequence_equal[TItem](self: Iterable[TItem], other: Iterable[TItem]) -> bool:
    self_iterator = iter(self)
    other_iterator = iter(other)

    while True:
        try:
            self_current_element = next(self_iterator)
        except StopIteration:
            try:
                next(other_iterator)
                return False  # self shorter than other  # noqa: TRY300
            except StopIteration:
                return True

        try:
            other_current_element = next(other_iterator)
        except StopIteration:
            return False  # Other shorter than self

        if self_current_element != other_current_element:
            return False
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/single_or_none.py">
from __future__ import annotations

from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details import ops
from queryablecollections.q_errors import InvalidOperationError

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Predicate

def single_or_none[TItem](self: Iterable[TItem],
                          predicate: Predicate[TItem] | None = None) -> TItem | None:
    if predicate is not None:
        self = ops.where(self, predicate)
    iterator = iter(self)
    try:
        first_element = next(iterator)
    except StopIteration:
        return None

    try:
        next(iterator)  # Check if there's a second element
        raise InvalidOperationError("Sequence contains more than one element")
    except StopIteration:
        return first_element
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/single.py">
from __future__ import annotations

from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details import ops
from queryablecollections.q_errors import EmptyIterableError, InvalidOperationError

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Predicate

def single[TItem](self: Iterable[TItem],
                  predicate: Predicate[TItem] | None = None) -> TItem:
    if predicate is not None:
        self = ops.where(self, predicate)
    iterator = iter(self)
    try:
        first_element = next(iterator)
    except StopIteration:
        raise EmptyIterableError() from None

    try:
        next(iterator)
        raise InvalidOperationError("Sequence contains more than one element")
    except StopIteration:
        return first_element
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/skip_last.py">
from __future__ import annotations

from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C

if TYPE_CHECKING:
    from collections.abc import Iterable


def skip_last[TItem](self: Iterable[TItem], count: int) -> Iterable[TItem]:
    def skip_last_implementation() -> Iterable[TItem]:
        if count <= 0: return self
        items = list(self)
        if count >= len(items):
            return C.empty_iterable()
        return items[:-count]
    return C.lazy_iterable(skip_last_implementation)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/skip_while.py">
# src/queryablecollections/_private_implementation_details/ops/skip_while.py
from __future__ import annotations

import itertools
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Predicate


def skip_while[TItem](self: Iterable[TItem], predicate: Predicate[TItem]) -> Iterable[TItem]:
    return itertools.dropwhile(predicate, self)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/skip.py">
from __future__ import annotations

import itertools
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

def skip[TItem](self: Iterable[TItem],
                count: int) -> Iterable[TItem]:
    if count <= 0: return self
    return itertools.islice(self, count, None)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/take_last.py">
from __future__ import annotations

from collections import deque
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

_empty_iterator = iter(())
def take_last[TItem](self: Iterable[TItem], count: int) -> Iterable[TItem]:
    if count <= 0: return _empty_iterator
    buffer = deque[TItem](maxlen=count)
    for item in self:
        buffer.append(item)

    return buffer
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/take_while.py">
from __future__ import annotations

import itertools
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Predicate


def take_while[TItem](self: Iterable[TItem], predicate: Predicate[TItem]) -> Iterable[TItem]:
    return itertools.takewhile(predicate, self)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/take.py">
from __future__ import annotations

import itertools
from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C

if TYPE_CHECKING:
    from collections.abc import Iterable


def take[TItem](self: Iterable[TItem], count: int) -> Iterable[TItem]:
    if count <= 0: return C.empty_iterable()
    return itertools.islice(self, count)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/to_dict.py">
from __future__ import annotations

from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C

if TYPE_CHECKING:
    from queryablecollections._private_implementation_details.type_aliases import Selector
    from queryablecollections.collections.q_dict import QDict
    from queryablecollections.q_iterable import QIterable


def to_dict[T, TKey, TValue](self: QIterable[T], key_selector: Selector[T, TKey], value_selector: Selector[T, TValue]) -> QDict[TKey, TValue]:
    return C.dict((key_selector(item), value_selector(item)) for item in self)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/where_key_in.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Selector


def where_key_in[TItem, TKey](self: Iterable[TItem], keys: Iterable[TKey], key_selector: Selector[TItem, TKey]) -> Iterable[TItem]:
    keys_set: set[TKey] = set(keys)
    seen_keys: set[TKey] = set()
    for item in self:
        item_key = key_selector(item)
        if item_key in keys_set and item_key not in seen_keys:
            seen_keys.add(item_key)
            yield item
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/where_key_not_in.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Selector


def where_key_not_in[TItem, TKey](self: Iterable[TItem], keys: Iterable[TKey], key_selector: Selector[TItem, TKey]) -> Iterable[TItem]:
    excluded_keys:set[TKey] = set(keys)
    seen_keys: set[TKey] = set()
    for item in self:
        item_key = key_selector(item)
        if item_key in excluded_keys:
            continue
        if item_key in seen_keys:
            continue
        seen_keys.add(item_key)
        yield item
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/where_not_none.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

def where_not_none[TItem](self: Iterable[TItem]) -> Iterable[TItem]:
    return (item for item in self if item is not None)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/where.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Predicate

def where[TItem](self: Iterable[TItem], predicate: Predicate[TItem]) -> Iterable[TItem]:
    return (item for item in self if predicate(item))
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/zip_tuple.py">
from __future__ import annotations

import builtins
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

def zip_tuple[T, T2](first: Iterable[T],
                     second: Iterable[T2]) -> Iterable[tuple[T, T2]]:
    return builtins.zip(first, second, strict=False)

def zip_tuple2[T, T2, T3](first: Iterable[T],
                          second: Iterable[T2],
                          third: Iterable[T3]) -> Iterable[tuple[T, T2, T3]]:
    return builtins.zip(first, second, third, strict=False)

def zip_tuple3[T, T2, T3, T4](first: Iterable[T],
                              second: Iterable[T2],
                              third: Iterable[T3],
                              fourth: Iterable[T4]) -> Iterable[tuple[T, T2, T3, T4]]:
    return builtins.zip(first, second, third, fourth, strict=False)
</file>

<file path="src/queryablecollections/_private_implementation_details/ops/zip.py">
from __future__ import annotations

import builtins
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Callable, Iterable

def zip[T, T2, TOut](first: Iterable[T],
                     second: Iterable[T2],
                     select: Callable[[T, T2], TOut]) -> Iterable[TOut]:
    for (first_item, second_item) in builtins.zip(first, second, strict=False):
        yield select(first_item, second_item)

def zip2[T, T2, T3, TOut](first: Iterable[T],
                          second: Iterable[T2],
                          third: Iterable[T3],
                          select: Callable[[T, T2, T3], TOut]) -> Iterable[TOut]:
    for first_item, second_item, third_item in builtins.zip(first, second, third, strict=False):
        yield select(first_item, second_item, third_item)

def zip3[T, T2, T3, T4, TOut](first: Iterable[T],
                              second: Iterable[T2],
                              third: Iterable[T3],
                              fourth: Iterable[T4],
                              select: Callable[[T, T2, T3, T4], TOut]) -> Iterable[TOut]:
    for first_item, second_item, third_item, fourth_item in builtins.zip(first, second, third, fourth, strict=False):
        yield select(first_item, second_item, third_item, fourth_item)
</file>

<file path="src/queryablecollections/_private_implementation_details/q_lazy_iterable.py">
from __future__ import annotations

from typing import TYPE_CHECKING, override

from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from collections.abc import Iterable, Iterator

    from queryablecollections._private_implementation_details.type_aliases import Func


class QLazyIterableImplementation[TItem](QIterable[TItem]):
    __slots__: tuple[str, ...] = ("_factory",)
    def __init__(self, iterable_factory: Func[Iterable[TItem]]) -> None:
        self._factory: Func[Iterable[TItem]] = iterable_factory

    @override
    def __iter__(self) -> Iterator[TItem]: yield from self._factory()

class QCachingIterableImplementation[TItem](QIterable[TItem]):
    __slots__: tuple[str, ...] = ("_iterable",)
    def __init__(self, iterable: Iterable[TItem]) -> None:
        self._iterable: Iterable[TItem] = iterable

    @override
    def __iter__(self) -> Iterator[TItem]:
        yield from iter(self._iterable)
</file>

<file path="src/queryablecollections/_private_implementation_details/q_zero_overhead_collection_contructors.py">
from __future__ import annotations

from typing import TYPE_CHECKING, Never

if TYPE_CHECKING:
    from collections.abc import Iterable
    from decimal import Decimal
    from fractions import Fraction

    from queryablecollections._private_implementation_details.sort_instruction import SortInstruction
    from queryablecollections._private_implementation_details.type_aliases import Func
    from queryablecollections.collections.numeric.q_decimal_types import QDecimalIterable
    from queryablecollections.collections.numeric.q_float_types import QFloatIterable
    from queryablecollections.collections.numeric.q_fraction_types import QFractionIterable
    from queryablecollections.collections.numeric.q_int_types import QIntIterable
    from queryablecollections.collections.q_default_dict import QDefaultDict
    from queryablecollections.collections.q_dict import QDict
    from queryablecollections.collections.q_frozen_set import QFrozenSet
    from queryablecollections.collections.q_list import QList
    from queryablecollections.collections.q_sequence import QSequence
    from queryablecollections.collections.q_set import QSet
    from queryablecollections.q_cast import QCast
    from queryablecollections.q_grouping import QGrouping
    from queryablecollections.q_iterable import QIterable
    from queryablecollections.q_ordered_iterable import QOrderedIterable


class ZeroImportOverheadConstructors:
    """This class contains static methods that are used to construct the collection classes with zero import overhead and without the need to complicate methods thoughouht the library by having to import these classes within functions in order to avoid circular imports."""
    @staticmethod
    def list[TItem](iterable: Iterable[TItem] = ()) -> QList[TItem]:
        from queryablecollections.collections.q_list import QList
        ZeroImportOverheadConstructors.list = QList  # replace this method with a direct call so that future calls have zero import overhead
        return ZeroImportOverheadConstructors.list(iterable)  # use the new version to prove from the very first call that it works

    @staticmethod
    def sequence[TItem](iterable: Iterable[TItem]) -> QSequence[TItem]:
        from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
        ZeroImportOverheadConstructors.sequence = QImmutableSequence  # replace this method with a direct call so that future calls have zero import overhead
        return ZeroImportOverheadConstructors.sequence(iterable)  # use the new version to prove from the very first call that it works

    @staticmethod
    def set[TItem](iterable: Iterable[TItem]) -> QSet[TItem]:
        from queryablecollections.collections.q_set import QSet
        ZeroImportOverheadConstructors.set = QSet  # replace this method with a direct call so that future calls have zero import overhead
        return ZeroImportOverheadConstructors.set(iterable)  # use the new version to prove from the very first call that it works

    @staticmethod
    def frozen_set[TItem](iterable: Iterable[TItem]) -> QFrozenSet[TItem]:
        from queryablecollections.collections.q_frozen_set import QFrozenSet
        ZeroImportOverheadConstructors.frozen_set = QFrozenSet  # replace this method with a direct call so that future calls have zero import overhead
        return ZeroImportOverheadConstructors.frozen_set(iterable)  # use the new version to prove from the very first call that it works

    @staticmethod
    def cast[TItem](qiterable: QIterable[TItem]) -> QCast[TItem]:
        from queryablecollections.q_cast import QCast
        ZeroImportOverheadConstructors.cast = QCast  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.cast(qiterable)  # use the new version to prove from the very first call that it works

    @staticmethod
    def empty_iterable[TItem]() -> QIterable[Never]:  # pyright: ignore [reportInvalidTypeVarUse]
        empty_iterable = ZeroImportOverheadConstructors.lazy_iterable(lambda: ())
        def get_empty() -> QIterable[TItem]: return empty_iterable  # pyright: ignore [reportReturnType]
        ZeroImportOverheadConstructors.empty_iterable = get_empty  # replace this method itself with  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.empty_iterable()

    @staticmethod
    def lazy_iterable[TItem](iterable_factory: Func[Iterable[TItem]]) -> QIterable[TItem]:
        from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
        ZeroImportOverheadConstructors.lazy_iterable = QLazyIterableImplementation  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.lazy_iterable(iterable_factory)  # use the new version to prove from the very first call that it works

    @staticmethod
    def caching_iterable[TItem](iterable: Iterable[TItem]) -> QIterable[TItem]:
        from queryablecollections._private_implementation_details.q_lazy_iterable import QCachingIterableImplementation
        ZeroImportOverheadConstructors.caching_iterable = QCachingIterableImplementation  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.caching_iterable(iterable)  # use the new version to prove from the very first call that it works

    @staticmethod
    def ordered_iterable[TItem](factory: Func[QIterable[TItem]], sorting_instructions: list[SortInstruction[TItem]]) -> QOrderedIterable[TItem]:
        from queryablecollections.q_ordered_iterable import QOrderedIterable
        ZeroImportOverheadConstructors.ordered_iterable = QOrderedIterable  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.ordered_iterable(factory, sorting_instructions)  # use the new version to prove from the very first call that it works

    @staticmethod
    def grouping[TKey, TItem](values: tuple[TKey, QList[TItem]]) -> QGrouping[TKey, TItem]:
        from queryablecollections.q_grouping import QGrouping
        ZeroImportOverheadConstructors.grouping = QGrouping  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.grouping(values)  # use the new version to prove from the very first call that it works

    @staticmethod
    def default_dict[TKey, TElement](factory: Func[TElement]) -> QDefaultDict[TKey, TElement]:  # pyright: ignore [reportInvalidTypeVarUse]
        from queryablecollections.collections.q_default_dict import QDefaultDict
        ZeroImportOverheadConstructors.default_dict = QDefaultDict  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.default_dict(factory)

    @staticmethod
    def dict[TKey, TValue](elements: Iterable[tuple[TKey, TValue]] = ()) -> QDict[TKey, TValue]:
        from queryablecollections.collections.q_dict import QDict
        ZeroImportOverheadConstructors.dict = QDict  # replace this method with a direct call so that future calls have zero import overhead
        return ZeroImportOverheadConstructors.dict(elements)  # use the new version to prove from the very first call that it works

    @staticmethod
    def int_iterable(factory: Func[Iterable[int]]) -> QIntIterable:  # pyright: ignore [reportInvalidTypeVarUse]
        from queryablecollections.collections.numeric.q_int_types import QIntIterableImplementation
        ZeroImportOverheadConstructors.int_iterable = QIntIterableImplementation  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.int_iterable(factory)  # use the new version to prove from the very first call that it works

    @staticmethod
    def float_iterable(factory: Func[Iterable[float]]) -> QFloatIterable:  # pyright: ignore [reportInvalidTypeVarUse]
        from queryablecollections.collections.numeric.q_float_types import QFloatIterableImplementation
        ZeroImportOverheadConstructors.float_iterable = QFloatIterableImplementation  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.float_iterable(factory)  # use the new version to prove from the very first call that it works

    @staticmethod
    def fraction_iterable(factory: Func[Iterable[Fraction]]) -> QFractionIterable:  # pyright: ignore [reportInvalidTypeVarUse]
        from queryablecollections.collections.numeric.q_fraction_types import QFractionIterableImplementation
        ZeroImportOverheadConstructors.fraction_iterable = QFractionIterableImplementation  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.fraction_iterable(factory)  # use the new version to prove from the very first call that it works

    @staticmethod
    def decimal_iterable(factory: Func[Iterable[Decimal]]) -> QDecimalIterable:  # pyright: ignore [reportInvalidTypeVarUse]
        from queryablecollections.collections.numeric.q_decimal_types import QDecimalIterableImplementation
        ZeroImportOverheadConstructors.decimal_iterable = QDecimalIterableImplementation  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.decimal_iterable(factory)  # use the new version to prove from the very first call that it works
</file>

<file path="src/queryablecollections/_private_implementation_details/sort_by_instructions.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.sort_instruction import SortInstruction


def sort_by_instructions[TItem](self: Iterable[TItem], sort_instructions: list[SortInstruction[TItem]]) -> Iterable[TItem]:
    items = list(self)
    for instruction in sort_instructions:  # the official documentation recommends multiple sort passes. Unless proven to perform badly in the common usage scenarios by actual performance testing, let's keep it simple: https://docs.python.org/3/howto/sorting.html
        items.sort(key=instruction.key_selector, reverse=instruction.descending)

    yield from items
</file>

<file path="src/queryablecollections/_private_implementation_details/sort_instruction.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Selector


class SortInstruction[TItem]:
    __slots__: tuple[str, ...] = ("key_selector", "descending")
    def __init__(self, key_selector: Selector[TItem, SupportsRichComparison], descending: bool) -> None:
        self.key_selector: Selector[TItem, SupportsRichComparison] = key_selector
        self.descending: bool = descending
</file>

<file path="src/queryablecollections/_private_implementation_details/type_aliases.py">
from __future__ import annotations

from collections.abc import Callable

type Action = Callable[[], None]
type Action1[TIn] = Callable[[TIn], None]
type Action2[TIn, TIn2] = Callable[[TIn, TIn2], None]
type Action3[TIn, TIn2, TIn3] = Callable[[TIn, TIn2, TIn3], None]
type Action4[TIn, TIn2, TIn3, TIn4] = Callable[[TIn, TIn2, TIn3, TIn4], None]

type Func[TOut] = Callable[[], TOut]
type Func1[TIn, TOut] = Callable[[TIn], TOut]
type Func2[TIn, TIn2, TOut] = Callable[[TIn, TIn2], TOut]
type Func3[TIn, TIn2, TIn3, TOut] = Callable[[TIn, TIn2, TIn3], TOut]
type Func4[TIn, TIn2, TIn3, TIn4, TOut] = Callable[[TIn, TIn2, TIn3, TIn4], TOut]


type Predicate[TIn] = Callable[[TIn], bool]
type Selector[TIn, TOut] = Callable[[TIn], TOut]
</file>

<file path="src/queryablecollections/collections/numeric/q_decimal_types.py">
from __future__ import annotations

import statistics
from abc import ABC
from decimal import Decimal
from typing import TYPE_CHECKING, cast, override

from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
from queryablecollections._private_implementation_details.sort_instruction import SortInstruction
from queryablecollections.collections.q_frozen_set import QFrozenSet
from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList
from queryablecollections.collections.q_set import QSet
from queryablecollections.q_errors import EmptyIterableError
from queryablecollections.q_iterable import QIterable
from queryablecollections.q_ordered_iterable import QOrderedIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Func, Predicate, Selector

class QDecimalIterable(QIterable[Decimal], ABC):
    __slots__: tuple[str, ...] = ()

    def sum(self) -> Decimal: return sum(self, Decimal(0))

    def min(self) -> Decimal:
        try:
            return min(self)
        except ValueError:
            raise EmptyIterableError() from None

    def max(self) -> Decimal:
        try:
            return max(self)
        except ValueError:
            raise EmptyIterableError() from None

    def min_or_default(self) -> Decimal: return min(self) if self.any() else Decimal(0)
    def max_or_default(self) -> Decimal: return max(self) if self.any() else Decimal(0)
    def average(self) -> Decimal: return statistics.mean(self._assert_not_empty())
    def average_or_default(self) -> Decimal: return statistics.mean(self) if self.any() else Decimal(0)

    @override
    def _lazy(self, factory: Func[Iterable[Decimal]]) -> QDecimalIterable: return QDecimalIterableImplementation(factory)
    @override
    def _order_by(self, key_selector: Selector[Decimal, SupportsRichComparison], descending: bool) -> QOrderedIterable[Decimal]:
        return QDecimalOrderedIterable(lambda: self, [SortInstruction(key_selector, descending)])
    def _selfcast(self, iterable: QIterable[Decimal]) -> QDecimalIterable: return cast(QDecimalIterable, iterable)
    def _selfcast_ordered(self, iterable: QOrderedIterable[Decimal]) -> QDecimalOrderedIterable: return cast(QDecimalOrderedIterable, iterable)

    # region override methods so that typecheckers know that we actually return QDecimalIterables now, not QIterable[Decimal]
    # call the base method to eliminate code duplication. The base class will call lazy from just above, so it is already the correct type
    @override
    def where(self, predicate: Predicate[Decimal]) -> QDecimalIterable: return self._selfcast(super().where(predicate))
    @override
    def where_not_none(self) -> QDecimalIterable: return self._selfcast(super().where_not_none())
    @override
    def distinct(self) -> QDecimalIterable: return self._selfcast(super().distinct())
    @override
    def distinct_by[TKey](self, key_selector: Selector[Decimal, TKey]) -> QDecimalIterable: return self._selfcast(super().distinct_by(key_selector))
    @override
    def take(self, count: int) -> QDecimalIterable: return self._selfcast(super().take(count))
    @override
    def take_while(self, predicate: Predicate[Decimal]) -> QDecimalIterable: return self._selfcast(super().take_while(predicate))
    @override
    def take_last(self, count: int) -> QDecimalIterable: return self._selfcast(super().take_last(count))
    @override
    def skip(self, count: int) -> QDecimalIterable: return self._selfcast(super().skip(count))
    @override
    def skip_last(self, count: int) -> QDecimalIterable: return self._selfcast(super().skip_last(count))
    @override
    def reversed(self) -> QDecimalIterable: return self._selfcast(super().reversed())

    @override
    def concat(self, *others: Iterable[Decimal]) -> QDecimalIterable: return self._selfcast(super().concat(*others))

    @override
    def order_by(self, key_selector: Selector[Decimal, SupportsRichComparison]) -> QDecimalOrderedIterable: return self._selfcast_ordered(super().order_by(key_selector))
    @override
    def order_by_descending(self, key_selector: Selector[Decimal, SupportsRichComparison]) -> QDecimalOrderedIterable: return self._selfcast_ordered(super().order_by_descending(key_selector))
    # endregion

    @override
    def to_list(self) -> QDecimalList: return QDecimalList(self)

    @override
    def to_sequence(self) -> QDecimalSequence: return QDecimalSequence(self)

    @override
    def to_set(self) -> QDecimalSet: return QDecimalSet(self)

    @override
    def to_frozenset(self) -> QDecimalFrozenSet: return QDecimalFrozenSet(self)

class QDecimalIterableImplementation(QLazyIterableImplementation[Decimal], QDecimalIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[Decimal]]) -> None:
        super().__init__(factory)

class QDecimalOrderedIterable(QOrderedIterable[Decimal], QDecimalIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[Decimal]], sorting_instructions: list[SortInstruction[Decimal]]) -> None:
        super().__init__(factory, sorting_instructions)

class QDecimalList(QList[Decimal], QDecimalIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[Decimal] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QDecimalIterable: return QDecimalIterable.reversed(self)

class QDecimalSet(QSet[Decimal], QDecimalIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[Decimal] = ()) -> None:
        super().__init__(iterable)

class QDecimalFrozenSet(QFrozenSet[Decimal], QDecimalIterable):
    __slots__: tuple[str, ...] = ()
    def __new__(cls, iterable: Iterable[Decimal] = ()) -> QDecimalFrozenSet:
        return super().__new__(cls, iterable)  # pyright: ignore [reportReturnType]

class QDecimalSequence(QImmutableSequence[Decimal], QDecimalIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[Decimal] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QDecimalIterable: return QDecimalIterable.reversed(self)
</file>

<file path="src/queryablecollections/collections/numeric/q_float_types.py">
from __future__ import annotations

import statistics
from abc import ABC
from typing import TYPE_CHECKING, cast, override

from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
from queryablecollections._private_implementation_details.sort_instruction import SortInstruction
from queryablecollections.collections.q_frozen_set import QFrozenSet
from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList
from queryablecollections.collections.q_set import QSet
from queryablecollections.q_errors import EmptyIterableError
from queryablecollections.q_iterable import QIterable
from queryablecollections.q_ordered_iterable import QOrderedIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Func, Predicate, Selector

class QFloatIterable(QIterable[float], ABC):
    __slots__: tuple[str, ...] = ()

    def sum(self) -> float: return sum(self)

    def min(self) -> float:
        try:
            return min(self)
        except ValueError:
            raise EmptyIterableError() from None

    def max(self) -> float:
        try:
            return max(self)
        except ValueError:
            raise EmptyIterableError() from None

    def min_or_default(self) -> float: return min(self) if self.any() else 0.0
    def max_or_default(self) -> float: return max(self) if self.any() else 0.0
    def average(self) -> float: return statistics.mean(self._assert_not_empty())
    def average_or_default(self) -> float: return statistics.mean(self) if self.any() else 0.0

    @override
    def _lazy(self, factory: Func[Iterable[float]]) -> QFloatIterable: return QFloatIterableImplementation(factory)
    @override
    def _order_by(self, key_selector: Selector[float, SupportsRichComparison], descending: bool) -> QOrderedIterable[float]:
        return QFloatOrderedIterable(lambda: self, [SortInstruction(key_selector, descending)])
    def _selfcast(self, iterable: QIterable[float]) -> QFloatIterable: return cast(QFloatIterable, iterable)
    def _selfcast_ordered(self, iterable: QOrderedIterable[float]) -> QFloatOrderedIterable: return cast(QFloatOrderedIterable, iterable)

    # region override methods so that typecheckers know that we actually return QFloatIterables now, not QIterable[float]
    # call the base method to eliminate code duplication. The base class will call lazy from just above, so it is already the correct type
    @override
    def where(self, predicate: Predicate[float]) -> QFloatIterable: return self._selfcast(super().where(predicate))
    @override
    def where_not_none(self) -> QFloatIterable: return self._selfcast(super().where_not_none())
    @override
    def distinct(self) -> QFloatIterable: return self._selfcast(super().distinct())
    @override
    def distinct_by[TKey](self, key_selector: Selector[float, TKey]) -> QFloatIterable: return self._selfcast(super().distinct_by(key_selector))
    @override
    def take(self, count: int) -> QFloatIterable: return self._selfcast(super().take(count))
    @override
    def take_while(self, predicate: Predicate[float]) -> QFloatIterable: return self._selfcast(super().take_while(predicate))
    @override
    def take_last(self, count: int) -> QFloatIterable: return self._selfcast(super().take_last(count))
    @override
    def skip(self, count: int) -> QFloatIterable: return self._selfcast(super().skip(count))
    @override
    def skip_last(self, count: int) -> QFloatIterable: return self._selfcast(super().skip_last(count))
    @override
    def reversed(self) -> QFloatIterable: return self._selfcast(super().reversed())

    @override
    def concat(self, *others: Iterable[float]) -> QFloatIterable: return self._selfcast(super().concat(*others))

    @override
    def order_by(self, key_selector: Selector[float, SupportsRichComparison]) -> QFloatOrderedIterable: return self._selfcast_ordered(super().order_by(key_selector))
    @override
    def order_by_descending(self, key_selector: Selector[float, SupportsRichComparison]) -> QFloatOrderedIterable: return self._selfcast_ordered(super().order_by_descending(key_selector))
    # endregion

    @override
    def to_list(self) -> QFloatList: return QFloatList(self)

    @override
    def to_sequence(self) -> QFloatSequence: return QFloatSequence(self)

    @override
    def to_set(self) -> QFloatSet: return QFloatSet(self)

    @override
    def to_frozenset(self) -> QFloatFrozenSet: return QFloatFrozenSet(self)

class QFloatIterableImplementation(QLazyIterableImplementation[float], QFloatIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[float]]) -> None:
        super().__init__(factory)

class QFloatOrderedIterable(QOrderedIterable[float], QFloatIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[float]], sorting_instructions: list[SortInstruction[float]]) -> None:
        super().__init__(factory, sorting_instructions)

class QFloatList(QList[float], QFloatIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[float] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QFloatIterable: return QFloatIterable.reversed(self)

class QFloatSet(QSet[float], QFloatIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[float] = ()) -> None:
        super().__init__(iterable)

class QFloatFrozenSet(QFrozenSet[float], QFloatIterable):
    __slots__: tuple[str, ...] = ()
    def __new__(cls, iterable: Iterable[float] = ()) -> QFloatFrozenSet:
        return super().__new__(cls, iterable)  # pyright: ignore [reportReturnType]

class QFloatSequence(QImmutableSequence[float], QFloatIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[float] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QFloatIterable: return QFloatIterable.reversed(self)
</file>

<file path="src/queryablecollections/collections/numeric/q_fraction_types.py">
from __future__ import annotations

import statistics
from abc import ABC
from fractions import Fraction
from typing import TYPE_CHECKING, cast, override

from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
from queryablecollections._private_implementation_details.sort_instruction import SortInstruction
from queryablecollections.collections.q_frozen_set import QFrozenSet
from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList
from queryablecollections.collections.q_set import QSet
from queryablecollections.q_errors import EmptyIterableError
from queryablecollections.q_iterable import QIterable
from queryablecollections.q_ordered_iterable import QOrderedIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Func, Predicate, Selector

class QFractionIterable(QIterable[Fraction], ABC):
    __slots__: tuple[str, ...] = ()

    def sum(self) -> Fraction: return sum(self, Fraction(0))

    def min(self) -> Fraction:
        try:
            return min(self)
        except ValueError:
            raise EmptyIterableError() from None

    def max(self) -> Fraction:
        try:
            return max(self)
        except ValueError:
            raise EmptyIterableError() from None

    def min_or_default(self) -> Fraction: return min(self) if self.any() else Fraction(0)
    def max_or_default(self) -> Fraction: return max(self) if self.any() else Fraction(0)
    def average(self) -> Fraction: return statistics.mean(self._assert_not_empty())
    def average_or_default(self) -> Fraction: return statistics.mean(self) if self.any() else Fraction(0)

    @override
    def _lazy(self, factory: Func[Iterable[Fraction]]) -> QFractionIterable: return QFractionIterableImplementation(factory)
    @override
    def _order_by(self, key_selector: Selector[Fraction, SupportsRichComparison], descending: bool) -> QOrderedIterable[Fraction]:
        return QFractionOrderedIterable(lambda: self, [SortInstruction(key_selector, descending)])
    def _selfcast(self, iterable: QIterable[Fraction]) -> QFractionIterable: return cast(QFractionIterable, iterable)
    def _selfcast_ordered(self, iterable: QOrderedIterable[Fraction]) -> QFractionOrderedIterable: return cast(QFractionOrderedIterable, iterable)

    # region override methods so that typecheckers know that we actually return QFractionIterables now, not QIterable[Fraction]
    # call the base method to eliminate code duplication. The base class will call lazy from just above, so it is already the correct type
    @override
    def where(self, predicate: Predicate[Fraction]) -> QFractionIterable: return self._selfcast(super().where(predicate))
    @override
    def where_not_none(self) -> QFractionIterable: return self._selfcast(super().where_not_none())
    @override
    def distinct(self) -> QFractionIterable: return self._selfcast(super().distinct())
    @override
    def distinct_by[TKey](self, key_selector: Selector[Fraction, TKey]) -> QFractionIterable: return self._selfcast(super().distinct_by(key_selector))
    @override
    def take(self, count: int) -> QFractionIterable: return self._selfcast(super().take(count))
    @override
    def take_while(self, predicate: Predicate[Fraction]) -> QFractionIterable: return self._selfcast(super().take_while(predicate))
    @override
    def take_last(self, count: int) -> QFractionIterable: return self._selfcast(super().take_last(count))
    @override
    def skip(self, count: int) -> QFractionIterable: return self._selfcast(super().skip(count))
    @override
    def skip_last(self, count: int) -> QFractionIterable: return self._selfcast(super().skip_last(count))
    @override
    def reversed(self) -> QFractionIterable: return self._selfcast(super().reversed())

    @override
    def concat(self, *others: Iterable[Fraction]) -> QFractionIterable: return self._selfcast(super().concat(*others))

    @override
    def order_by(self, key_selector: Selector[Fraction, SupportsRichComparison]) -> QFractionOrderedIterable: return self._selfcast_ordered(super().order_by(key_selector))
    @override
    def order_by_descending(self, key_selector: Selector[Fraction, SupportsRichComparison]) -> QFractionOrderedIterable: return self._selfcast_ordered(super().order_by_descending(key_selector))
    # endregion

    @override
    def to_list(self) -> QFractionList: return QFractionList(self)

    @override
    def to_sequence(self) -> QFractionSequence: return QFractionSequence(self)

    @override
    def to_set(self) -> QFractionSet: return QFractionSet(self)

    @override
    def to_frozenset(self) -> QFractionFrozenSet: return QFractionFrozenSet(self)

class QFractionIterableImplementation(QLazyIterableImplementation[Fraction], QFractionIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[Fraction]]) -> None:
        super().__init__(factory)

class QFractionOrderedIterable(QOrderedIterable[Fraction], QFractionIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[Fraction]], sorting_instructions: list[SortInstruction[Fraction]]) -> None:
        super().__init__(factory, sorting_instructions)

class QFractionList(QList[Fraction], QFractionIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[Fraction] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QFractionIterable: return QFractionIterable.reversed(self)

class QFractionSet(QSet[Fraction], QFractionIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[Fraction] = ()) -> None:
        super().__init__(iterable)

class QFractionFrozenSet(QFrozenSet[Fraction], QFractionIterable):
    __slots__: tuple[str, ...] = ()
    def __new__(cls, iterable: Iterable[Fraction] = ()) -> QFractionFrozenSet:
        return super().__new__(cls, iterable)  # pyright: ignore [reportReturnType]

class QFractionSequence(QImmutableSequence[Fraction], QFractionIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[Fraction] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QFractionIterable: return QFractionIterable.reversed(self)
</file>

<file path="src/queryablecollections/collections/numeric/q_int_types.py">
from __future__ import annotations

import statistics
from abc import ABC
from typing import TYPE_CHECKING, cast, override

from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
from queryablecollections._private_implementation_details.sort_instruction import SortInstruction
from queryablecollections.collections.q_frozen_set import QFrozenSet
from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList
from queryablecollections.collections.q_set import QSet
from queryablecollections.q_errors import EmptyIterableError
from queryablecollections.q_iterable import QIterable
from queryablecollections.q_ordered_iterable import QOrderedIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Func, Predicate, Selector

class QIntIterable(QIterable[int], ABC):
    __slots__: tuple[str, ...] = ()

    def sum(self) -> int: return sum(self)

    def min(self) -> int:
        try:
            return min(self)
        except ValueError:
            raise EmptyIterableError() from None

    def max(self) -> int:
        try:
            return max(self)
        except ValueError:
            raise EmptyIterableError() from None

    def min_or_default(self) -> int: return min(self) if self.any() else 0
    def max_or_default(self) -> int: return max(self) if self.any() else 0
    def average(self) -> float: return statistics.mean(self._assert_not_empty())
    def average_or_default(self) -> float: return statistics.mean(self) if self.any() else 0.0

    @override
    def _lazy(self, factory: Func[Iterable[int]]) -> QIntIterable: return QIntIterableImplementation(factory)
    @override
    def _order_by(self, key_selector: Selector[int, SupportsRichComparison], descending: bool) -> QOrderedIterable[int]:
        return QIntOrderedIterable(lambda: self, [SortInstruction(key_selector, descending)])
    def _selfcast(self, iterable: QIterable[int]) -> QIntIterable: return cast(QIntIterable, iterable)
    def _selfcast_ordered(self, iterable: QOrderedIterable[int]) -> QIntOrderedIterable: return cast(QIntOrderedIterable, iterable)

    # region override methods so that typecheckers know that we actually return QIntIterables now, not QIterable[int]
    # call the base method to eliminate code duplication. The base class will call lazy from just above, so it is already the correct type
    @override
    def where(self, predicate: Predicate[int]) -> QIntIterable: return self._selfcast(super().where(predicate))
    @override
    def where_not_none(self) -> QIntIterable: return self._selfcast(super().where_not_none())
    @override
    def distinct(self) -> QIntIterable: return self._selfcast(super().distinct())
    @override
    def distinct_by[TKey](self, key_selector: Selector[int, TKey]) -> QIntIterable: return self._selfcast(super().distinct_by(key_selector))
    @override
    def take(self, count: int) -> QIntIterable: return self._selfcast(super().take(count))
    @override
    def take_while(self, predicate: Predicate[int]) -> QIntIterable: return self._selfcast(super().take_while(predicate))
    @override
    def take_last(self, count: int) -> QIntIterable: return self._selfcast(super().take_last(count))
    @override
    def skip(self, count: int) -> QIntIterable: return self._selfcast(super().skip(count))
    @override
    def skip_last(self, count: int) -> QIntIterable: return self._selfcast(super().skip_last(count))
    @override
    def reversed(self) -> QIntIterable: return self._selfcast(super().reversed())

    @override
    def concat(self, *others: Iterable[int]) -> QIntIterable: return self._selfcast(super().concat(*others))

    @override
    def order_by(self, key_selector: Selector[int, SupportsRichComparison]) -> QIntOrderedIterable: return self._selfcast_ordered(super().order_by(key_selector))
    @override
    def order_by_descending(self, key_selector: Selector[int, SupportsRichComparison]) -> QIntOrderedIterable: return self._selfcast_ordered(super().order_by_descending(key_selector))
    # endregion

    @override
    def to_list(self) -> QIntList: return QIntList(self)

    @override
    def to_sequence(self) -> QIntSequence: return QIntSequence(self)

    @override
    def to_set(self) -> QIntSet: return QIntSet(self)

    @override
    def to_frozenset(self) -> QIntFrozenSet: return QIntFrozenSet(self)

class QIntIterableImplementation(QLazyIterableImplementation[int], QIntIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[int]]) -> None:
        super().__init__(factory)

class QIntOrderedIterable(QOrderedIterable[int], QIntIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[int]], sorting_instructions: list[SortInstruction[int]]) -> None:
        super().__init__(factory, sorting_instructions)

class QIntList(QList[int], QIntIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[int] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QIntIterable: return QIntIterable.reversed(self)

class QIntSet(QSet[int], QIntIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[int] = ()) -> None:
        super().__init__(iterable)

class QIntFrozenSet(QFrozenSet[int], QIntIterable):
    __slots__: tuple[str, ...] = ()
    def __new__(cls, iterable: Iterable[int] = ()) -> QIntFrozenSet:
        return super().__new__(cls, iterable)  # pyright: ignore [reportReturnType]

class QIntSequence(QImmutableSequence[int], QIntIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[int] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QIntIterable: return QIntIterable.reversed(self)
</file>

<file path="src/queryablecollections/collections/q_default_dict.py">
from __future__ import annotations

from collections import defaultdict
from typing import TYPE_CHECKING, override

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C
from queryablecollections.collections.q_key_value_pair import KeyValuePair
from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from queryablecollections._private_implementation_details.type_aliases import Func


class QDefaultDict[TKey, TItem](defaultdict[TKey, TItem], QIterable[TKey]):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[TItem]) -> None:
        super().__init__(factory)

    def qitems(self) -> QIterable[KeyValuePair[TKey, TItem]]: return C.lazy_iterable(lambda: self.items()).select(KeyValuePair)

    @override
    def _optimized_length(self) -> int: return len(self)
</file>

<file path="src/queryablecollections/collections/q_dict.py">
from __future__ import annotations

from typing import TYPE_CHECKING, override

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C
from queryablecollections.collections.q_key_value_pair import KeyValuePair
from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

class QDict[TKey, TItem](dict[TKey, TItem], QIterable[TKey]):
    __slots__: tuple[str, ...] = ()
    def __init__(self, elements: Iterable[tuple[TKey, TItem]] = ()) -> None:
        super().__init__(elements)

    def qitems(self) -> QIterable[KeyValuePair[TKey, TItem]]: return C.lazy_iterable(lambda: self.items()).select(KeyValuePair)

    @override
    def _optimized_length(self) -> int: return len(self)
</file>

<file path="src/queryablecollections/collections/q_frozen_set.py">
from __future__ import annotations

from typing import TYPE_CHECKING, Never, override

from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

class QFrozenSet[TItem](frozenset[TItem], QIterable[TItem]):
    __slots__: tuple[str, ...] = ()
    def __new__(cls, iterable: Iterable[TItem] = ()) -> QFrozenSet[TItem]:
        return super().__new__(cls, iterable)

    @override
    def _optimized_length(self) -> int: return len(self)

    _empty_set: QFrozenSet[Never]

    @staticmethod
    @override
    def empty() -> QFrozenSet[Never]:
        return QFrozenSet._empty_set

QFrozenSet._empty_set = QFrozenSet()  # pyright: ignore [reportGeneralTypeIssues, reportPrivateUsage]
</file>

<file path="src/queryablecollections/collections/q_immutable_sequence.py">
from __future__ import annotations

from typing import TYPE_CHECKING, overload, override

from queryablecollections._private_implementation_details.immutable_sequence import ImmutableSequence
from queryablecollections.collections.q_sequence import QSequence

if TYPE_CHECKING:
    from collections.abc import Iterable


class QImmutableSequence[TItem](ImmutableSequence[TItem], QSequence[TItem]):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[TItem] = ()) -> None:
        super().__init__(list(iterable))

    @overload
    def __getitem__(self, index: int) -> TItem: ...
    @overload
    def __getitem__(self, index: slice) -> QImmutableSequence[TItem]: ...
    @override
    def __getitem__(self, index: int | slice) -> TItem | QImmutableSequence[TItem]:
        if isinstance(index, slice):
            return QImmutableSequence(super().__getitem__(index))
        return super().__getitem__(index)
</file>

<file path="src/queryablecollections/collections/q_key_value_pair.py">
from __future__ import annotations

from typing import TypeVar

TValue = TypeVar("TValue", covariant=True)
TKey = TypeVar("TKey")


class KeyValuePair(tuple[TKey, TValue]):
    __slots__: tuple[str, ...] = ()
    def __new__(cls, value: tuple[TKey, TValue]):
        return super().__new__(cls, value)

    @property
    def key(self) -> TKey: return self[0]
    @property
    def value(self) -> TValue: return self[1]
</file>

<file path="src/queryablecollections/collections/q_list.py">
from __future__ import annotations

import sys
from typing import TYPE_CHECKING, SupportsIndex, overload, override

from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
from queryablecollections.collections.q_sequence import QSequence
from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

class QList[TItem](list[TItem], QSequence[TItem], QIterable[TItem]):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[TItem] = ()) -> None:
        super().__init__(iterable)

    @override
    def _optimized_length(self) -> int: return len(self)

    @override
    def reversed(self) -> QIterable[TItem]: return QLazyIterableImplementation[TItem](lambda: reversed(self))

    @override
    def element_at(self, index: int) -> TItem: return self[index]

    @override
    def index(self, value: TItem, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize) -> int:
        return super().index(value, start, stop)

    @override
    def count(self, value: TItem): return super().count(value)

    @overload
    def __getitem__(self, index: SupportsIndex) -> TItem: ...

    @overload
    def __getitem__(self, index: slice) -> QList[TItem]: ...

    @override
    def __getitem__(self, index: SupportsIndex | slice) -> TItem | QList[TItem]:
        if isinstance(index, slice):
            return QList(super().__getitem__(index))
        return super().__getitem__(index)
</file>

<file path="src/queryablecollections/collections/q_sequence.py">
from __future__ import annotations

from abc import ABC
from collections.abc import Sequence
from typing import Never, override

from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
from queryablecollections.q_iterable import QIterable


class QSequence[TItem](Sequence[TItem], QIterable[TItem], ABC):
    __slots__: tuple[str, ...] = ()
    @override
    def _optimized_length(self) -> int: return len(self)

    @override
    def reversed(self) -> QIterable[TItem]: return QLazyIterableImplementation[TItem](lambda: reversed(self))

    @staticmethod
    @override
    def empty() -> QSequence[Never]:
        from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
        empty = QImmutableSequence[Never]()
        def get_empty() -> QSequence[Never]: return empty  # pyright: ignore [reportReturnType]
        QSequence.empty = get_empty
        return QSequence[TItem].empty()
</file>

<file path="src/queryablecollections/collections/q_set.py">
from __future__ import annotations

from typing import TYPE_CHECKING, override

from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from collections.abc import Iterable


class QSet[TItem](set[TItem], QIterable[TItem]):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[TItem] = ()) -> None:
        super().__init__(iterable)

    @override
    def _optimized_length(self) -> int: return len(self)

    @override
    def contains(self, value: TItem) -> bool: return value in self
</file>

<file path="src/queryablecollections/q_cast.py">
from __future__ import annotations

from collections.abc import Iterable
from decimal import Decimal
from fractions import Fraction
from typing import TYPE_CHECKING, cast

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C
from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from queryablecollections.collections.numeric.q_decimal_types import QDecimalIterable
    from queryablecollections.collections.numeric.q_float_types import QFloatIterable
    from queryablecollections.collections.numeric.q_fraction_types import QFractionIterable
    from queryablecollections.collections.numeric.q_int_types import QIntIterable

class CheckedCast[TValue]:
    __slots__: tuple[str, ...] = ("_type",)
    def __init__(self, type: type[TValue]) -> None:
        self._type: type[TValue] = type

    def __call__(self, value: object) -> TValue:
        if not isinstance(value, self._type): raise TypeError(f"Expected {self._type.__name__}, got {type(value).__name__}")
        return value

_checked_cast_int = CheckedCast(int)
_checked_cast_float = CheckedCast(float)
_checked_cast_fraction = CheckedCast(Fraction)
_checked_cast_decimal = CheckedCast(Decimal)

class QCast[TItem]:
    __slots__: tuple[str, ...] = ("_iterable",)
    def __init__(self, iterable: QIterable[TItem]) -> None:
        self._iterable: QIterable[TItem] = iterable

    @property
    def checked(self) -> QCheckedCast[TItem]:
        return QCheckedCast(self._iterable)

    def int(self) -> QIntIterable:
        return C.int_iterable(lambda: (cast(Iterable[int], self._iterable)))

    def float(self) -> QFloatIterable:
        return C.float_iterable(lambda: (cast(Iterable[float], self._iterable)))

    def fraction(self) -> QFractionIterable:
        return C.fraction_iterable(lambda: (cast(Iterable[Fraction], self._iterable)))

    def decimal(self) -> QDecimalIterable:
        return C.decimal_iterable(lambda: cast(Iterable[Decimal], self._iterable))

    def to[TNew](self, _type: type[TNew]) -> QIterable[TNew]:  # pyright: ignore
        return cast(QIterable[TNew], self._iterable)

class QCheckedCast[TItem]:
    __slots__: tuple[str, ...] = ("_iterable",)
    def __init__(self, iterable: QIterable[TItem]) -> None:
        self._iterable: QIterable[TItem] = iterable

    def int(self) -> QIntIterable:
        return C.int_iterable(lambda: self._iterable.select(_checked_cast_int))

    def float(self) -> QFloatIterable:
        return C.float_iterable(lambda: self._iterable.select(_checked_cast_float))

    def fraction(self) -> QFractionIterable:
        return C.fraction_iterable(lambda: self._iterable.select(_checked_cast_fraction))

    def decimal(self) -> QDecimalIterable:
        return C.decimal_iterable(lambda: self._iterable.select(_checked_cast_decimal))

    def to[TNew](self, _type: type[TNew]) -> QIterable[TNew]:  # pyright: ignore
        return self._iterable.select(CheckedCast(_type))
</file>

<file path="src/queryablecollections/q_errors.py">
from __future__ import annotations


class InvalidOperationError(Exception):
    """Raised when a method call is invalid for the object's current state."""
    def __init__(self, message: str = "The called method cannot be called with the object in the current state") -> None:
        super().__init__(message)

class EmptyIterableError(InvalidOperationError):
    """Raised when an operation is attempted on an empty Iterable."""
    def __init__(self) -> None:
        super().__init__("The operation cannot be performed on an empty Iterable.")

class ArgumentError(ValueError):
    """Raised when an argument is invalid."""
    def __init__(self, message: str = "The argument is invalid.") -> None:
        super().__init__(message)

class ArgumentNoneError(ArgumentError):
    """Raised when an argument is None."""
    def __init__(self, argument_name: str) -> None:
        super().__init__(f"{argument_name} cannot be None.")
</file>

<file path="src/queryablecollections/q_grouping.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList


class QGrouping[TKey, TElement](QList[TElement]):
    """Represents a collection of objects that have a common key."""
    __slots__: tuple[str, ...] = ("key",)

    def __init__(self, values: tuple[TKey, QList[TElement]]) -> None:
        super().__init__(values[1])
        self.key: TKey = values[0]
</file>

<file path="src/queryablecollections/q_iterable.py">
from __future__ import annotations

from abc import ABC
from collections.abc import Callable, Iterable
from typing import TYPE_CHECKING, Never, Self, overload

from queryablecollections._private_implementation_details import ops

# noinspection PyPep8Naming
from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C
from queryablecollections._private_implementation_details.sort_instruction import SortInstruction
from queryablecollections.q_errors import EmptyIterableError

if TYPE_CHECKING:
    from decimal import Decimal
    from fractions import Fraction

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Action1, Func, Predicate, Selector
    from queryablecollections.collections.numeric.q_decimal_types import QDecimalIterable
    from queryablecollections.collections.numeric.q_float_types import QFloatIterable
    from queryablecollections.collections.numeric.q_fraction_types import QFractionIterable
    from queryablecollections.collections.numeric.q_int_types import QIntIterable
    from queryablecollections.collections.q_dict import QDict
    from queryablecollections.collections.q_frozen_set import QFrozenSet
    from queryablecollections.collections.q_key_value_pair import KeyValuePair
    from queryablecollections.collections.q_list import QList
    from queryablecollections.collections.q_sequence import QSequence
    from queryablecollections.collections.q_set import QSet
    from queryablecollections.q_cast import QCast
    from queryablecollections.q_grouping import QGrouping
    from queryablecollections.q_ordered_iterable import QOrderedIterable

def query[TItem](value: Iterable[TItem]) -> QIterable[TItem]: return C.caching_iterable(value)

# note to coders, you can trust that the methods on single lines do nothing except delegate to the corresponding operations method,
# or to ZeroImportOverheadConstructors, knowing that, keeping them on single lines make it easier to read through the definitions
class QIterable[T](Iterable[T], ABC):
    __slots__: tuple[str, ...] = ()
    @property
    def cast(self) -> QCast[T]: return C.cast(self)

    def _lazy(self, factory: Func[Iterable[T]]) -> QIterable[T]:
        return C.lazy_iterable(factory)

    # region  static factory methods
    @staticmethod
    def empty() -> QIterable[Never]: return C.empty_iterable()

    @staticmethod
    @overload
    def range(stop_before: int, /) -> QIntIterable:
        """Returns a QIntIterable with values from 0 to stop_before - 1"""

    @staticmethod
    @overload
    def range(start: int, stop_before: int, step: int = 1, /) -> QIntIterable:
        """Returns a QIntIterable with values from start to stop_before - 1 in steps of step"""

    @staticmethod
    def range(start_or_stop_before: int, stop_before: int | None = None, step: int = 1, /) -> QIntIterable: return C.int_iterable(lambda: ops.range(start_or_stop_before, stop_before, step))

    @staticmethod
    def repeat[TElement](element: TElement, count: int) -> QIterable[TElement]:
        """Returns a QIterable with the given element repeated count times"""
        return C.lazy_iterable(lambda: ops.repeat(element, count))

    # endregion

    # region operations on the whole collection, not the items
    def qappend(self, item: T) -> QIterable[T]: return self._lazy(lambda: ops.append(self, item))
    def prepend(self, item: T) -> QIterable[T]: return self._lazy(lambda: ops.prepend(self, item))
    def concat(self, *others: Iterable[T]) -> QIterable[T]: return self._lazy(lambda: ops.concat(self, *others))
    # endregion

    # region functional programming helpers
    def pipe[TReturn](self, action: Selector[QIterable[T], TReturn]) -> TReturn: return ops.pipe(self, action)
    def for_each(self, action: Action1[T]) -> Self:
        for item in self: action(item)
        return self
    # endregion

    def as_iterable(self) -> QIterable[T]: return self

    # region typed convertions to access type specific functionality type checkers will only allow calls if the instance is the correct type

    def as_ints(self: QIterable[int]) -> QIntIterable: return ops.as_ints(self)
    def as_floats(self: QIterable[float]) -> QFloatIterable: return ops.as_floats(self)
    def as_fractions(self: QIterable[Fraction]) -> QFractionIterable: return ops.as_fractions(self)
    def as_decimals(self: QIterable[Decimal]) -> QDecimalIterable: return ops.as_decimals(self)

    # endregion

    # region set operations
    def qexcept(self, other: Iterable[T]) -> QIterable[T]: return self._lazy(lambda: ops.qexcept(self, other))
    def qexcept_by[TKey](self, keys: Iterable[TKey], key_selector: Selector[T, TKey]) -> QIterable[T]:
        """Alias for where_key_not_in, for consistency with other set operations and for those used to the .Net API. Consider using the more descriptive where_key_not_in instead."""
        return self.where_key_not_in(keys, key_selector)
    def where_key_not_in[TKey](self, keys: Iterable[TKey], key_selector: Selector[T, TKey]) -> QIterable[T]: return self._lazy(lambda: ops.where_key_not_in(self, keys, key_selector))
    def qunion(self, other: Iterable[T]) -> QIterable[T]: return self._lazy(lambda: ops.qunion(self, other))
    def qunion_by[TKey](self, other: Iterable[T], key_selector: Selector[T, TKey]) -> QIterable[T]: return self._lazy(lambda: ops.qunion_by(self, other, key_selector))
    def qintersect(self, other: Iterable[T]) -> QIterable[T]: return self._lazy(lambda: ops.qintersect(self, other))
    def qintersect_by[TKey](self, keys: Iterable[TKey], key_selector: Selector[T, TKey]) -> QIterable[T]:
        """Alias for where_key_in, for consistency with other set operations and for those used to the .Net API. Consider using the more descriptive where_key_in instead."""
        return self.where_key_in(keys, key_selector)
    def where_key_in[TKey](self, keys: Iterable[TKey], key_selector: Selector[T, TKey]) -> QIterable[T]: return self._lazy(lambda: ops.where_key_in(self, keys, key_selector))

    def contains(self, value: T) -> bool: return ops.contains(self, value)

    # endregion

    # region filtering
    def where(self, predicate: Predicate[T]) -> QIterable[T]: return self._lazy(lambda: ops.where(self, predicate))
    def where_not_none(self) -> QIterable[T]: return self._lazy(lambda: ops.where_not_none(self))

    def distinct(self) -> QIterable[T]: return self._lazy(lambda: ops.distinct(self))
    def distinct_by[TKey](self, key_selector: Selector[T, TKey]) -> QIterable[T]: return self._lazy(lambda: ops.distinct_by(self, key_selector))

    def take(self, count: int) -> QIterable[T]: return self._lazy(lambda: ops.take(self, count))
    def take_while(self, predicate: Predicate[T]) -> QIterable[T]: return self._lazy(lambda: ops.take_while(self, predicate))
    def take_last(self, count: int) -> QIterable[T]: return self._lazy(lambda: ops.take_last(self, count))
    def skip(self, count: int) -> QIterable[T]: return self._lazy(lambda: ops.skip(self, count))
    def skip_while(self, predicate: Predicate[T]) -> QIterable[T]: return self._lazy(lambda: ops.skip_while(self, predicate))
    def skip_last(self, count: int) -> QIterable[T]: return self._lazy(lambda: ops.skip_last(self, count))

    def of_type[TResult](self, target_type: type[TResult]) -> QIterable[TResult]: return C.lazy_iterable(lambda: ops.of_type(self, target_type))

    # endregion

    # region value queries
    def qcount_by[TKey](self, key_selector: Selector[T, TKey]) -> QIterable[KeyValuePair[TKey, int]]: return ops.qcount_by(self, key_selector)
    def qcount(self, predicate: Predicate[T] | None = None) -> int: return ops.qcount(self, predicate)
    def none(self, predicate: Predicate[T] | None = None) -> bool: return not ops.any(self, predicate)
    def any(self, predicate: Predicate[T] | None = None) -> bool: return ops.any(self, predicate)
    def all(self, predicate: Predicate[T]) -> bool: return ops.all(self, predicate)

    def sequence_equal(self, other: Iterable[T]) -> bool: return ops.sequence_equal(self, other)

    # endregion

    # region aggregation methods
    @overload
    def aggregate(self, func: Callable[[T, T], T]) -> T: ...

    @overload
    def aggregate[TAccumulate](self, func: Callable[[TAccumulate, T], TAccumulate], seed: TAccumulate) -> TAccumulate: ...

    @overload
    def aggregate[TAccumulate, TResult](self, func: Callable[[TAccumulate, T], TAccumulate], seed: TAccumulate, select: Selector[TAccumulate, TResult]) -> TResult: ...

    def aggregate[TAccumulate, TResult](self, func: Callable[[T, T], T] | Callable[[TAccumulate, T], TAccumulate],
                                        seed: TAccumulate | None = None,
                                        select: Selector[TAccumulate, TResult] | None = None) -> T | TAccumulate | TResult:
        return ops.aggregate(self, func, seed, select)

    # endregion

    # region sorting
    def _order_by(self, key_selector: Selector[T, SupportsRichComparison], descending: bool) -> QOrderedIterable[T]:
        return C.ordered_iterable(lambda: self, [SortInstruction(key_selector, descending)])

    def order_by(self, key_selector: Selector[T, SupportsRichComparison]) -> QOrderedIterable[T]:
        return self._order_by(key_selector, False)
    def order_by_descending(self, key_selector: Selector[T, SupportsRichComparison]) -> QOrderedIterable[T]:
        return self._order_by(key_selector, True)

    def reversed(self) -> QIterable[T]: return self._lazy(lambda: ops.reversed(self))

    # endregion

    # region mapping/transformation methods
    def select[TReturn](self, selector: Selector[T, TReturn]) -> QIterable[TReturn]: return C.lazy_iterable(lambda: ops.select(self, selector))
    def select_index[TReturn](self, selector: Callable[[T, int], TReturn]) -> QIterable[TReturn]: return C.lazy_iterable(lambda: ops.select_index(self, selector))
    def select_many[TInner](self, selector: Selector[T, Iterable[TInner]]) -> QIterable[TInner]: return C.lazy_iterable(lambda: ops.select_many(self, selector))
    def join[TInner, TKey, TResult](self, other: Iterable[TInner], self_key: Selector[T, TKey], other_key: Selector[TInner, TKey], select: Callable[[T, TInner], TResult]) -> QIterable[TResult]: return C.lazy_iterable(lambda: ops.join(self, other, self_key, other_key, select))
    def group_join[TInner, TKey, TResult](self, other: Iterable[TInner], self_key: Selector[T, TKey], group_key: Selector[TInner, TKey], select: Callable[[T, Iterable[TInner]], TResult]) -> QIterable[TResult]: return C.lazy_iterable(lambda: ops.group_join(self, other, self_key, group_key, select))

    def qindex(self) -> QIterable[tuple[int, T]]: return C.lazy_iterable(lambda: ops.qindex(self))

    def zip[T2, TResult](self, second: Iterable[T2], select: Callable[[T, T2], TResult]) -> QIterable[TResult]: return C.lazy_iterable(lambda: ops.zip(self, second, select))
    def zip2[T2, T3, TResult](self, second: Iterable[T2], third: Iterable[T3], select: Callable[[T, T2, T3], TResult]) -> QIterable[TResult]: return C.lazy_iterable(lambda: ops.zip2(self, second, third, select))
    def zip3[T2, T3, T4, TResult](self, second: Iterable[T2], third: Iterable[T3], fourth: Iterable[T4], select: Callable[[T, T2, T3, T4], TResult]) -> QIterable[TResult]: return C.lazy_iterable(lambda: ops.zip3(self, second, third, fourth, select))

    def zip_tuple[T2](self, second: Iterable[T2]) -> QIterable[tuple[T, T2]]: return C.lazy_iterable(lambda: ops.zip_tuple(self, second))
    def zip_tuple2[T2, T3](self, second: Iterable[T2], third: Iterable[T3]) -> QIterable[tuple[T, T2, T3]]: return C.lazy_iterable(lambda: ops.zip_tuple2(self, second, third))
    def zip_tuple3[T2, T3, T4](self, second: Iterable[T2], third: Iterable[T3], fourth: Iterable[T4]) -> QIterable[tuple[T, T2, T3, T4]]: return C.lazy_iterable(lambda: ops.zip_tuple3(self, second, third, fourth))

    def to_dict[TKey, TValue](self, key_selector: Selector[T, TKey], value_selector: Selector[T, TValue]) -> QDict[TKey, TValue]: return ops.to_dict(self, key_selector, value_selector)

    def chunk(self, size: int) -> QIterable[QList[T]]: return C.lazy_iterable(lambda: ops.chunk(self, size))

    @overload
    def group_by[TKey](self, key: Selector[T, TKey]) -> QIterable[QGrouping[TKey, T]]:
        """Groups the elements of a sequence according to the specified key selector"""

    @overload
    def group_by[TKey, TElement](self, key: Selector[T, TKey], select: Selector[T, TElement]) -> QIterable[QGrouping[TKey, TElement]]:
        """Groups the elements of a sequence according to the specified key selector and element selector"""

    def group_by[TKey, TElement](self, key: Selector[T, TKey], select: Selector[T, TElement] | None = None) -> QIterable[QGrouping[TKey, T]] | QIterable[QGrouping[TKey, TElement]]: return ops.group_by_q(self, key, select)
    # endregion

    # region single item selecting methods
    def first(self, predicate: Predicate[T] | None = None) -> T: return ops.first(self, predicate)
    def first_or_none(self, predicate: Predicate[T] | None = None) -> T | None: return ops.first_or_none(self, predicate)
    def single(self, predicate: Predicate[T] | None = None) -> T: return ops.single(self, predicate)
    def single_or_none(self, predicate: Predicate[T] | None = None) -> T | None: return ops.single_or_none(self, predicate)
    def last(self, predicate: Predicate[T] | None = None) -> T: return ops.last(self, predicate)
    def last_or_none(self, predicate: Predicate[T] | None = None) -> T | None: return ops.last_or_none(self, predicate)

    def element_at(self, index: int) -> T: return ops.element_at(self, index)
    def element_at_or_none(self, index: int) -> T | None: return ops.element_at_or_none(self, index)

    def min_by[TKey: SupportsRichComparison](self, key_selector: Selector[T, TKey]) -> T:return ops.min_by(self, key_selector)
    def max_by[TKey: SupportsRichComparison](self, key_selector: Selector[T, TKey]) -> T: return ops.max_by(self, key_selector)

    # endregion

    # region methods subclasses may want to override for perfarmonce reasons

    def _optimized_length(self) -> int: return sum(1 for _ in self)
    def _assert_not_empty(self) -> Self:
        if not self.any(): raise EmptyIterableError()
        return self

    # region factory methods
    # note: we do not "optimize" by returning self in any subclass because the contract is to create a new independent copy
    def to_list(self) -> QList[T]: return C.list(self)
    def to_set(self) -> QSet[T]: return C.set(self)
    def to_frozenset(self) -> QFrozenSet[T]: return C.frozen_set(self)
    def to_sequence(self) -> QSequence[T]: return C.sequence(self)
    def to_built_in_list(self) -> list[T]: return list(self)

    # endregion
</file>

<file path="src/queryablecollections/q_ordered_iterable.py">
from __future__ import annotations

from typing import TYPE_CHECKING, override

import queryablecollections._private_implementation_details.ops as ops
from queryablecollections._private_implementation_details.sort_instruction import SortInstruction
from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from collections.abc import Iterable, Iterator

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Func, Selector


class QOrderedIterable[TItem](QIterable[TItem]):
    __slots__: tuple[str, ...] = ("sorting_instructions", "_factory")
    def __init__(self, factory: Func[Iterable[TItem]], sorting_instructions: list[SortInstruction[TItem]]) -> None:
        self.sorting_instructions: list[SortInstruction[TItem]] = sorting_instructions
        self._factory: Func[Iterable[TItem]] = factory

    def then_by(self, key_selector: Selector[TItem, SupportsRichComparison]) -> QOrderedIterable[TItem]:
        return QOrderedIterable(self._factory, self.sorting_instructions + [SortInstruction(key_selector, descending=False)])

    def then_by_descending(self, key_selector: Selector[TItem, SupportsRichComparison]) -> QOrderedIterable[TItem]:
        return QOrderedIterable(self._factory, self.sorting_instructions + [SortInstruction(key_selector, descending=True)])

    @override
    def __iter__(self) -> Iterator[TItem]: yield from ops.sort_by_instructions(self._factory(), self.sorting_instructions)
</file>

</files>

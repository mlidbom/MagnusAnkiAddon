This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*py, **/*.pyi
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
queryablecollections_tests/common_helpers.py
queryablecollections_tests/numeric/test_q_decimal_iterable.py
queryablecollections_tests/numeric/test_q_float_iterable.py
queryablecollections_tests/numeric/test_q_fraction_iterable.py
queryablecollections_tests/numeric/test_q_int_iterable.py
queryablecollections_tests/q_iterable/test_all.py
queryablecollections_tests/q_iterable/test_any.py
queryablecollections_tests/q_iterable/test_as_.py
queryablecollections_tests/q_iterable/test_cast_checked_to.py
queryablecollections_tests/q_iterable/test_cast_to.py
queryablecollections_tests/q_iterable/test_concat.py
queryablecollections_tests/q_iterable/test_distinct.py
queryablecollections_tests/q_iterable/test_element_at_or_none.py
queryablecollections_tests/q_iterable/test_element_at.py
queryablecollections_tests/q_iterable/test_empty.py
queryablecollections_tests/q_iterable/test_first.py
queryablecollections_tests/q_iterable/test_for_each.py
queryablecollections_tests/q_iterable/test_group_by.py
queryablecollections_tests/q_iterable/test_indexer.py
queryablecollections_tests/q_iterable/test_join.py
queryablecollections_tests/q_iterable/test_none.py
queryablecollections_tests/q_iterable/test_not_none.py
queryablecollections_tests/q_iterable/test_of_type.py
queryablecollections_tests/q_iterable/test_order_by.py
queryablecollections_tests/q_iterable/test_qcount.py
queryablecollections_tests/q_iterable/test_reverse.py
queryablecollections_tests/q_iterable/test_select_.py
queryablecollections_tests/q_iterable/test_select_many.py
queryablecollections_tests/q_iterable/test_single_or_none.py
queryablecollections_tests/q_iterable/test_single.py
queryablecollections_tests/q_iterable/test_skip_last.py
queryablecollections_tests/q_iterable/test_skip.py
queryablecollections_tests/q_iterable/test_take_last.py
queryablecollections_tests/q_iterable/test_take_while.py
queryablecollections_tests/q_iterable/test_take.py
queryablecollections_tests/q_iterable/test_to_.py
queryablecollections_tests/q_iterable/test_to_dict.py
queryablecollections_tests/q_iterable/test_where.py
queryablecollections_tests/q_iterable/test_zip.py
queryablecollections_tests/q_iterable/test_zip2.py
queryablecollections_tests/q_iterable/test_zip3.py
queryablecollections_tests/q_list/test_indexer.py
queryablecollections_tests/q_list/test_slicing.py
queryablecollections_tests/test_lazyness_and_consuming_behavior.py
src/queryablecollections/_private_implementation_details/immutable_sequence.py
src/queryablecollections/_private_implementation_details/operations/__init__.py
src/queryablecollections/_private_implementation_details/operations/filtering.py
src/queryablecollections/_private_implementation_details/operations/functional.py
src/queryablecollections/_private_implementation_details/operations/grouping.py
src/queryablecollections/_private_implementation_details/operations/ordering.py
src/queryablecollections/_private_implementation_details/operations/scalars.py
src/queryablecollections/_private_implementation_details/operations/single_elements.py
src/queryablecollections/_private_implementation_details/operations/transforms.py
src/queryablecollections/_private_implementation_details/operations/zip.py
src/queryablecollections/_private_implementation_details/q_lazy_iterable.py
src/queryablecollections/_private_implementation_details/q_zero_overhead_collection_contructors.py
src/queryablecollections/_private_implementation_details/type_aliases.py
src/queryablecollections/collections/numeric/q_decimal_types.py
src/queryablecollections/collections/numeric/q_float_types.py
src/queryablecollections/collections/numeric/q_fraction_types.py
src/queryablecollections/collections/numeric/q_int_types.py
src/queryablecollections/collections/q_default_dict.py
src/queryablecollections/collections/q_dict.py
src/queryablecollections/collections/q_frozen_set.py
src/queryablecollections/collections/q_immutable_sequence.py
src/queryablecollections/collections/q_key_value_pair.py
src/queryablecollections/collections/q_list.py
src/queryablecollections/collections/q_sequence.py
src/queryablecollections/collections/q_set.py
src/queryablecollections/q_cast.py
src/queryablecollections/q_errors.py
src/queryablecollections/q_grouping.py
src/queryablecollections/q_iterable.py
src/queryablecollections/q_ordered_iterable.py
src/zip_test.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="queryablecollections_tests/common_helpers.py">
from __future__ import annotations

from collections.abc import Callable, Iterable
from typing import cast

import pytest
from queryablecollections.collections.q_frozen_set import QFrozenSet
from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList
from queryablecollections.collections.q_set import QSet
from queryablecollections.q_iterable import QIterable, query


def create_sequences[T](iterable: Iterable[T] | Callable[[], Iterable[T]], skip_sets: bool = False) -> list[tuple[str, QIterable[T]]]:
    factory: Callable[[], Iterable[T]] = (iterable
                                          if not isinstance(iterable, Iterable)
                                          else lambda: cast(Iterable[T], iterable))  # pyright: ignore[reportUnnecessaryCast] while basedpyright understands it is not needed, pyright does not

    values = [
            ("query", query(factory())),
            ("QList", QList(factory())),
            ("QImmutableSequence", QImmutableSequence(list(factory()))),
    ]
    if not skip_sets:
        values += [("QSet", QSet(factory())),
                   ("QFRozenSet", QFrozenSet(factory()))]
    return values

def where_test[TIn, TOut](input: Iterable[TIn],
                          predicate: Callable[[TIn], bool],
                          output: list[TOut],
                          skip_sets: bool = False) -> None:
    for name, sequence in create_sequences(input, skip_sets):
        result = sequence.where(predicate)
        assert result.to_list() == output, name

def select_test[TIn, TOut](input: Iterable[TIn],
                           select: Callable[[TIn], TOut],
                           output: list[TOut],
                           skip_sets: bool = False) -> None:
    for name, sequence in create_sequences(input, skip_sets):
        result = sequence.select(select)
        assert result.to_list() == output, name

def lists_value_test[TIn, TOut](input: list[TIn] | Callable[[], Iterable[TIn]],
                                operation: Callable[[QIterable[TIn]], TOut],
                                output: TOut) -> None:
    value_test(input, operation, output, skip_sets=True)

def value_test[TIn, TOut](input: list[TIn] | Callable[[], Iterable[TIn]],
                          operation: Callable[[QIterable[TIn]], TOut],
                          output: TOut,
                          skip_sets: bool = False) -> None:
    for _name, sequence in create_sequences(input, skip_sets):
        result = operation(sequence)
        assert result == output

def throws_test[TIn, TOut](input: Iterable[TIn],
                           operation: Callable[[QIterable[TIn]], TOut],
                           output: type[Exception] = Exception,
                           skip_sets: bool = False) -> None:
    for name, sequence in create_sequences(input, skip_sets):
        with pytest.raises(output):  # noqa: PT012
            operation(sequence)
            pytest.fail(f"{name}: Expected {output} to be raised")

class CallCounter:
    def __init__(self) -> None:
        self.call_count: int = 0

    def increment(self) -> None:
        self.call_count += 1
</file>

<file path="queryablecollections_tests/numeric/test_q_decimal_iterable.py">
from __future__ import annotations

from decimal import Decimal

import pytest
from common_helpers import throws_test, value_test
from queryablecollections.collections.numeric.q_decimal_types import QDecimalList
from queryablecollections.q_errors import EmptyIterableError


def test_typing() -> None:
    QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).where(lambda item: True).sum()

def test_cast_decimal_returns_an_q_iterable_decimal_with_the_same_elements() -> None:
    value_test([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")], lambda x: x.cast.decimal().to_list(), [Decimal("1.1"), Decimal("2.1"), Decimal("3.1")])

def test_cast_checked_decimal_returns_a_q_iterable_decimal_with_the_same_elements() -> None:
    value_test([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")], lambda x: x.cast.checked.decimal().to_list(), [Decimal("1.1"), Decimal("2.1"), Decimal("3.1")])

def test_cast_checked_decimal_raises_type_error_if_collection_contains_non_decimal() -> None:
    throws_test([Decimal("1.1"), "2.1", Decimal("3.1")], lambda x: x.cast.checked.decimal().to_list(), TypeError)

def test_sum_returns_sum_of_the_values() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).sum() == Decimal("6.3")
def test_sum_returns_zero_on_on_empty_collection() -> None: assert QDecimalList().sum() == Decimal(0)

def test_min_returns_min_of_the_values() -> None: assert QDecimalList([Decimal("6.1"), Decimal("2.1"), Decimal("5.1"), Decimal("3.1")]).min() == Decimal("2.1")
def test_min_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QDecimalList().min()

def test_min_or_default_returns_min_of_the_values() -> None: assert QDecimalList([Decimal("6.1"), Decimal("2.1"), Decimal("5.1"), Decimal("3.1")]).min_or_default() == Decimal("2.1")
def test_min_or_default_returns_0_on_on_empty_collection() -> None: assert QDecimalList().min_or_default() == Decimal(0)

def test_max_returns_max_of_the_values() -> None: assert QDecimalList([Decimal("1.1"), Decimal("5.1"), Decimal("3.1")]).max() == Decimal("5.1")
def test_max_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QDecimalList().max()

def test_max_or_default_returns_max_of_the_values() -> None: assert QDecimalList([Decimal("1.1"), Decimal("5.1"), Decimal("3.1")]).max_or_default() == Decimal("5.1")
def test_max_or_default_returns_0_on_on_empty_collection() -> None: assert QDecimalList().max_or_default() == Decimal(0)

def test_average_returns_average_of_the_values() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).average() == Decimal("2.1")
def test_average_throws_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QDecimalList().average()

def test_average_or_default_returns_average_of_the_values() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).average_or_default() == Decimal("2.1")
def test_average_or_default_returns_0_on_on_empty_collection() -> None: assert QDecimalList().average_or_default() == Decimal(0)

def test_to_list_returns_a_list_with_the_same_elements() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).to_list() == [Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]
def test_to_set_returns_a_set_with_the_same_elements() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).to_set() == {Decimal("1.1"), Decimal("2.1"), Decimal("3.1")}
def test_to_frozenset_returns_a_frozenset_with_the_same_elements() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).to_frozenset() == frozenset({Decimal("1.1"), Decimal("2.1"), Decimal("3.1")})
def test_to_sequence_returns_a_sequence_with_the_same_elements() -> None: assert QDecimalList([Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]).to_sequence().to_list() == [Decimal("1.1"), Decimal("2.1"), Decimal("3.1")]
</file>

<file path="queryablecollections_tests/numeric/test_q_float_iterable.py">
from __future__ import annotations

from common_helpers import *
from queryablecollections.collections.numeric.q_float_types import QFloatList
from queryablecollections.q_errors import EmptyIterableError


def test_cast_float_returns_an_q_iterable_float_with_the_same_elements() -> None:
    value_test([1.1, 2.1, 3.1], lambda x: x.cast.float().to_list(), [1.1, 2.1, 3.1])

def test_cast_checked_float_returns_a_q_iterable_float_with_the_same_elements() -> None:
    value_test([1.1, 2.1, 3.1], lambda x: x.cast.checked.float().to_list(), [1.1, 2.1, 3.1])

def test_cast_checked_float_raises_type_error_if_collection_contains_non_float() -> None:
    throws_test([1.1, "2.1", 3.1], lambda x: x.cast.checked.float().to_list(), TypeError)

def test_sum_returns_sum_of_the_values() -> None: assert QFloatList([1.1, 2.1, 3.1]).sum() == 6.300000000000001
def test_sum_returns_zero_on_on_empty_collection() -> None: assert QFloatList().sum() == 0

def test_min_returns_min_of_the_values() -> None: assert QFloatList([6.1, 2.1, 5.1, 3.1]).min() == 2.1
def test_min_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QFloatList().min()

def test_min_or_default_returns_min_of_the_values() -> None: assert QFloatList([6.1, 2.1, 5.1, 3.1]).min_or_default() == 2.1
def test_min_or_default_returns_0_on_on_empty_collection() -> None: assert QFloatList().min_or_default() == 0

def test_max_returns_max_of_the_values() -> None: assert QFloatList([1.1, 5.1, 3.1]).max() == 5.1
def test_max_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QFloatList().max()

def test_max_or_default_returns_max_of_the_values() -> None: assert QFloatList([1.1, 5.1, 3.1]).max_or_default() == 5.1
def test_max_or_default_returns_0_on_on_empty_collection() -> None: assert QFloatList().max_or_default() == 0

def test_average_returns_average_of_the_values() -> None: assert QFloatList([1.1, 2.1, 3.1]).average() == 2.1
def test_average_throws_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QFloatList().average()

def test_average_or_default_returns_average_of_the_values() -> None: assert QFloatList([1.1, 2.1, 3.1]).average_or_default() == 2.1
def test_average_or_default_returns_0_on_on_empty_collection() -> None: assert QFloatList().average_or_default() == 0

def test_to_list_returns_a_list_with_the_same_elements() -> None: assert QFloatList([1.1, 2.1, 3.1]).to_list() == [1.1, 2.1, 3.1]
def test_to_set_returns_a_set_with_the_same_elements() -> None: assert QFloatList([1.1, 2.1, 3.1]).to_set() == {1.1, 2.1, 3.1}
def test_to_frozenset_returns_a_frozenset_with_the_same_elements() -> None: assert QFloatList([1.1, 2.1, 3.1]).to_frozenset() == frozenset({1.1, 2.1, 3.1})
def test_to_sequence_returns_a_sequence_with_the_same_elements() -> None: assert QFloatList([1.1, 2.1, 3.1]).to_sequence().to_list() == [1.1, 2.1, 3.1]
</file>

<file path="queryablecollections_tests/numeric/test_q_fraction_iterable.py">
from __future__ import annotations

from fractions import Fraction

from common_helpers import *
from queryablecollections.collections.numeric.q_fraction_types import QFractionList
from queryablecollections.q_errors import EmptyIterableError


def test_cast_fraction_returns_an_q_iterable_fraction_with_the_same_elements() -> None:
    value_test([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)], lambda x: x.cast.fraction().to_list(), [Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)])

def test_cast_checked_fraction_returns_a_q_iterable_fraction_with_the_same_elements() -> None:
    value_test([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)], lambda x: x.cast.checked.fraction().to_list(), [Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)])

def test_cast_checked_fraction_raises_type_error_if_collection_contains_non_fraction() -> None:
    throws_test([Fraction(11, 10), "2.1", Fraction(31, 10)], lambda x: x.cast.checked.fraction().to_list(), TypeError)

def test_sum_returns_sum_of_the_values() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).sum() == Fraction(63, 10)
def test_sum_returns_zero_on_on_empty_collection() -> None: assert QFractionList().sum() == Fraction(0)

def test_min_returns_min_of_the_values() -> None: assert QFractionList([Fraction(61, 10), Fraction(21, 10), Fraction(51, 10), Fraction(31, 10)]).min() == Fraction(21, 10)
def test_min_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QFractionList().min()

def test_min_or_default_returns_min_of_the_values() -> None: assert QFractionList([Fraction(61, 10), Fraction(21, 10), Fraction(51, 10), Fraction(31, 10)]).min_or_default() == Fraction(21, 10)
def test_min_or_default_returns_0_on_on_empty_collection() -> None: assert QFractionList().min_or_default() == Fraction(0)

def test_max_returns_max_of_the_values() -> None: assert QFractionList([Fraction(11, 10), Fraction(51, 10), Fraction(31, 10)]).max() == Fraction(51, 10)
def test_max_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QFractionList().max()

def test_max_or_default_returns_max_of_the_values() -> None: assert QFractionList([Fraction(11, 10), Fraction(51, 10), Fraction(31, 10)]).max_or_default() == Fraction(51, 10)
def test_max_or_default_returns_0_on_on_empty_collection() -> None: assert QFractionList().max_or_default() == Fraction(0)

def test_average_returns_average_of_the_values() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).average() == Fraction(21, 10)
def test_average_throws_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QFractionList().average()

def test_average_or_default_returns_average_of_the_values() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).average_or_default() == Fraction(21, 10)
def test_average_or_default_returns_0_on_on_empty_collection() -> None: assert QFractionList().average_or_default() == Fraction(0)

def test_to_list_returns_a_list_with_the_same_elements() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).to_list() == [Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]
def test_to_set_returns_a_set_with_the_same_elements() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).to_set() == {Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)}
def test_to_frozenset_returns_a_frozenset_with_the_same_elements() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).to_frozenset() == frozenset({Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)})
def test_to_sequence_returns_a_sequence_with_the_same_elements() -> None: assert QFractionList([Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]).to_sequence().to_list() == [Fraction(11, 10), Fraction(21, 10), Fraction(31, 10)]
</file>

<file path="queryablecollections_tests/numeric/test_q_int_iterable.py">
from __future__ import annotations

from common_helpers import *
from queryablecollections.collections.numeric.q_int_types import QIntList
from queryablecollections.q_errors import EmptyIterableError


def test_cast_int_returns_an_q_iterable_int_with_the_same_elements() -> None:
    value_test([1, 2, 3], lambda x: x.cast.int().to_list(), [1, 2, 3])

def test_cast_checked_int_returns_a_q_iterable_int_with_the_same_elements() -> None:
    value_test([1, 2, 3], lambda x: x.cast.checked.int().to_list(), [1, 2, 3])

def test_cast_checked_int_raises_type_error_if_collection_contains_non_int() -> None:
    throws_test([1, "2", 3], lambda x: x.cast.checked.int().to_list(), TypeError)

def test_sum_returns_sum_of_the_values() -> None: assert QIntList([1, 2, 3]).sum() == 6
def test_sum_returns_zero_on_on_empty_collection() -> None: assert QIntList().sum() == 0

def test_min_returns_min_of_the_values() -> None: assert QIntList([6, 2, 5, 3]).min() == 2
def test_min_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QIntList().min()

def test_min_or_default_returns_min_of_the_values() -> None: assert QIntList([6, 2, 5, 3]).min_or_default() == 2
def test_min_or_default_returns_0_on_on_empty_collection() -> None: assert QIntList().min_or_default() == 0

def test_max_returns_max_of_the_values() -> None: assert QIntList([1, 5, 3]).max() == 5
def test_max_raises_invalid_operation_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QIntList().max()

def test_max_or_default_returns_max_of_the_values() -> None: assert QIntList([1, 5, 3]).max_or_default() == 5
def test_max_or_default_returns_0_on_on_empty_collection() -> None: assert QIntList().max_or_default() == 0

def test_average_returns_average_of_the_values() -> None: assert QIntList([1, 2, 3]).average() == 2
def test_average_throws_on_on_empty_collection() -> None:
    with pytest.raises(EmptyIterableError): QIntList().average()

def test_average_or_default_returns_average_of_the_values() -> None: assert QIntList([1, 2, 3]).average_or_default() == 2
def test_average_or_default_returns_0_on_on_empty_collection() -> None: assert QIntList().average_or_default() == 0

def test_to_list_returns_a_list_with_the_same_elements() -> None: assert QIntList([1, 2, 3]).to_list() == [1, 2, 3]
def test_to_set_returns_a_set_with_the_same_elements() -> None: assert QIntList([1, 2, 3]).to_set() == {1, 2, 3}
def test_to_frozenset_returns_a_frozenset_with_the_same_elements() -> None: assert QIntList([1, 2, 3]).to_frozenset() == frozenset({1, 2, 3})
def test_to_sequence_returns_a_sequence_with_the_same_elements() -> None: assert QIntList([1, 2, 3]).to_sequence().to_list() == [1, 2, 3]
</file>

<file path="queryablecollections_tests/q_iterable/test_all.py">
from __future__ import annotations

from common_helpers import value_test


def test_returns_true_if_all_elements_match_predicate() -> None:
    value_test([1, 2, 3],
               lambda x: x.all(lambda y: y != 0),
               True)

def test_eturns_false_if_any_element_does_not_match_predicate() -> None:
    value_test([1, 2, 3],
               lambda x: x.all(lambda y: y != 1),
               False)
</file>

<file path="queryablecollections_tests/q_iterable/test_any.py">
from __future__ import annotations

from common_helpers import value_test


def test_any_returns_true_if_there_are_elements() -> None:
    value_test([1],
               lambda x: x.any(),
               True)

def test_any_returns_false_if_there_are_no_elements() -> None:
    value_test([],
               lambda x: x.any(),
               False)
</file>

<file path="queryablecollections_tests/q_iterable/test_as_.py">
from __future__ import annotations

from decimal import Decimal
from fractions import Fraction

from queryablecollections.collections.numeric.q_decimal_types import QDecimalIterable
from queryablecollections.collections.numeric.q_float_types import QFloatIterable
from queryablecollections.collections.numeric.q_fraction_types import QFractionIterable
from queryablecollections.collections.numeric.q_int_types import QIntIterable
from queryablecollections.collections.q_list import QList


def test_iterable_of_int_returns_an_int_iterable_with_all_the_values_in_order() -> None:
    test = QList(("1", "2", "3")).select(int).as_ints()

    assert test.to_list() == [1, 2, 3]
    assert isinstance(test, QIntIterable)

def test_iterable_of_float_returns_a_float_iterable_with_all_the_values_in_order() -> None:
    test = QList(("1.1", "2.1", "3.1")).select(float).as_floats()

    assert test.to_list() == [1.1, 2.1, 3.1]
    assert isinstance(test, QFloatIterable)

def test_iterable_of_fraction_returns_a_fraction_iterable_with_all_the_values_in_order() -> None:
    test = QList((Fraction(1, 2), Fraction(2, 3))).as_fractions()

    assert test.to_list() == [Fraction(1, 2), Fraction(2, 3)]
    assert isinstance(test, QFractionIterable)

def test_iterable_of_decimal_returns_a_decimal_iterable_with_all_the_values_in_order() -> None:
    test = QList((Decimal("1.2"), Decimal("2.1"))).as_decimals()

    assert test.to_list() == [Decimal("1.2"), Decimal("2.1")]
    assert isinstance(test, QDecimalIterable)
</file>

<file path="queryablecollections_tests/q_iterable/test_cast_checked_to.py">
from __future__ import annotations

from decimal import Decimal
from fractions import Fraction

from common_helpers import lists_value_test, throws_test


def test_to_int_returns_q_iterable_with_same_elements_when_types_match() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.cast.checked.to(int).to_list(),
                     [1, 2, 3])

def test_to_str_returns_q_iterable_with_same_elements() -> None:
    lists_value_test(["hello", "world"],
                     lambda x: x.cast.checked.to(str).to_list(),
                     ["hello", "world"])

def test_to_fraction_returns_q_iterable_with_same_elements() -> None:
    lists_value_test([Fraction(1, 3), Fraction(2, 5)],
                     lambda x: x.cast.checked.to(Fraction).to_list(),
                     [Fraction(1, 3), Fraction(2, 5)])

def test_to_decimal_returns_q_iterable_with_same_elements() -> None:
    lists_value_test([Decimal("1.23"), Decimal("4.56")],
                     lambda x: x.cast.checked.to(Decimal).to_list(),
                     [Decimal("1.23"), Decimal("4.56")])

def test_raises_type_error_when_types_dont_match() -> None:
    throws_test([1, "2", 3],
                lambda x: x.cast.checked.to(int).to_list(),
                TypeError)

def test_raises_type_error_for_mixed_string_int() -> None:
    throws_test(["hello", 42],
                lambda x: x.cast.checked.to(str).to_list(),
                TypeError)

def test_raises_type_error_for_mixed_fraction_float() -> None:
    throws_test([Fraction(1, 3), 0.5],
                lambda x: x.cast.checked.to(Fraction).to_list(),
                TypeError)

def test_raises_type_error_for_mixed_decimal_float() -> None:
    throws_test([Decimal("1.23"), 4.56],
                lambda x: x.cast.checked.to(Decimal).to_list(),
                TypeError)
</file>

<file path="queryablecollections_tests/q_iterable/test_cast_to.py">
from __future__ import annotations

from decimal import Decimal
from fractions import Fraction

from common_helpers import lists_value_test


def test_to_int_returns_q_iterable_with_same_elements() -> None:
    lists_value_test([1, 2, 3],
                     lambda x: x.cast.to(int).to_list(),
                     [1, 2, 3])

def test_to_str_returns_q_iterable_with_same_elements() -> None:
    lists_value_test(["a", "b", "c"],
                     lambda x: x.cast.to(str).to_list(),
                     ["a", "b", "c"])

def test_to_fraction_q_iterable_with_same_elements() -> None:
    lists_value_test([Fraction(1, 2), Fraction(3, 4)],
                     lambda x: x.cast.to(Fraction).to_list(),
                     [Fraction(1, 2), Fraction(3, 4)])

def test_to_decimal_returns_q_iterable_with_same_elements() -> None:
    lists_value_test([Decimal("1.5"), Decimal("2.7")],
                     lambda x: x.cast.to(Decimal).to_list(),
                     [Decimal("1.5"), Decimal("2.7")])
</file>

<file path="queryablecollections_tests/q_iterable/test_concat.py">
from __future__ import annotations

from common_helpers import value_test


def test_concat_appends_second_sequence_to_first() -> None:
    value_test([1, 2],
               lambda x: x.concat([3, 4]).to_list(),
               [1, 2, 3, 4])
</file>

<file path="queryablecollections_tests/q_iterable/test_distinct.py">
from __future__ import annotations

from common_helpers import value_test


def test_distinct_removes_duplicates_while_retaining_order() -> None:
    value_test([1, 2, 2, 3, 3],
               lambda x: x.distinct().to_list(),
               [1, 2, 3])

def test_distinct_by_removes_duplicates_by_selected_key_while_retaining_order_keeping_the_first_matched_value() -> None:
    value_test([("a", 1),
                ("a", 2),
                ("b", 3),
                ("a", 4),
                ("b", 5)],
               lambda x: x.distinct_by(lambda y: y[0]).to_list(),
               [("a", 1),
                ("b", 3)],
               skip_sets=True)
</file>

<file path="queryablecollections_tests/q_iterable/test_element_at_or_none.py">
from __future__ import annotations

from common_helpers import value_test


def test_0_test_returns_element_1() -> None:
    value_test([1, 2, 3],
               lambda x: x.element_at_or_none(0),
               1)

def test_1_return_element_2() -> None:
    value_test([1, 2, 3],
               lambda x: x.element_at_or_none(1),
               2)

def test_2_returns_element_3() -> None:
    value_test([1, 2, 3],
               lambda x: x.element_at_or_none(2),
               3)

def test_returns_none_if_index_is_out_of_range() -> None:
    value_test([1, 2, 3],
               lambda x: x.element_at_or_none(3),
               None)
</file>

<file path="queryablecollections_tests/q_iterable/test_element_at.py">
from __future__ import annotations

from common_helpers import throws_test, value_test


def test_0_returns_element_1() -> None:
    value_test([1, 2, 3],
               lambda x: x.element_at(0),
               1)

def test_1_return_element_2() -> None: value_test(
        [1, 2, 3],
        lambda x: x.element_at(1),
        2)

def test_2_returns_element_3() -> None:
    value_test([1, 2, 3],
               lambda x: x.element_at(2),
               3)

def test_throws_if_index_is_out_of_range() -> None:
    throws_test((1, 2, 3),
                lambda x: x.element_at(3),
                IndexError)
</file>

<file path="queryablecollections_tests/q_iterable/test_empty.py">
from __future__ import annotations

from queryablecollections.collections.q_frozen_set import QFrozenSet
from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList
from queryablecollections.collections.q_sequence import QSequence
from queryablecollections.collections.q_set import QSet
from queryablecollections.q_iterable import QIterable


def test_iterable_empty_returns_empty_sequence_the_same_instance_each_time() -> None:
    assert QIterable[str].empty() is not None
    assert QIterable[str].empty() is QIterable.empty()

def test_sequence_empty_returns_empty_sequence_the_same_instance_each_time() -> None:
    assert QSequence[str].empty() is not None
    assert QSequence[str].empty() is QSequence.empty()

def test_list_empty_returns_empty_list_new_instance_each_time() -> None:
    assert QList[str].empty() is not None
    assert QList[str].empty() is not QList.empty()

def test_set_empty_returns_empty_set_new_instance_each_time() -> None:
    assert QSet[str].empty() is not None
    assert QSet[str].empty() is not QSet.empty()

def test_frozen_set_empty_returns_empty_set_same_instance_each_time() -> None:
    assert QFrozenSet[str].empty() is not None
    assert QFrozenSet[str].empty() is QFrozenSet.empty()

def test_immutable_sequence_empty_returns_empty_set_same_instance_each_time() -> None:
    assert QImmutableSequence[str].empty() is not None
    assert QImmutableSequence[str].empty() is QImmutableSequence.empty()
</file>

<file path="queryablecollections_tests/q_iterable/test_first.py">
from __future__ import annotations

from common_helpers import throws_test, value_test


def test_first_returns_first_value() -> None:
    value_test([1, 2, 3],
               lambda x: x.first(),
               1)

def test_first_returns_single_none_value() -> None:
    value_test([None],
               lambda x: x.first(),
               None)

def test_first_or_none_returns_first_value() -> None:
    value_test([1, 2, 3],
               lambda x: x.first_or_none(),
               1)

def test_first_or_none_return_none_if_no_values() -> None:
    value_test([],
               lambda x: x.first_or_none(),
               None)

def test_first_or_none_returns_single_none_value() -> None:
    value_test([None],
               lambda x: x.first_or_none(),
               None)

def test_first_throws_if_no_values() -> None:
    throws_test([], lambda x: x.first())
</file>

<file path="queryablecollections_tests/q_iterable/test_for_each.py">
from __future__ import annotations

from common_helpers import CallCounter, value_test


def test_executes_action_for_each_element() -> None:
    value_test(lambda: [CallCounter(), CallCounter(), CallCounter()],
               lambda x: x.for_each(lambda y: y.increment()).select(lambda y: y.call_count).to_list(),
               [1, 1, 1])
</file>

<file path="queryablecollections_tests/q_iterable/test_group_by.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


def test_group_by_first_character_of_string_returns_one_group_per_unique_first_character_in_the_order_encountered() -> None:
    data = ["apple", "apricot", "banana", "blueberry", "cherry"]

    groups = query(data).group_by(lambda string: string[0]).to_list()

    assert len(groups) == 3

    a_group = groups.single(lambda group: group.key == "a")
    assert a_group == groups[0]
    b_group = groups.single(lambda group: group.key == "b")
    assert b_group == groups[1]
    c_group = groups.single(lambda group: group.key == "c")
    assert c_group == groups[2]

    assert a_group == ["apple", "apricot"]
    assert b_group == ["banana", "blueberry"]
    assert c_group == ["cherry"]

def test_group_by_first_character_of_string_with_element_selector_returns_one_group_per_unique_first_character_in_the_order_encountered_and_the_values_are_the_selected_value() -> None:
    data = ["apple", "apricot", "banana", "blueberry", "cherry"]

    groups = (query(data)
              .group_by(lambda element: element[0], lambda element: len(element))
              .to_list())

    assert len(groups) == 3

    a_group = groups.single(lambda group: group.key == "a")
    assert a_group == groups[0]
    b_group = groups.single(lambda group: group.key == "b")
    assert b_group == groups[1]
    c_group = groups.single(lambda group: group.key == "c")
    assert c_group == groups[2]
    assert a_group.ordered().to_list() == [len("apple"), len("apricot")]  # apple=5, apricot=7
    assert b_group == [len("banana"), len("blueberry")]
    assert c_group == [len("cherry")]

def test_group_by_empty_returns_no_groups() -> None:
    result = QList[int]([]).group_by(lambda element: element).to_list()
    assert result == []
</file>

<file path="queryablecollections_tests/q_iterable/test_indexer.py">
from __future__ import annotations

from common_helpers import value_test


def test_indexer_returns_first_value() -> None:
    value_test([1, 2, 3],
               lambda x: x.to_list()[0],
               1)

def test_indexer_returns_middle_value() -> None:
    value_test([1, 2, 3],
               lambda x: x.to_list()[1],
               2)

def test_indexer_returns_last_value() -> None:
    value_test([1, 2, 3],
               lambda x: x.to_list()[2],
               3)
</file>

<file path="queryablecollections_tests/q_iterable/test_join.py">
from __future__ import annotations

from dataclasses import dataclass

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


@dataclass
class Person:
    id: int | None
    name: str

@dataclass
class Order:
    id: int
    person_id: int | None
    amount: float

class TestJoin:
    def test_join_with_matching_keys_returns_combined_results(self) -> None:
        people = [Person(1, "Alice"), Person(2, "Bob")]
        orders = [Order(101, 1, 100.0), Order(102, 2, 200.0), Order(103, 1, 150.0)]

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        expected = ["Alice: $100.0", "Alice: $150.0", "Bob: $200.0"]
        assert result == expected

    def test_join_with_no_matching_keys_returns_empty_sequence(self) -> None:
        people = [Person(1, "Alice"), Person(2, "Bob")]
        orders = [Order(101, 3, 100.0), Order(102, 4, 200.0)]

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        assert result == []

    def test_join_with_empty_outer_sequence_returns_empty_sequence(self) -> None:
        people = QList[Person]()
        orders = [Order(101, 1, 100.0), Order(102, 2, 200.0)]

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        assert result == []

    def test_join_with_empty_inner_sequence_returns_empty_sequence(self) -> None:
        people = [Person(1, "Alice"), Person(2, "Bob")]
        orders = QList[Order]()

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        assert result == []

    def test_join_with_both_empty_sequences_returns_empty_sequence(self) -> None:
        people = QList[Person]()
        orders = QList[Order]()

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        assert result == []

    def test_join_with_simple_types_works_correctly(self) -> None:
        numbers = [1, 2, 3, 2]
        letters = ["a", "1a", "c", "3a", "2a", "4a"]

        result = (query(numbers)
                  .join(letters,
                        lambda this: str(this),
                        lambda other: other[0],
                        lambda this, other: f"{this}-{other}")
                  .to_list())

        assert result == ["1-1a", "2-2a", "3-3a", "2-2a"]

    def test_join_with_different_key_types_works_correctly(self) -> None:
        # Test with string keys
        categories = [("tech", "Technology"), ("health", "Health")]
        products = [("laptop", "tech"), ("tablet", "tech"), ("vitamins", "health")]

        result = (query(categories)
                  .join(products,
                        lambda this: this[0],  # category id
                        lambda other: other[1],  # product category
                        lambda this, other: f"{other[0]} in {this[1]}")
                  .to_list())

        expected = ["laptop in Technology", "tablet in Technology", "vitamins in Health"]
        assert result == expected

    def test_join_is_lazy(self) -> None:
        call_count = 0

        def counting_result_selector(p: Person, o: Order) -> str:
            nonlocal call_count
            call_count += 1
            return f"{p.name}: ${o.amount}"

        people = [Person(1, "Alice"), Person(2, "Bob")]
        orders = [Order(101, 1, 100.0), Order(102, 2, 200.0)]

        joined = query(people).join(orders,
                                    lambda this: this.id,
                                    lambda other: other.person_id,
                                    counting_result_selector)

        assert call_count == 0

        result = joined.to_list()
        assert call_count == 2
        assert result == ["Alice: $100.0", "Bob: $200.0"]

    def test_join_with_none_keys_match_each_other(self) -> None:
        people = [Person(1, "Alice"), Person(None, "Bob")]
        orders = [Order(101, 1, 100.0), Order(102, None, 200.0)]  # type: ignore

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        expected = ["Alice: $100.0", "Bob: $200.0"]
        assert result == expected

    def test_join_with_duplicate_keys_in_outer_sequence(self) -> None:
        people = [Person(1, "Alice"), Person(1, "Alice2"), Person(2, "Bob")]
        orders = [Order(101, 1, 100.0), Order(102, 2, 200.0)]

        result = (query(people)
                  .join(orders,
                        lambda this: this.id,
                        lambda other: other.person_id,
                        lambda this, other: f"{this.name}: ${other.amount}")
                  .to_list())

        expected = ["Alice: $100.0", "Alice2: $100.0", "Bob: $200.0"]
        assert result == expected
</file>

<file path="queryablecollections_tests/q_iterable/test_none.py">
from __future__ import annotations

from common_helpers import value_test


def test_none_returns_false_if_there_are_elements() -> None:
    value_test([1],
               lambda x: x.none(),
               False)

def test_none_returns_true_if_there_are_no_elements() -> None:
    value_test([],
               lambda x: x.none(),
               True)
</file>

<file path="queryablecollections_tests/q_iterable/test_not_none.py">
from __future__ import annotations

from common_helpers import value_test
from queryablecollections.collections.q_list import QList


def test_not_none_returns_only_elements_that_are_not_none() -> None:
    value_test([1, None],
               lambda x: x.where_not_none().to_list(),
               [1])

def test_not_none_returns_empty_list_if_all_elements_are_none() -> None:
    value_test(QList[str | None]([None, None]),
               lambda x: x.where_not_none().to_list(),
               list[str]())
</file>

<file path="queryablecollections_tests/q_iterable/test_of_type.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_of_type_filters_by_type() -> None:
    mixed_type_values = query([1, "hello", 2.5, "world", 42, 3.14, True, False])

    assert mixed_type_values.of_type(str).to_list() == ["hello", "world"]
    assert mixed_type_values.of_type(int).to_list() == [1, 42, True, False]  # note: bool is a subclass of int in Python
    assert mixed_type_values.of_type(float).to_list() == [2.5, 3.14]

def test_of_type_with_inheritance() -> None:
    class Animal:
        def __init__(self, name: str) -> None:
            self.name = name

    class Dog(Animal): pass

    class Cat(Animal): pass

    mixed_animals = query([Dog("Buddy"),
                           Cat("Whiskers"),
                           Dog("Rex"),
                           Animal("Generic"),
                           Cat("Mittens")])

    dogs = mixed_animals.of_type(Dog).to_list()
    assert len(dogs) == 2
    assert all(isinstance(dog, Dog) for dog in dogs)
    assert dogs.select(lambda dog: dog.name).to_list() == ["Buddy", "Rex"]

    cats = mixed_animals.of_type(Cat).to_list()
    assert len(cats) == 2
    assert all(isinstance(cat, Cat) for cat in cats)
    assert cats.select(lambda cat: cat.name).to_list() == ["Whiskers", "Mittens"]

    all_animals = mixed_animals.of_type(Animal).to_list()
    assert len(all_animals) == 5
    assert all(isinstance(animal, Animal) for animal in all_animals)

def test_if_there_are_no_floats_of_type_float_returns_no_elements() -> None:
    assert (query([1, 2, 3, "hello", "world"]).of_type(float)
            .to_list()) == []

def test_of_type_string_returns_all_strings() -> None:
    assert (query(["apple", "banana", "cherry"])
            .of_type(str).to_list() == ["apple", "banana", "cherry"])

def test_of_type_with_none_values_only_returns_none_values_if_the_given_type_was_none() -> None:
    list_including_none_values = [1, None, "hello", None, 2.5, None]

    assert query(list_including_none_values).of_type(str).to_list() == ["hello"]

    assert query(list_including_none_values).of_type(int).to_list() == [1]

    assert query(list_including_none_values).of_type(type(None)).to_list() == [None, None, None]
</file>

<file path="queryablecollections_tests/q_iterable/test_order_by.py">
from __future__ import annotations

from common_helpers import throws_test, value_test


def test_order_by_sorts_in_ascending_order() -> None:
    value_test([3, 2, 1],
               lambda input: input.order_by(lambda y: y).to_list(),
               [1, 2, 3])

def test_order_by_descending_sorts_in_descending_order() -> None:
    value_test([3, 2, 1],
               lambda input: input.order_by_descending(lambda y: y).to_list(),
               [3, 2, 1])

def test_then_by_sorts_in_ascending_order() -> None:
    value_test([3, 2, 1],
               lambda input: input
               .order_by(lambda item: item)
               .then_by(lambda item: item).to_list(),
               [1, 2, 3])

    value_test([3, 2, 1],
               lambda iterable: iterable
               .order_by(lambda item: item)
               .then_by(lambda item: 1 if item == 1 else 0).to_list(),
               [2, 3, 1])

def test_then_by_descending_sorts_in_descending_order() -> None:
    value_test([3, 2, 1],
               lambda x: x.order_by(lambda y: y).then_by_descending(lambda y: y).to_list(), [3, 2, 1])
    value_test([3, 2, 1],
               lambda x: x.order_by(lambda y: y).then_by_descending(lambda y: 1 if y == 2 else 0).to_list(), [2, 1, 3])

def test_can_sort_ints_implicitly() -> None:
    value_test([3, 2, 1], lambda x: x.ordered().to_list(), [1, 2, 3])

def test_can_sort_strings_implicitly() -> None:
    value_test(["c", "b", "a"], lambda x: x.ordered().to_list(), ["a", "b", "c"])

def test_can_sort_floats_implicitly() -> None:
    value_test([3.0, 2.0, 1.0], lambda x: x.ordered().to_list(), [1.0, 2.0, 3.0])

class MyClass:
    pass

def test_cannot_sort_myclass_implicitly() -> None:
    throws_test([MyClass(), MyClass()], lambda x: x.ordered().to_list(), TypeError)
</file>

<file path="queryablecollections_tests/q_iterable/test_qcount.py">
from __future__ import annotations

from common_helpers import value_test


def test_returns_element_count_of_sequence() -> None:
    value_test([0], lambda x: x.qcount(), 1)
    value_test([0, 3], lambda x: x.qcount(), 2)
    value_test([0, 3, 5], lambda x: x.qcount(), 3)
</file>

<file path="queryablecollections_tests/q_iterable/test_reverse.py">
from __future__ import annotations

from common_helpers import value_test


def test_reverse_returns_reversed_sequence() -> None:
    value_test([1, 2, 3],
               lambda x: x.reversed().to_list(),
               [3, 2, 1])
</file>

<file path="queryablecollections_tests/q_iterable/test_select_.py">
from __future__ import annotations

from common_helpers import select_test


def test_select() -> None:
    select_test((1, 2, 3),
                lambda x: x * 2,
                [2, 4, 6])
</file>

<file path="queryablecollections_tests/q_iterable/test_select_many.py">
from __future__ import annotations

from common_helpers import value_test


def test_select_many_flattens_nested_sequences() -> None:
    value_test([[1, 2], [3, 4]],
               lambda x: x.select_many(lambda y: y).to_list(),
               [1, 2, 3, 4], skip_sets=True)
</file>

<file path="queryablecollections_tests/q_iterable/test_single_or_none.py">
from __future__ import annotations

from common_helpers import throws_test, value_test
from queryablecollections.q_errors import InvalidOperationError


def test_single_or_none_returns_single_value() -> None:
    value_test([1],
               lambda x: x.single_or_none(),
               1)

def test_single_or_none_returns_none_if_no_values() -> None:
    value_test([],
               lambda x: x.single_or_none(),
               None)

def test_single_or_none_throws_if_multiple_values() -> None:
    throws_test([1, 2],
                lambda x: x.single_or_none(),
                InvalidOperationError)
</file>

<file path="queryablecollections_tests/q_iterable/test_single.py">
from __future__ import annotations

from common_helpers import throws_test, value_test


def test_single_returns_single_value() -> None:
    value_test([1],
               lambda x: x.single(),
               1)

def test_single_throws_if_no_values() -> None:
    throws_test([],
                lambda x: x.single())

def test_single_throws_if_multiple_values() -> None:
    throws_test([1, 2],
                lambda x: x.single())

def test_single_returns_single_none_value() -> None:
    value_test([None],
               lambda x: x.single(),
               None)
</file>

<file path="queryablecollections_tests/q_iterable/test_skip_last.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_skip_last_skips_the_last_x_elements() -> None:
    assert query([1, 2, 3, 4, 5]).skip_last(2).to_list() == [1, 2, 3]

def test_skip_last_zero_returns_all_elements() -> None:
    assert query([1, 2, 3, 4, 5]).skip_last(0).to_list() == [1, 2, 3, 4, 5]

def test_skip_last_negative_returns_all_elements() -> None:
    assert query([1, 2, 3, 4, 5]).skip_last(-3).to_list() == [1, 2, 3, 4, 5]

def test_skip_last_more_than_available_returns_no_elements() -> None:
    assert query([1, 2, 3]).skip_last(10).to_list() == []

def test_skip_last_from_empty_returns_no_elements() -> None:
    assert query([]).skip_last(5).to_list() == []

def test_skip_last_single_element_returns_no_elements() -> None:
    assert query([42]).skip_last(1).to_list() == []
</file>

<file path="queryablecollections_tests/q_iterable/test_skip.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_skip_skips_the_specified_number_of_elements() -> None:
    assert query([1, 2, 3, 4, 5]).skip(2).to_list() == [3, 4, 5]

def test_skip_zero_returns_all_elements() -> None:
    assert query([1, 2, 3, 4, 5]).skip(0).to_list() == [1, 2, 3, 4, 5]

def test_skip_negative_count_returns_all_elements() -> None:
    assert query([1, 2, 3, 4, 5]).skip(-3).to_list() == [1, 2, 3, 4, 5]

def test_skip_more_than_available_returns_no_elements() -> None:
    assert query([1, 2, 3]).skip(10).to_list() == []

def test_skip_from_empty_returns_no_elements() -> None:
    assert query([]).skip(5).to_list() == []
</file>

<file path="queryablecollections_tests/q_iterable/test_take_last.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_take_last_returns_the_last_x_elements() -> None:
    assert query([1, 2, 3, 4, 5]).take_last(3).to_list() == [3, 4, 5]

def test_take_last_zero_returns_no_elements() -> None:
    assert query([1, 2, 3, 4, 5]).take_last(0).to_list() == []

def test_take_last_negative_count_returns_no_elements() -> None:
    assert query([1, 2, 3, 4, 5]).take_last(-5).to_list() == []

def test_take_last_more_than_available_returns_all_elements() -> None:
    assert query([1, 2, 3]).take_last(10).to_list() == [1, 2, 3]

def test_take_last_from_empty_returns_no_elements() -> None:
    assert query([]).take_last(5).to_list() == []

def test_take_last_single_element_returns_the_single_element() -> None:
    assert query([42]).take_last(1).to_list() == [42]
</file>

<file path="queryablecollections_tests/q_iterable/test_take_while.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_take_while_returns_elements_until_predicate_becomes_false() -> None:
    assert query([1, 2, 3, 4, 5]).take_while(lambda x: x < 4).to_list() == [1, 2, 3]

def test_take_while_with_always_true_predicate_returns_all_elements() -> None:
    assert query([1, 2, 3, 4, 5]).take_while(lambda x: x > 0).to_list() == [1, 2, 3, 4, 5]

def test_take_while_with_always_false_predicate_returns_no_elements() -> None:
    assert query([1, 2, 3, 4, 5]).take_while(lambda x: x < 0).to_list() == []

def test_take_while_with_first_element_failing_predicate_returns_empty() -> None:
    assert query([5, 1, 2, 3]).take_while(lambda x: x < 3).to_list() == []

def test_take_while_from_empty_collection_returns_empty() -> None:
    assert query(list[int]([])).take_while(lambda x: True).to_list() == []

def test_take_while_with_single_element_matching_predicate_returns_the_element() -> None:
    assert query([42]).take_while(lambda x: x > 0).to_list() == [42]

def test_take_while_with_single_element_not_matching_predicate_returns_no_elements() -> None:
    assert query([42]).take_while(lambda x: x < 0).to_list() == []

def test_take_while_is_lazy() -> None:
    call_count = 0

    def expensive_operation(_: int) -> int:
        nonlocal call_count
        call_count += 1
        return 0

    query([1, 2, 3, 4]).select(expensive_operation).take_while(lambda x: x < 6)
    assert call_count == 0

def test_take_while_stops_processing_at_the_first_element_that_fails_the_predidate() -> None:
    processed_values: list[int] = []

    def track_processing(x: int) -> int:
        processed_values.append(x)
        return x

    result = query([1, 2, 3, 4, 5]).select(track_processing).take_while(lambda x: x < 4).to_list()

    assert result == [1, 2, 3]
    assert processed_values == [1, 2, 3, 4]
</file>

<file path="queryablecollections_tests/q_iterable/test_take.py">
from __future__ import annotations

from queryablecollections.q_iterable import query


def test_take_returns_the_specified_number_of_elements_from_the_start() -> None:
    assert query([1, 2, 3, 4, 5]).take(3).to_list() == [1, 2, 3]

def test_take_zero_returns_empty_iterable() -> None:
    assert query([1, 2, 3, 4, 5]).take(0).to_list() == []

def test_take_negative_returns_empty_iterable() -> None:
    assert query([1, 2, 3, 4, 5]).take(-5).to_list() == []

def test_take_more_than_available_returns_the_full_iterable() -> None:
    assert query([1, 2, 3]).take(10).to_list() == [1, 2, 3]

def test_take_from_empty_returns_empty_iterable() -> None:
    assert query([]).take(5).to_list() == []
</file>

<file path="queryablecollections_tests/q_iterable/test_to_.py">
from __future__ import annotations

from common_helpers import value_test


def test_to_list() -> None: value_test([1, 2, 3], lambda x: x.to_list(), [1, 2, 3])
def test_to_sequence() -> None: value_test([1, 2, 3], lambda x: x.to_sequence().to_list(), [1, 2, 3])
def test_to_builtin_list() -> None: value_test([1, 2, 3], lambda x: x.to_built_in_list(), [1, 2, 3])
def test_to_set() -> None: value_test([1, 2, 3], lambda x: x.to_set(), {1, 2, 3})
def test_to_frozenset() -> None: value_test([1, 2, 3], lambda x: x.to_frozenset(), frozenset({1, 2, 3}))
</file>

<file path="queryablecollections_tests/q_iterable/test_to_dict.py">
from __future__ import annotations

import pytest
from queryablecollections.collections.q_list import QList
from queryablecollections.q_errors import ArgumentNoneError
from queryablecollections.q_iterable import query


class DummyObj:
    def __init__(self, name: str, val: int) -> None:
        self.name: str = name
        self.val: int = val

    def __eq__(self, other: object) -> bool:
        return isinstance(other, DummyObj) and self.name == other.name and self.val == other.val

class TestToDictFromKeyValueTypedIterable:
    """Tests for to_dict() method when called without selectors on sequences of tuples"""

    def test_with_no_arguments_returns_dict_mapping_all_keys_to_values(self) -> None:
        assert query([("a", 1),
                      ("b", 2),
                      ("c", 3)]).to_dict() == {"a": 1,
                                               "b": 2,
                                               "c": 3}

    def test_to_dict_from_empty_sequence_returns_empty_dict(self) -> None:
        assert QList[tuple[int, str]]().to_dict() == {}

    def test_to_dict_from_single_tuple_returns_single_entry_dict(self) -> None:
        assert query([("key", "value")]).to_dict() == {"key": "value"}

    def test_to_dict_with_mixed_types_preserves_types(self) -> None:
        tuple_list: list[tuple[str | int | bool, int | str | bool]] = \
            [("str_key", 42),
             (123, "str_value"),
             (True, False)]
        assert query(tuple_list).to_dict() == {"str_key": 42,
                                               123: "str_value",
                                               True: False}

    def test_to_dict_with_duplicate_keys_uses_last_value(self) -> None:
        assert query([("key", 1),
                      ("key", 2),
                      ("key", 3)]).to_dict() == {"key": 3}

class TestToDictWithSelectors:
    """Tests for to_dict() method when called with key and value selectors"""

    def test_to_dict_with_selectors_returns_a_dict_combining_the_selected_keys_and_values(self) -> None:
        assert (query([DummyObj("x", 10),
                       DummyObj("y", 14),
                       DummyObj("z", 16)])
                .to_dict(lambda o: o.name, lambda o: o.val) == {"x": 10,
                                                                "y": 14,
                                                                "z": 16})

    def test_to_dict_with_selectors_on_empty_sequence_returns_empty_dict(self) -> None:
        assert QList[int]([]).to_dict(lambda x: x, lambda x: x) == {}

    def test_to_dict_with_selectors_on_single_item_returns_single_entry_dict(self) -> None:
        assert (query([(DummyObj("test", 42))])
                .to_dict(lambda o: o.name, lambda o: o.val) == {"test": 42})

    def test_to_dict_with_selectors_and_duplicate_keys_uses_last_value(self) -> None:
        assert (query([DummyObj("same", 1),
                       DummyObj("same", 2),
                       DummyObj("same", 3)])
                .to_dict(lambda o: o.name, lambda o: o.val) == {"same": 3})

class TestToDictErrorCases:
    """Tests for error conditions in to_dict() method"""

    def test_to_dict_with_key_selector_but_without_value_selector_raises_argument_none_error(self) -> None:
        with pytest.raises(ArgumentNoneError):
            query([DummyObj("k", 9)]).to_dict(lambda o: o.name)  # type: ignore[call-overload]

    def test_to_dict_with_value_selector_but_without_key_selector_raises_argument_none_error(self) -> None:
        with pytest.raises(ArgumentNoneError):
            query([DummyObj("k", 9)]).to_dict(None, lambda o: o.val)  # type: ignore[call-overload]

    def test_to_dict_with_none_key_selector_raises_argument_none_error(self) -> None:
        with pytest.raises(ArgumentNoneError):
            query([DummyObj("k", 9)]).to_dict(None, lambda o: o.val)  # type: ignore[arg-type]
</file>

<file path="queryablecollections_tests/q_iterable/test_where.py">
from __future__ import annotations

from common_helpers import where_test


def test_where_first_element_returns_only_first_element() -> None:
    where_test((1, 2, 3),
               lambda x: x == 1,
               [1])

def test_where_middle_element_returns_only_middle_element() -> None:
    where_test((1, 2, 3),
               lambda x: x == 2,
               [2])

def test_where_last_element_returns_only_last_element() -> None:
    where_test((1, 2, 3),
               lambda x: x == 3,
               [3])

def test_where_excluding_first_element() -> None:
    where_test((1, 2, 3),
               lambda x: x != 1,
               [2, 3])

def test_where_excluding_middle_element() -> None:
    where_test((1, 2, 3),
               lambda x: x != 2,
               [1, 3])

def test_where_excluding_end_element() -> None:
    where_test((1, 2, 3),
               lambda x: x != 3,
               [1, 2])
</file>

<file path="queryablecollections_tests/q_iterable/test_zip.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


def test_zip_with_equal_length_sequences_returns_each_combination() -> None:
    assert (query([1, 2, 3])
            .zip([10, 20, 30], lambda x, y: (x, y))
            .to_list() == [(1, 10), (2, 20), (3, 30)])

def test_zip_with_single_element_sequences_returns_that_element() -> None:
    assert query([42]).zip([100], lambda x, y: (x, y)).to_list() == [(42, 100)]

def test_zip_with_shorter_first_sequence_returns_the_number_of_elements_in_the_first_sequence() -> None:
    assert (query([1, 2])
            .zip([10, 20, 30, 40], lambda x, y: (x, y))
            .to_list() == [(1, 10), (2, 20)])

def test_zip_with_second_sequence_shorter_returns_the_number_of_elements_in_the_second_sequence() -> None:
    assert (query([1, 2, 3, 4])
            .zip([10, 20], lambda x, y: (x, y))
            .to_list() == [(1, 10), (2, 20)])

def test_zip_with_empty_first_sequence_returns_no_elements() -> None:
    assert (query(list[int]([]))
            .zip([1, 2, 3], lambda x, y: (x, y))
            .to_list() == [])

def test_zip_with_empty_second_sequence_returns_no_elements() -> None:
    assert (query([1, 2, 3])
            .zip(list[int](), lambda x, y: (x, y))
            .to_list() == [])

def test_zip_with_both_empty_sequences_returns_no_elements() -> None:
    assert (QList[int]()
            .zip(QList[int](), lambda x, y: (x, y))
            .to_list() == [])
</file>

<file path="queryablecollections_tests/q_iterable/test_zip2.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


def test_zip2_with_equal_length_sequences_returns_each_combination() -> None:
    assert (
            query([1, 2, 3])
            .zip2([10, 20, 30],
                  [100, 200, 300],
                  lambda x, y, z: (x, y, z))
            .to_list()
            == [(1, 10, 100), (2, 20, 200), (3, 30, 300)]
    )

def test_zip2_with_single_element_sequences_returns_that_element() -> None:
    assert query([1]).zip2([10], [100], lambda x, y, z: (x, y, z)).to_list() == [(1, 10, 100)]

def test_zip2_with_shorter_first_sequence_returns_number_of_elements_in_first_sequence() -> None:
    assert (
            query([1, 2])
            .zip2([10, 20, 30, 40], [100, 200, 300, 400], lambda x, y, z: (x, y, z))
            .to_list()
            == [(1, 10, 100), (2, 20, 200)]
    )

def test_zip2_with_second_sequence_shorter_returns_number_of_elements_in_second_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip2([10, 20], [100, 200, 300, 400], lambda x, y, z: (x, y, z))
            .to_list()
            == [(1, 10, 100), (2, 20, 200)]
    )

def test_zip2_with_third_sequence_shorter_returns_number_of_elements_in_third_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip2([10, 20, 30, 40], [100, 200], lambda x, y, z: (x, y, z))
            .to_list()
            == [(1, 10, 100), (2, 20, 200)]
    )

def test_zip2_with_empty_first_sequence_returns_no_elements() -> None:
    assert (
            query(list[int]([]))
            .zip2([1, 2, 3], [10, 20, 30], lambda x, y, z: (x, y, z))
            .to_list()
            == []
    )

def test_zip2_with_empty_second_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip2(list[int](), [10, 20, 30], lambda x, y, z: (x, y, z))
            .to_list()
            == []
    )

def test_zip2_with_empty_third_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip2([10, 20, 30], list[int](), lambda x, y, z: (x, y, z))
            .to_list()
            == []
    )

def test_zip2_with_all_empty_sequences_returns_no_elements() -> None:
    assert (
            QList[int]()
            .zip2(QList[int](), QList[int](), lambda x, y, z: (x, y, z))
            .to_list()
            == []
    )
</file>

<file path="queryablecollections_tests/q_iterable/test_zip3.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList
from queryablecollections.q_iterable import query


def test_zip3_with_equal_length_sequences_returns_each_combination() -> None:
    assert (
            query([1, 2, 3])
            .zip3([10, 20, 30],
                  [100, 200, 300],
                  [1000, 2000, 3000],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000), (3, 30, 300, 3000)]
    )

def test_zip3_with_single_element_sequences_returns_that_element() -> None:
    assert query([1]).zip3([10], [100], [1000], lambda a, b, c, d: (a, b, c, d)).to_list() == [(1, 10, 100, 1000)]

def test_zip3_with_shorter_first_sequence_returns_number_of_elements_in_first_sequence() -> None:
    assert (
            query([1, 2])
            .zip3([10, 20, 30, 40],
                  [100, 200, 300, 400],
                  [1000, 2000, 3000, 4000],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000)]
    )

def test_zip3_with_second_sequence_shorter_returns_number_of_elements_in_second_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip3([10, 20],
                  [100, 200, 300, 400],
                  [1000, 2000, 3000, 4000],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000)]
    )

def test_zip3_with_third_sequence_shorter_returns_number_of_elements_in_third_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip3([10, 20, 30, 40],
                  [100, 200],
                  [1000, 2000, 3000, 4000],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000)]
    )

def test_zip3_with_fourth_sequence_shorter_returns_number_of_elements_in_fourth_sequence() -> None:
    assert (
            query([1, 2, 3, 4])
            .zip3([10, 20, 30, 40],
                  [100, 200, 300, 400],
                  [1000, 2000],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == [(1, 10, 100, 1000), (2, 20, 200, 2000)]
    )

def test_zip3_with_empty_first_sequence_returns_no_elements() -> None:
    assert (
            query(list[int]([]))
            .zip3([1, 2, 3],
                  [10, 20, 30]
                  , [100, 200, 300],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == []
    )

def test_zip3_with_empty_second_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip3(list[int](),
                  [10, 20, 30],
                  [100, 200, 300],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == []
    )

def test_zip3_with_empty_third_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip3([10, 20, 30],
                  list[int](),
                  [100, 200, 300],
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == []
    )

def test_zip3_with_empty_fourth_sequence_returns_no_elements() -> None:
    assert (
            query([1, 2, 3])
            .zip3([10, 20, 30],
                  [100, 200, 300],
                  list[int](),
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == []
    )

def test_zip3_with_all_empty_sequences_returns_no_elements() -> None:
    assert (
            QList[int]()
            .zip3(QList[int](),
                  QList[int](),
                  QList[int](),
                  lambda a, b, c, d: (a, b, c, d))
            .to_list()
            == []
    )
</file>

<file path="queryablecollections_tests/q_list/test_indexer.py">
from __future__ import annotations

from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList


def test_list_indexer_returns_element_at_index() -> None:
    values = QList((0, 1, 2))
    assert values[0] == 0
    assert values[1] == 1
    assert values[2] == 2

def test_sequence_indexer_returns_element_at_index() -> None:
    values = QImmutableSequence((0, 1, 2))
    assert values[0] == 0
    assert values[1] == 1
    assert values[2] == 2
</file>

<file path="queryablecollections_tests/q_list/test_slicing.py">
from __future__ import annotations

from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList


def test_list_slice_from_start_returns_the_specified_slice() -> None:
    assert QList((1, 2, 3, 4, 5, 6, 7))[:2] == QList([1, 2])

def test_sequence_slice_from_start_returns_the_specified_slice() -> None:
    assert QImmutableSequence((1, 2, 3, 4, 5, 6, 7))[:2].to_list() == QList([1, 2])

def test_list_slice_middle__returns_the_specified_slice() -> None:
    assert QList((1, 2, 3, 4, 5))[2:4] == QList([3, 4])

def test_sequence_slice_middle_returns_the_specified_slice() -> None:
    assert QImmutableSequence((1, 2, 3, 4, 5))[2:4].to_list() == QList([3, 4])

def test_list_slice_end_returns_the_specified_slice() -> None:
    assert QList((1, 2, 3, 4, 5))[3:] == QList([4, 5])

def test_sequence_slice_end_returns_the_specified_slice() -> None:
    assert QImmutableSequence((1, 2, 3, 4, 5))[3:].to_list() == QList([4, 5])

def test_list_slice_returns_qlist() -> None:
    value = QList((1, 2, 3))[1:]
    assert isinstance(value, QList)
    assert value.element_at(0) == 2

def test_sequence_slice_returns_qimmutable_sequence() -> None:
    value = QImmutableSequence((1, 2, 3))[1:]
    assert isinstance(value, QImmutableSequence)
    assert value.element_at(0) == 2
</file>

<file path="queryablecollections_tests/test_lazyness_and_consuming_behavior.py">
from __future__ import annotations

from collections.abc import Callable, Iterable
from decimal import Decimal
from fractions import Fraction
from typing import Any

from queryablecollections.q_iterable import QIterable, query


def swallow_exception_decorator(inner: ScalarOrActionOperator) -> ScalarOrActionOperator:
    def wrapper(argument: QIterable[int]) -> Any:  # noqa: ANN401
        # noinspection PyBroadException
        try:
            return inner(argument)
        except:  # noqa: E722
            pass

    return wrapper

type CollectionReturningOperator = Callable[[QIterable[int]], Iterable[object]]
type ScalarOrActionOperator = Callable[[QIterable[int]], Any]
iterator_generating_operators: list[tuple[str, CollectionReturningOperator]] = [
        ("as_decimals", lambda x1: x1.select(Decimal).as_decimals()),
        ("as_floats", lambda x1: x1.select(float).as_floats()),
        ("as_fractions", lambda x1: x1.select(Fraction).as_fractions()),
        ("as_ints", lambda x1: x1.as_ints()),
        ("cast", lambda x1: x1.cast.checked.to(int)),
        ("distinct", lambda x1: x1.distinct()),
        ("distinct_by", lambda x1: x1.distinct_by(lambda x2: x2)),
        ("group_by", lambda x1: x1.group_by(lambda x2: x2)),
        ("join", lambda x1: x1.join([1, 2, 3, 4], lambda key1: key1, lambda key2: key2, lambda val1, val2: val1 + val2)),
        ("of_type", lambda x1: x1.of_type(int)),
        ("order_by", lambda x1: x1.order_by(lambda x2: x2)),
        ("order_by_descending", lambda x1: x1.order_by_descending(lambda x2: x2)),
        ("ordered", lambda x1: x1.ordered()),
        ("reversed", lambda x1: x1.reversed()),
        ("select", lambda x1: x1.select(lambda x2: x2)),
        ("select_many", lambda x1: x1.select_many(lambda _: [1, 2, 3])),
        ("skip", lambda x1: x1.skip(1)),
        ("skip_last", lambda x1: x1.skip_last(1)),
        ("take", lambda x1: x1.take(10)),
        ("take_last", lambda x1: x1.take_last(1)),
        ("take_while", lambda x1: x1.take_while(lambda _: True)),
        ("where", lambda x1: x1.where(lambda _: True)),
        ("where_not_none", lambda x1: x1.where_not_none()),
        ("zip", lambda x1: x1.zip([1, 2, 3, 4], lambda x2, x3: (x2, x3))),
        ("zip2", lambda x1: x1.zip2([1, 2, 3], [1, 2, 3], lambda x2, x3, x4: (x2, x3, x4))),
        ("zip3", lambda x1: x1.zip3([1, 2, 3], [1, 2, 3], [1, 2, 3], lambda x2, x3, x4, x5: (x2, x3, x4, x5))),
]

scalar_or_action_operators: list[tuple[str, ScalarOrActionOperator]] = [
        ("all", lambda x1: x1.all(lambda _: True)),
        ("any", lambda x1: x1.any()),
        ("element_at", lambda x1: x1.element_at(0)),
        ("element_at_or_none", lambda x1: x1.element_at_or_none(0)),
        ("first", lambda x1: x1.first()),
        ("first_or_none", lambda x1: x1.first_or_none()),
        ("for_each", lambda x1: x1.for_each(null_op)),
        ("none", lambda x1: x1.none()),
        ("pipe", lambda x1: x1.pipe(lambda iterator: iterator.for_each(null_op))),
        ("qcount", lambda x1: x1.qcount()),
        ("single", swallow_exception_decorator(lambda x1: x1.single())),
        ("single_or_none", swallow_exception_decorator(lambda x1: x1.single_or_none())),
        ("to_built_in_list", lambda x1: x1.to_built_in_list()),
        ("to_dict", lambda x1: x1.to_dict(lambda x2: x2, lambda x2: x2)),
        ("to_frozenset", lambda x1: x1.to_frozenset()),
        ("to_list", lambda x1: x1.to_list()),
        ("to_sequence", lambda x1: x1.to_sequence()),
        ("to_set", lambda x1: x1.to_set()),
]

def assert_has_10_elements[T](iterable: QIterable[T]) -> QIterable[T]:
    assert sum(1 for _ in iterable) == 10
    return iterable

def assert_is_empty[T](iterable: QIterable[T]) -> QIterable[T]:
    assert sum(1 for _ in iterable) == 0
    return iterable

def generate_10_ints() -> QIterable[int]:
    return query(i for i in collection_10_ints())

def collection_10_ints() -> QIterable[int]:
    return query([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

def test_query_can_only_enumerate_once_given_a_generator() -> None:
    generator_query = query(i for i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    assert_has_10_elements(generator_query)
    assert_is_empty(generator_query)

def test_query_can_iterate_again_given_a_collection() -> None:
    generator_query = query([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    assert_has_10_elements(generator_query)
    assert_has_10_elements(generator_query)

def null_op(_: object) -> None: pass

exceptional_operators: set[str] = {"concat"}

all_tested_operator_names: set[str] = query(iterator_generating_operators).select(lambda x: x[0]).to_set() | query(scalar_or_action_operators).select(lambda x: x[0]).to_set()

def get_all_operator_names_defined_in__q_iterable_mixin() -> set[str]:
    return (query(QIterable.__dict__.items())
            .where(lambda x: not isinstance(x[1], (staticmethod, classmethod)))
            .select(lambda x: x[0])  # member names
            .where(lambda x: not x.startswith("_"))
            .to_set())

def test_all_operators_are_tested() -> None:
    missing_tests = get_all_operator_names_defined_in__q_iterable_mixin() - all_tested_operator_names - exceptional_operators
    if missing_tests: raise AssertionError(f"Missing tests for operators: {missing_tests}")

def test_no_iterator_generating_operator_consumes_elements_on_call_without_iteration() -> None:
    for operator_name, operator in iterator_generating_operators:
        original_iterator = generate_10_ints()
        operator(original_iterator)
        if original_iterator.qcount() != 10: raise AssertionError(f"Operator {operator_name} consumed elements on first call")

def test_all_iterator_generating_operators_when_called_on_generator_backed_iterable_consume_elements_but_only_once_iterated_and_the_results_they_return_change_on_second_iteration() -> None:
    for operator_name, operator in iterator_generating_operators:
        original_iterator = generate_10_ints()
        result = operator(original_iterator)
        length_of_iterable_returned_by_operator = sum(1 for _ in result)
        length_of_iterator_returned_by_operator_on_second_iteration = sum(1 for _ in result)

        assert length_of_iterable_returned_by_operator != 0, f"Operator {operator_name} did not return any elements"
        assert length_of_iterator_returned_by_operator_on_second_iteration != length_of_iterable_returned_by_operator, f"Operator {operator_name} returned the same results on second call"
        assert original_iterator.qcount() != 10, f"Operator {operator_name} did not consume any elements from source generator"

def test_no_iterator_generating_operators_when_called_on_collection_backed_iterator_consume_elements_and_they_return_the_same_result_repeatedly() -> None:
    for operator_name, operator in iterator_generating_operators:
        original_iterator = collection_10_ints()
        result_iterator = operator(original_iterator)
        length_of_iterable_returned_by_operator = sum(1 for _ in result_iterator)
        length_of_iterator_returned_by_operator_on_second_iteration = sum(1 for _ in result_iterator)
        assert length_of_iterable_returned_by_operator != 0, f"Operator {operator_name} did not return any elements"
        assert length_of_iterator_returned_by_operator_on_second_iteration == length_of_iterable_returned_by_operator, f"Operator {operator_name} consumed elements"
        assert original_iterator.qcount() == 10, f"Operator {operator_name} mutated source collection"

def test_all_scalar_or_action_operators_when_called_on_generator_backed_iterable_consume_elements() -> None:
    for operator_name, operator in scalar_or_action_operators:
        original_iterator = generate_10_ints()
        operator(original_iterator)
        assert original_iterator.qcount() != 10, f"Operator {operator_name} consumed no elements"

def test_no_scalar_or_action_operators_when_called_on_collection_backed_iterator_consume_elements() -> None:
    for operator_name, operator in scalar_or_action_operators:
        original_iterator = collection_10_ints()
        operator(original_iterator)
        assert original_iterator.qcount() == 10, f"Operator {operator_name} mutated source collection"
</file>

<file path="src/queryablecollections/_private_implementation_details/immutable_sequence.py">
from __future__ import annotations

from collections.abc import Sequence
from typing import overload, override


class ImmutableSequence[TItem](Sequence[TItem]):
    __slots__: tuple[str, ...] = ("_items",)
    def __init__(self, items: Sequence[TItem] = ()) -> None:
        self._items: Sequence[TItem] = items  # Direct reference - no copying

    @override
    def __len__(self) -> int:
        return len(self._items)

    @overload
    def __getitem__(self, index: int) -> TItem: ...

    @overload
    def __getitem__(self, index: slice) -> ImmutableSequence[TItem]: ...

    @override
    def __getitem__(self, index: int | slice) -> TItem | ImmutableSequence[TItem]:
        if isinstance(index, slice):
            return ImmutableSequence(self._items[index])
        return self._items[index]
</file>

<file path="src/queryablecollections/_private_implementation_details/operations/__init__.py">
from __future__ import annotations

from .filtering import distinct, distinct_by, of_type, skip, skip_last, take, take_last, take_while, where, where_not_none
from .functional import for_each, pipe
from .grouping import group_by_q
from .ordering import ordered, reverse_lazy, sort_by_instructions
from .scalars import all, any, count
from .single_elements import element_at, element_at_or_none, first, first_or_none, single, single_or_none
from .transforms import as_decimals, as_floats, as_fractions, as_ints, concat, flatten, join, select, select_many, to_dict
from .zip import zip, zip2, zip3

__all__ = [
        "scalars",
        "filtering",
        "grouping",
        "ordering",
        "single_elements",
        "transforms",
        "functional",
        "zip",
        "zip2",
        "zip3",
        "distinct",
        "distinct_by",
        "where",
        "where_not_none",
        "take_while",
        "take",
        "take_last",
        "skip",
        "skip_last",
        "of_type",
        "for_each",
        "pipe",
        "group_by_q",
        "reverse_lazy",
        "sort_by_instructions",
        "ordered",
        "all",
        "any",
        "count",
        "first",
        "first_or_none",
        "single",
        "single_or_none",
        "element_at",
        "element_at_or_none",
        "concat",
        "select",
        "flatten",
        "select_many",
        "to_dict",
        "as_ints",
        "as_floats",
        "as_fractions",
        "as_decimals",
        "join"
]
</file>

<file path="src/queryablecollections/_private_implementation_details/operations/filtering.py">
from __future__ import annotations

import itertools
from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Predicate, Selector
    from queryablecollections.q_iterable import QIterable

def distinct[TItem](self: Iterable[TItem]) -> Iterable[TItem]:
    return dict.fromkeys(self)  # highly optimized and guaranteed to keep ordering

def distinct_by[TItem, TKey](self: Iterable[TItem], key_selector: Selector[TItem, TKey]) -> Iterable[TItem]:
    seen: dict[TKey, TItem] = {}
    for item in self:
        key = key_selector(item)
        if key not in seen:
            seen[key] = item
    return seen.values()


def where[TItem](self: Iterable[TItem], predicate: Predicate[TItem]) -> Iterable[TItem]:
    return filter(predicate, self)

def _item_not_none(value: object) -> bool: return value is not None  # pyright: ignore [reportInvalidTypeVarUse]
def where_not_none[TItem](self: Iterable[TItem]) -> Iterable[TItem]:
    return where(self, _item_not_none)

def take_while[TItem](self: Iterable[TItem], predicate: Predicate[TItem]) -> Iterable[TItem]:
    return itertools.takewhile(predicate, self)

def take[TItem](self: Iterable[TItem], count: int) -> Iterable[TItem]:
    if count <= 0: return C.empty_iterable()
    return itertools.islice(self, count)

def take_last[TItem](self: Iterable[TItem], count: int) -> Iterable[TItem]:
    def internal_take_last() -> Iterable[TItem]:
        if count <= 0: return ()
        items = list(self)
        if count >= len(items):
            return items
        return items[-count:]
    return C.lazy_iterable(internal_take_last)


def skip[TItem](self: Iterable[TItem], count: int) -> Iterable[TItem]:
    if count <= 0: return self
    return itertools.islice(self, count, None)

def skip_last[TItem](self: Iterable[TItem], count: int) -> Iterable[TItem]:
    def internal_skip_last() -> Iterable[TItem]:
        if count <= 0: return self
        items = list(self)
        if count >= len(items):
            return C.empty_iterable()
        return items[:-count]
    return C.lazy_iterable(internal_skip_last)

class _TypeTester:
    def __init__(self, type_: type) -> None:
        self.type_:type = type_
    def __call__(self, value: object) -> bool:
        return isinstance(value, self.type_)

def of_type[TItem, TResult](self: QIterable[TItem], type_: type[TResult]) -> Iterable[TResult]:
    return self.where(_TypeTester(type_)).cast.to(type_)
</file>

<file path="src/queryablecollections/_private_implementation_details/operations/functional.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from queryablecollections._private_implementation_details.type_aliases import Action1, Selector
    from queryablecollections.q_iterable import QIterable

def for_each[TItem](self: QIterable[TItem], action: Action1[TItem]) -> QIterable[TItem]:
    for item in self: action(item)
    return self

def pipe[TItem, TReturn](self: QIterable[TItem], action: Selector[QIterable[TItem], TReturn]) -> TReturn:
    return action(self)
</file>

<file path="src/queryablecollections/_private_implementation_details/operations/grouping.py">
from __future__ import annotations

from typing import TYPE_CHECKING

# noinspection PyPep8Naming
from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Selector
    from queryablecollections.collections.q_default_dict import QDefaultDict
    from queryablecollections.q_grouping import QGrouping
    from queryablecollections.q_iterable import QIterable

# pycharm is wrong. Pyright sees no problem
# noinspection PyTypeHints
def _group_by[TElement, TKey](self: Iterable[TElement], key_selector: Selector[TElement, TKey]) -> Iterable[QGrouping[TKey, TElement]]:
    """Groups the elements of a sequence according to a specified key selector function."""
    from queryablecollections.collections.q_list import QList
    groups: QDefaultDict[TKey, QList[TElement]] = C.default_dict(QList[TElement])

    for item in self:
        groups[key_selector(item)].append(item)

    return groups.qitems().select(C.grouping)

# pycharm is wrong. Pyright sees no problem
# noinspection PyTypeHints
def _group_by_with_element_selector[TSourceElement, TKey, TGroupElement](self: Iterable[TSourceElement],
                                                                         key_selector: Selector[TSourceElement, TKey],
                                                                         element_selector: Selector[TSourceElement, TGroupElement]) -> Iterable[QGrouping[TKey, TGroupElement]]:
    """Groups the elements of a sequence according to key and element selector functions."""
    from queryablecollections.collections.q_list import QList
    groups: QDefaultDict[TKey, QList[TGroupElement]] = C.default_dict(QList[TGroupElement])

    for item in self:
        groups[key_selector(item)].append(element_selector(item))

    return groups.qitems().select(C.grouping)

def group_by_q[TItem, TKey, TElement](self: QIterable[TItem], key: Selector[TItem, TKey], element: Selector[TItem, TElement] | None = None) -> QIterable[QGrouping[TKey, TItem]] | QIterable[QGrouping[TKey, TElement]]:
    return (C.lazy_iterable(lambda: _group_by(self, key))
            if element is None
            else C.lazy_iterable(lambda: _group_by_with_element_selector(self, key, element)))
</file>

<file path="src/queryablecollections/_private_implementation_details/operations/ordering.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Selector

def reverse_lazy[TItem](self: Iterable[TItem]) -> Iterable[TItem]:
    return reversed(list(self))

class SortInstruction[TItem]:
    __slots__: tuple[str, ...] = ("key_selector", "descending")
    def __init__(self, key_selector: Selector[TItem, SupportsRichComparison], descending: bool) -> None:
        self.key_selector: Selector[TItem, SupportsRichComparison] = key_selector
        self.descending: bool = descending

def sort_by_instructions[TItem](self: Iterable[TItem], sort_instructions: list[SortInstruction[TItem]]) -> Iterable[TItem]:
    items = list(self)
    for instruction in sort_instructions:  # the official documentation recommends multiple sort passes. Unless proven to perform badly in the common usage scenarios by actual performance testing, let's keep it simple: https://docs.python.org/3/howto/sorting.html
        items.sort(key=instruction.key_selector, reverse=instruction.descending)

    yield from items

def ordered[TElement: SupportsRichComparison](self: Iterable[TElement]) -> Iterable[TElement]:
    return sorted(self)
</file>

<file path="src/queryablecollections/_private_implementation_details/operations/scalars.py">
from __future__ import annotations

import builtins
from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details.operations.transforms import select

if TYPE_CHECKING:
    from queryablecollections._private_implementation_details.type_aliases import Predicate
    from queryablecollections.q_iterable import QIterable

def all[TItem](self: QIterable[TItem], predicate: Predicate[TItem]) -> bool:
    return builtins.all(select(self, predicate))  # use named functions over lambdas where possible because: https://switowski.com/blog/map-vs-list-comprehension/

def any[TItem](self: QIterable[TItem], predicate: Predicate[TItem] | None = None) -> bool:
    if predicate is None:
        iterator = iter(self)
        try:
            next(iterator)
            return True  # noqa: TRY300
        except StopIteration:
            return False
    return builtins.any(select(self, predicate, ))

def count[TItem](self: QIterable[TItem], predicate: Predicate[TItem] | None = None) -> int:
    if predicate is not None: return self.where(predicate).qcount()
    return self._optimized_length()  # pyright: ignore [reportPrivateUsage]
</file>

<file path="src/queryablecollections/_private_implementation_details/operations/single_elements.py">
from __future__ import annotations

import itertools
from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details.operations.filtering import where
from queryablecollections.q_errors import EmptyIterableError, InvalidOperationError

if TYPE_CHECKING:
    from collections.abc import Iterable

    from queryablecollections._private_implementation_details.type_aliases import Predicate

def first[TItem](self: Iterable[TItem], predicate: Predicate[TItem] | None = None) -> TItem:
    if predicate is not None:
        self = where(self, predicate)
    try:
        return next(iter(self))
    except StopIteration:
        raise EmptyIterableError() from None

def first_or_none[TItem](self: Iterable[TItem], predicate: Predicate[TItem] | None = None) -> TItem | None:
    if predicate is not None:
        self = where(self, predicate)
    try:
        return next(iter(self))
    except StopIteration:
        return None

def single[TItem](self: Iterable[TItem], predicate: Predicate[TItem] | None = None) -> TItem:
    if predicate is not None:
        self = where(self, predicate)
    iterator = iter(self)
    try:
        first_element = next(iterator)
    except StopIteration:
        raise EmptyIterableError() from None

    try:
        next(iterator)  # Check if there's a second element
        raise InvalidOperationError("Sequence contains more than one element")
    except StopIteration:
        return first_element

def single_or_none[TItem](self: Iterable[TItem], predicate: Predicate[TItem] | None = None) -> TItem | None:
    if predicate is not None:
        self = where(self, predicate)
    iterator = iter(self)
    try:
        first_element = next(iterator)
    except StopIteration:
        return None

    try:
        next(iterator)  # Check if there's a second element
        raise InvalidOperationError("Sequence contains more than one element")
    except StopIteration:
        return first_element

def element_at[TItem](self: Iterable[TItem], index: int) -> TItem:
    try:
        return next(itertools.islice(self, index, index + 1))
    except StopIteration:
        raise IndexError(f"Index {index} was outside the bounds of the collection.") from None

def element_at_or_none[TItem](self: Iterable[TItem], index: int) -> TItem | None:
    return next(itertools.islice(self, index, index + 1), None)
</file>

<file path="src/queryablecollections/_private_implementation_details/operations/transforms.py">
from __future__ import annotations

import itertools
from collections.abc import Iterable
from typing import TYPE_CHECKING, cast

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C
from queryablecollections.q_errors import ArgumentNoneError

if TYPE_CHECKING:
    from collections.abc import Callable
    from decimal import Decimal
    from fractions import Fraction

    from queryablecollections._private_implementation_details.type_aliases import Selector
    from queryablecollections.collections.numeric.q_decimal_types import QDecimalIterable
    from queryablecollections.collections.numeric.q_float_types import QFloatIterable
    from queryablecollections.collections.numeric.q_fraction_types import QFractionIterable
    from queryablecollections.collections.numeric.q_int_types import QIntIterable
    from queryablecollections.collections.q_dict import QDict
    from queryablecollections.q_iterable import QIterable

def concat[T](self: Iterable[T], *others: Iterable[T]) -> Iterable[T]:
    return itertools.chain(self, *others)

def select[T, TResult](self: QIterable[T], selector: Selector[T, TResult]) -> QIterable[TResult]:
    return C.lazy_iterable(lambda: map(selector, self))

def flatten[T](self: QIterable[Iterable[T]]) -> QIterable[T]:
    return C.lazy_iterable(lambda: itertools.chain.from_iterable(self))

def select_many[T, TSubItem](self: QIterable[T], selector: Selector[T, Iterable[TSubItem]]) -> QIterable[TSubItem]:
    return flatten(select(self, selector))

def to_dict[T, TKey, TValue](self: QIterable[T], key_selector: Selector[T, TKey] | None = None, value_selector: Selector[T, TValue] | None = None) -> QDict[TKey, TValue]:
    if key_selector is not None:
        if value_selector is None: raise ArgumentNoneError("value_selector")
        return C.dict((key_selector(item), value_selector(item)) for item in self)

    if value_selector is not None: raise ArgumentNoneError("key_selector")

    # Assume self is a sequence of tuples. Unless the user is working without pyright and/or ignoring the errors it will be
    return C.dict(cast(Iterable[tuple[TKey, TValue]], self))

def as_ints(self: QIterable[int]) -> QIntIterable: return C.int_iterable(lambda: self)
def as_floats(self: QIterable[float]) -> QFloatIterable: return C.float_iterable(lambda: self)
def as_fractions(self: QIterable[Fraction]) -> QFractionIterable: return C.fraction_iterable(lambda: self)
def as_decimals(self: QIterable[Decimal]) -> QDecimalIterable: return C.decimal_iterable(lambda: self)

def join[TOuter, TInner, TKey, TResult](
        outer: QIterable[TOuter],
        inner: Iterable[TInner],
        outer_key_selector: Selector[TOuter, TKey],
        inner_key_selector: Selector[TInner, TKey],
        result_selector: Callable[[TOuter, TInner], TResult]
) -> QIterable[TResult]:
    def inner_join() -> Iterable[TResult]:
        inner_lookup: dict[TKey, list[TInner]] = {}
        for inner_item in inner:
            key = inner_key_selector(inner_item)
            if key not in inner_lookup:
                inner_lookup[key] = []
            inner_lookup[key].append(inner_item)

        # For each outer element, find matching inner elements and yield results
        for outer_item in outer:
            outer_key = outer_key_selector(outer_item)
            if outer_key in inner_lookup:
                for inner_item in inner_lookup[outer_key]:
                    yield result_selector(outer_item, inner_item)

    return C.lazy_iterable(inner_join)
</file>

<file path="src/queryablecollections/_private_implementation_details/operations/zip.py">
from __future__ import annotations

import builtins
from typing import TYPE_CHECKING

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C

if TYPE_CHECKING:
    from collections.abc import Callable, Iterable

    from queryablecollections.q_iterable import QIterable

def zip[T, T2, TOut](first: QIterable[T], second: Iterable[T2], select: Callable[[T, T2], TOut]) -> QIterable[TOut]:
    def inner_zip() -> Iterable[TOut]:
        for first_item, second_item in builtins.zip(first, second, strict=False):
            yield select(first_item, second_item)
    return C.lazy_iterable(inner_zip)

def zip2[T, T2, T3, TOut](first: QIterable[T], second: Iterable[T2], third: Iterable[T3], select: Callable[[T, T2, T3], TOut]) -> QIterable[TOut]:
    def inner_zip() -> Iterable[TOut]:
        for first_item, second_item, third_item in builtins.zip(first, second, third, strict=False):
            yield select(first_item, second_item, third_item)
    return C.lazy_iterable(inner_zip)

def zip3[T, T2, T3, T4, TOut](first: QIterable[T], second: Iterable[T2], third: Iterable[T3], fourth: Iterable[T4], select: Callable[[T, T2, T3, T4], TOut]) -> QIterable[TOut]:
    def inner_zip() -> Iterable[TOut]:
        for first_item, second_item, third_item, fourth_item in builtins.zip(first, second, third, fourth, strict=False):
            yield select(first_item, second_item, third_item, fourth_item)
    return C.lazy_iterable(inner_zip)
</file>

<file path="src/queryablecollections/_private_implementation_details/q_lazy_iterable.py">
from __future__ import annotations

from typing import TYPE_CHECKING, override

from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from collections.abc import Iterable, Iterator

    from queryablecollections._private_implementation_details.type_aliases import Func


class QLazyIterableImplementation[TItem](QIterable[TItem]):
    __slots__: tuple[str, ...] = ("_factory",)
    def __init__(self, iterable_factory: Func[Iterable[TItem]]) -> None:
        self._factory: Func[Iterable[TItem]] = iterable_factory

    @override
    def __iter__(self) -> Iterator[TItem]: yield from self._factory()

class QCachingIterableImplementation[TItem](QIterable[TItem]):
    __slots__: tuple[str, ...] = ("_iterable",)
    def __init__(self, iterable: Iterable[TItem]) -> None:
        self._iterable: Iterable[TItem] = iterable

    @override
    def __iter__(self) -> Iterator[TItem]:
        yield from iter(self._iterable)
</file>

<file path="src/queryablecollections/_private_implementation_details/q_zero_overhead_collection_contructors.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable
    from decimal import Decimal
    from fractions import Fraction

    from queryablecollections._private_implementation_details.operations.ordering import SortInstruction
    from queryablecollections._private_implementation_details.type_aliases import Func
    from queryablecollections.collections.numeric.q_decimal_types import QDecimalIterable
    from queryablecollections.collections.numeric.q_float_types import QFloatIterable
    from queryablecollections.collections.numeric.q_fraction_types import QFractionIterable
    from queryablecollections.collections.numeric.q_int_types import QIntIterable
    from queryablecollections.collections.q_default_dict import QDefaultDict
    from queryablecollections.collections.q_dict import QDict
    from queryablecollections.collections.q_frozen_set import QFrozenSet
    from queryablecollections.collections.q_list import QList
    from queryablecollections.collections.q_sequence import QSequence
    from queryablecollections.collections.q_set import QSet
    from queryablecollections.q_cast import QCast
    from queryablecollections.q_grouping import QGrouping
    from queryablecollections.q_iterable import QIterable
    from queryablecollections.q_ordered_iterable import QOrderedIterable


class ZeroImportOverheadConstructors:
    """This class contains static methods that are used to construct the collection classes with zero import overhead and without the need to complicate methods thoughouht the library by having to import these classes within functions in order to avoid circular imports."""
    @staticmethod
    def list_[TItem](iterable: Iterable[TItem]) -> QList[TItem]:
        from queryablecollections.collections.q_list import QList
        ZeroImportOverheadConstructors.list_ = QList  # replace this method with a direct call so that future calls have zero import overhead
        return ZeroImportOverheadConstructors.list_(iterable)  # use the new version to prove from the very first call that it works

    @staticmethod
    def sequence[TItem](iterable: Iterable[TItem]) -> QSequence[TItem]:
        from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
        ZeroImportOverheadConstructors.sequence = QImmutableSequence  # replace this method with a direct call so that future calls have zero import overhead
        return ZeroImportOverheadConstructors.sequence(iterable)  # use the new version to prove from the very first call that it works

    @staticmethod
    def set[TItem](iterable: Iterable[TItem]) -> QSet[TItem]:
        from queryablecollections.collections.q_set import QSet
        ZeroImportOverheadConstructors.set = QSet  # replace this method with a direct call so that future calls have zero import overhead
        return ZeroImportOverheadConstructors.set(iterable)  # use the new version to prove from the very first call that it works

    @staticmethod
    def frozen_set[TItem](iterable: Iterable[TItem]) -> QFrozenSet[TItem]:
        from queryablecollections.collections.q_frozen_set import QFrozenSet
        ZeroImportOverheadConstructors.frozen_set = QFrozenSet  # replace this method with a direct call so that future calls have zero import overhead
        return ZeroImportOverheadConstructors.frozen_set(iterable)  # use the new version to prove from the very first call that it works

    @staticmethod
    def cast[TItem](qiterable: QIterable[TItem]) -> QCast[TItem]:
        from queryablecollections.q_cast import QCast
        ZeroImportOverheadConstructors.cast = QCast  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.cast(qiterable)  # use the new version to prove from the very first call that it works

    @staticmethod
    def empty_iterable[TItem]() -> QIterable[TItem]:  # pyright: ignore [reportInvalidTypeVarUse]
        empty_iterable = ZeroImportOverheadConstructors.lazy_iterable(lambda: ())
        def get_empty() -> QIterable[TItem]: return empty_iterable  # pyright: ignore [reportReturnType]
        ZeroImportOverheadConstructors.empty_iterable = get_empty  # replace this method itself with  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.empty_iterable()

    @staticmethod
    def lazy_iterable[TItem](iterable_factory: Func[Iterable[TItem]]) -> QIterable[TItem]:
        from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
        ZeroImportOverheadConstructors.lazy_iterable = QLazyIterableImplementation  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.lazy_iterable(iterable_factory)  # use the new version to prove from the very first call that it works

    @staticmethod
    def caching_iterable[TItem](iterable: Iterable[TItem]) -> QIterable[TItem]:
        from queryablecollections._private_implementation_details.q_lazy_iterable import QCachingIterableImplementation
        ZeroImportOverheadConstructors.caching_iterable = QCachingIterableImplementation  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.caching_iterable(iterable)  # use the new version to prove from the very first call that it works

    @staticmethod
    def ordered_iterable[TItem](factory: Func[QIterable[TItem]], sorting_instructions: list[SortInstruction[TItem]]) -> QOrderedIterable[TItem]:
        from queryablecollections.q_ordered_iterable import QOrderedIterable
        ZeroImportOverheadConstructors.ordered_iterable = QOrderedIterable  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.ordered_iterable(factory, sorting_instructions)  # use the new version to prove from the very first call that it works

    @staticmethod
    def grouping[TKey, TItem](values: tuple[TKey, QList[TItem]]) -> QGrouping[TKey, TItem]:
        from queryablecollections.q_grouping import QGrouping
        ZeroImportOverheadConstructors.grouping = QGrouping  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.grouping(values)  # use the new version to prove from the very first call that it works

    @staticmethod
    def default_dict[TKey, TElement](factory: Func[TElement]) -> QDefaultDict[TKey, TElement]:  # pyright: ignore [reportInvalidTypeVarUse]
        from queryablecollections.collections.q_default_dict import QDefaultDict
        ZeroImportOverheadConstructors.default_dict = QDefaultDict  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.default_dict(factory)

    @staticmethod
    def dict[TKey, TValue](elements: Iterable[tuple[TKey, TValue]]) -> QDict[TKey, TValue]:
        from queryablecollections.collections.q_dict import QDict
        ZeroImportOverheadConstructors.dict = QDict  # replace this method with a direct call so that future calls have zero import overhead
        return ZeroImportOverheadConstructors.dict(elements)  # use the new version to prove from the very first call that it works

    @staticmethod
    def int_iterable(factory: Func[Iterable[int]]) -> QIntIterable:  # pyright: ignore [reportInvalidTypeVarUse]
        from queryablecollections.collections.numeric.q_int_types import QIntIterableImplementation
        ZeroImportOverheadConstructors.int_iterable = QIntIterableImplementation  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.int_iterable(factory)  # use the new version to prove from the very first call that it works

    @staticmethod
    def float_iterable(factory: Func[Iterable[float]]) -> QFloatIterable:  # pyright: ignore [reportInvalidTypeVarUse]
        from queryablecollections.collections.numeric.q_float_types import QFloatIterableImplementation
        ZeroImportOverheadConstructors.float_iterable = QFloatIterableImplementation  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.float_iterable(factory)  # use the new version to prove from the very first call that it works

    @staticmethod
    def fraction_iterable(factory: Func[Iterable[Fraction]]) -> QFractionIterable:  # pyright: ignore [reportInvalidTypeVarUse]
        from queryablecollections.collections.numeric.q_fraction_types import QFractionIterableImplementation
        ZeroImportOverheadConstructors.fraction_iterable = QFractionIterableImplementation  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.fraction_iterable(factory)  # use the new version to prove from the very first call that it works

    @staticmethod
    def decimal_iterable(factory: Func[Iterable[Decimal]]) -> QDecimalIterable:  # pyright: ignore [reportInvalidTypeVarUse]
        from queryablecollections.collections.numeric.q_decimal_types import QDecimalIterableImplementation
        ZeroImportOverheadConstructors.decimal_iterable = QDecimalIterableImplementation  # replace this method with a direct call so that future calls have zero import overhead  # pyright: ignore [reportAttributeAccessIssue]
        return ZeroImportOverheadConstructors.decimal_iterable(factory)  # use the new version to prove from the very first call that it works
</file>

<file path="src/queryablecollections/_private_implementation_details/type_aliases.py">
from __future__ import annotations

from collections.abc import Callable

type Action = Callable[[], None]
type Action1[TIn] = Callable[[TIn], None]
type Action2[TIn, TIn2] = Callable[[TIn, TIn2], None]
type Action3[TIn, TIn2, TIn3] = Callable[[TIn, TIn2, TIn3], None]
type Action4[TIn, TIn2, TIn3, TIn4] = Callable[[TIn, TIn2, TIn3, TIn4], None]

type Func[TOut] = Callable[[], TOut]
type Func1[TIn, TOut] = Callable[[TIn], TOut]
type Func2[TIn, TIn2, TOut] = Callable[[TIn, TIn2], TOut]
type Func3[TIn, TIn2, TIn3, TOut] = Callable[[TIn, TIn2, TIn3], TOut]
type Func4[TIn, TIn2, TIn3, TIn4, TOut] = Callable[[TIn, TIn2, TIn3, TIn4], TOut]


type Predicate[TIn] = Callable[[TIn], bool]
type Selector[TIn, TOut] = Callable[[TIn], TOut]
</file>

<file path="src/queryablecollections/collections/numeric/q_decimal_types.py">
from __future__ import annotations

import statistics
from abc import ABC
from decimal import Decimal
from typing import TYPE_CHECKING, cast, override

from queryablecollections._private_implementation_details.operations.ordering import SortInstruction
from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
from queryablecollections.collections.q_frozen_set import QFrozenSet
from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList
from queryablecollections.collections.q_set import QSet
from queryablecollections.q_errors import EmptyIterableError
from queryablecollections.q_iterable import QIterable
from queryablecollections.q_ordered_iterable import QOrderedIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Func, Predicate, Selector

class QDecimalIterable(QIterable[Decimal], ABC):
    __slots__: tuple[str, ...] = ()

    def sum(self) -> Decimal: return sum(self, Decimal(0))

    def min(self) -> Decimal:
        try:
            return min(self)
        except ValueError:
            raise EmptyIterableError() from None

    def max(self) -> Decimal:
        try:
            return max(self)
        except ValueError:
            raise EmptyIterableError() from None

    def min_or_default(self) -> Decimal: return min(self) if self.any() else Decimal(0)
    def max_or_default(self) -> Decimal: return max(self) if self.any() else Decimal(0)
    def average(self) -> Decimal: return statistics.mean(self._assert_not_empty())
    def average_or_default(self) -> Decimal: return statistics.mean(self) if self.any() else Decimal(0)

    @override
    def _lazy(self, factory: Func[Iterable[Decimal]]) -> QDecimalIterable: return QDecimalIterableImplementation(factory)
    @override
    def _order_by(self, key_selector: Selector[Decimal, SupportsRichComparison], descending: bool) -> QOrderedIterable[Decimal]:
        return QDecimalOrderedIterable(lambda: self, [SortInstruction(key_selector, descending)])
    def _selfcast(self, iterable: QIterable[Decimal]) -> QDecimalIterable: return cast(QDecimalIterable, iterable)
    def _selfcast_ordered(self, iterable: QOrderedIterable[Decimal]) -> QDecimalOrderedIterable: return cast(QDecimalOrderedIterable, iterable)

    # region override methods so that typecheckers know that we actually return QDecimalIterables now, not QIterable[Decimal]
    # call the base method to eliminate code duplication. The base class will call lazy from just above, so it is already the correct type
    @override
    def where(self, predicate: Predicate[Decimal]) -> QDecimalIterable: return self._selfcast(super().where(predicate))
    @override
    def where_not_none(self) -> QDecimalIterable: return self._selfcast(super().where_not_none())
    @override
    def distinct(self) -> QDecimalIterable: return self._selfcast(super().distinct())
    @override
    def distinct_by[TKey](self, key_selector: Selector[Decimal, TKey]) -> QDecimalIterable: return self._selfcast(super().distinct_by(key_selector))
    @override
    def take(self, count: int) -> QDecimalIterable: return self._selfcast(super().take(count))
    @override
    def take_while(self, predicate: Predicate[Decimal]) -> QDecimalIterable: return self._selfcast(super().take_while(predicate))
    @override
    def take_last(self, count: int) -> QDecimalIterable: return self._selfcast(super().take_last(count))
    @override
    def skip(self, count: int) -> QDecimalIterable: return self._selfcast(super().skip(count))
    @override
    def skip_last(self, count: int) -> QDecimalIterable: return self._selfcast(super().skip_last(count))
    @override
    def reversed(self) -> QDecimalIterable: return self._selfcast(super().reversed())

    @override
    def concat(self, *others: Iterable[Decimal]) -> QDecimalIterable: return self._selfcast(super().concat(*others))

    @override
    def ordered(self) -> QDecimalIterable: return self._selfcast(super().ordered())
    @override
    def order_by(self, key_selector: Selector[Decimal, SupportsRichComparison]) -> QDecimalOrderedIterable: return self._selfcast_ordered(super().order_by(key_selector))
    @override
    def order_by_descending(self, key_selector: Selector[Decimal, SupportsRichComparison]) -> QDecimalOrderedIterable: return self._selfcast_ordered(super().order_by_descending(key_selector))
    # endregion

    @override
    def to_list(self) -> QDecimalList: return QDecimalList(self)

    @override
    def to_sequence(self) -> QDecimalSequence: return QDecimalSequence(self)

    @override
    def to_set(self) -> QDecimalSet: return QDecimalSet(self)

    @override
    def to_frozenset(self) -> QDecimalFrozenSet: return QDecimalFrozenSet(self)

class QDecimalIterableImplementation(QLazyIterableImplementation[Decimal], QDecimalIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[Decimal]]) -> None:
        super().__init__(factory)

class QDecimalOrderedIterable(QOrderedIterable[Decimal], QDecimalIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[Decimal]], sorting_instructions: list[SortInstruction[Decimal]]) -> None:
        super().__init__(factory, sorting_instructions)

class QDecimalList(QList[Decimal], QDecimalIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[Decimal] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QDecimalIterable: return QDecimalIterable.reversed(self)

class QDecimalSet(QSet[Decimal], QDecimalIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[Decimal] = ()) -> None:
        super().__init__(iterable)

class QDecimalFrozenSet(QFrozenSet[Decimal], QDecimalIterable):
    __slots__: tuple[str, ...] = ()
    def __new__(cls, iterable: Iterable[Decimal] = ()) -> QDecimalFrozenSet:
        return super().__new__(cls, iterable)  # pyright: ignore [reportReturnType]

class QDecimalSequence(QImmutableSequence[Decimal], QDecimalIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[Decimal] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QDecimalIterable: return QDecimalIterable.reversed(self)
</file>

<file path="src/queryablecollections/collections/numeric/q_float_types.py">
from __future__ import annotations

import statistics
from abc import ABC
from typing import TYPE_CHECKING, cast, override

from queryablecollections._private_implementation_details.operations.ordering import SortInstruction
from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
from queryablecollections.collections.q_frozen_set import QFrozenSet
from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList
from queryablecollections.collections.q_set import QSet
from queryablecollections.q_errors import EmptyIterableError
from queryablecollections.q_iterable import QIterable
from queryablecollections.q_ordered_iterable import QOrderedIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Func, Predicate, Selector

class QFloatIterable(QIterable[float], ABC):
    __slots__: tuple[str, ...] = ()

    def sum(self) -> float: return sum(self)

    def min(self) -> float:
        try:
            return min(self)
        except ValueError:
            raise EmptyIterableError() from None

    def max(self) -> float:
        try:
            return max(self)
        except ValueError:
            raise EmptyIterableError() from None

    def min_or_default(self) -> float: return min(self) if self.any() else 0.0
    def max_or_default(self) -> float: return max(self) if self.any() else 0.0
    def average(self) -> float: return statistics.mean(self._assert_not_empty())
    def average_or_default(self) -> float: return statistics.mean(self) if self.any() else 0.0

    @override
    def _lazy(self, factory: Func[Iterable[float]]) -> QFloatIterable: return QFloatIterableImplementation(factory)
    @override
    def _order_by(self, key_selector: Selector[float, SupportsRichComparison], descending: bool) -> QOrderedIterable[float]:
        return QFloatOrderedIterable(lambda: self, [SortInstruction(key_selector, descending)])
    def _selfcast(self, iterable: QIterable[float]) -> QFloatIterable: return cast(QFloatIterable, iterable)
    def _selfcast_ordered(self, iterable: QOrderedIterable[float]) -> QFloatOrderedIterable: return cast(QFloatOrderedIterable, iterable)

    # region override methods so that typecheckers know that we actually return QFloatIterables now, not QIterable[float]
    # call the base method to eliminate code duplication. The base class will call lazy from just above, so it is already the correct type
    @override
    def where(self, predicate: Predicate[float]) -> QFloatIterable: return self._selfcast(super().where(predicate))
    @override
    def where_not_none(self) -> QFloatIterable: return self._selfcast(super().where_not_none())
    @override
    def distinct(self) -> QFloatIterable: return self._selfcast(super().distinct())
    @override
    def distinct_by[TKey](self, key_selector: Selector[float, TKey]) -> QFloatIterable: return self._selfcast(super().distinct_by(key_selector))
    @override
    def take(self, count: int) -> QFloatIterable: return self._selfcast(super().take(count))
    @override
    def take_while(self, predicate: Predicate[float]) -> QFloatIterable: return self._selfcast(super().take_while(predicate))
    @override
    def take_last(self, count: int) -> QFloatIterable: return self._selfcast(super().take_last(count))
    @override
    def skip(self, count: int) -> QFloatIterable: return self._selfcast(super().skip(count))
    @override
    def skip_last(self, count: int) -> QFloatIterable: return self._selfcast(super().skip_last(count))
    @override
    def reversed(self) -> QFloatIterable: return self._selfcast(super().reversed())

    @override
    def concat(self, *others: Iterable[float]) -> QFloatIterable: return self._selfcast(super().concat(*others))

    @override
    def ordered(self) -> QFloatIterable: return self._selfcast(super().ordered())
    @override
    def order_by(self, key_selector: Selector[float, SupportsRichComparison]) -> QFloatOrderedIterable: return self._selfcast_ordered(super().order_by(key_selector))
    @override
    def order_by_descending(self, key_selector: Selector[float, SupportsRichComparison]) -> QFloatOrderedIterable: return self._selfcast_ordered(super().order_by_descending(key_selector))
    # endregion

    @override
    def to_list(self) -> QFloatList: return QFloatList(self)

    @override
    def to_sequence(self) -> QFloatSequence: return QFloatSequence(self)

    @override
    def to_set(self) -> QFloatSet: return QFloatSet(self)

    @override
    def to_frozenset(self) -> QFloatFrozenSet: return QFloatFrozenSet(self)

class QFloatIterableImplementation(QLazyIterableImplementation[float], QFloatIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[float]]) -> None:
        super().__init__(factory)

class QFloatOrderedIterable(QOrderedIterable[float], QFloatIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[float]], sorting_instructions: list[SortInstruction[float]]) -> None:
        super().__init__(factory, sorting_instructions)

class QFloatList(QList[float], QFloatIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[float] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QFloatIterable: return QFloatIterable.reversed(self)

class QFloatSet(QSet[float], QFloatIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[float] = ()) -> None:
        super().__init__(iterable)

class QFloatFrozenSet(QFrozenSet[float], QFloatIterable):
    __slots__: tuple[str, ...] = ()
    def __new__(cls, iterable: Iterable[float] = ()) -> QFloatFrozenSet:
        return super().__new__(cls, iterable)  # pyright: ignore [reportReturnType]

class QFloatSequence(QImmutableSequence[float], QFloatIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[float] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QFloatIterable: return QFloatIterable.reversed(self)
</file>

<file path="src/queryablecollections/collections/numeric/q_fraction_types.py">
from __future__ import annotations

import statistics
from abc import ABC
from fractions import Fraction
from typing import TYPE_CHECKING, cast, override

from queryablecollections._private_implementation_details.operations.ordering import SortInstruction
from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
from queryablecollections.collections.q_frozen_set import QFrozenSet
from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList
from queryablecollections.collections.q_set import QSet
from queryablecollections.q_errors import EmptyIterableError
from queryablecollections.q_iterable import QIterable
from queryablecollections.q_ordered_iterable import QOrderedIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Func, Predicate, Selector

class QFractionIterable(QIterable[Fraction], ABC):
    __slots__: tuple[str, ...] = ()

    def sum(self) -> Fraction: return sum(self, Fraction(0))

    def min(self) -> Fraction:
        try:
            return min(self)
        except ValueError:
            raise EmptyIterableError() from None

    def max(self) -> Fraction:
        try:
            return max(self)
        except ValueError:
            raise EmptyIterableError() from None

    def min_or_default(self) -> Fraction: return min(self) if self.any() else Fraction(0)
    def max_or_default(self) -> Fraction: return max(self) if self.any() else Fraction(0)
    def average(self) -> Fraction: return statistics.mean(self._assert_not_empty())
    def average_or_default(self) -> Fraction: return statistics.mean(self) if self.any() else Fraction(0)

    @override
    def _lazy(self, factory: Func[Iterable[Fraction]]) -> QFractionIterable: return QFractionIterableImplementation(factory)
    @override
    def _order_by(self, key_selector: Selector[Fraction, SupportsRichComparison], descending: bool) -> QOrderedIterable[Fraction]:
        return QFractionOrderedIterable(lambda: self, [SortInstruction(key_selector, descending)])
    def _selfcast(self, iterable: QIterable[Fraction]) -> QFractionIterable: return cast(QFractionIterable, iterable)
    def _selfcast_ordered(self, iterable: QOrderedIterable[Fraction]) -> QFractionOrderedIterable: return cast(QFractionOrderedIterable, iterable)

    # region override methods so that typecheckers know that we actually return QFractionIterables now, not QIterable[Fraction]
    # call the base method to eliminate code duplication. The base class will call lazy from just above, so it is already the correct type
    @override
    def where(self, predicate: Predicate[Fraction]) -> QFractionIterable: return self._selfcast(super().where(predicate))
    @override
    def where_not_none(self) -> QFractionIterable: return self._selfcast(super().where_not_none())
    @override
    def distinct(self) -> QFractionIterable: return self._selfcast(super().distinct())
    @override
    def distinct_by[TKey](self, key_selector: Selector[Fraction, TKey]) -> QFractionIterable: return self._selfcast(super().distinct_by(key_selector))
    @override
    def take(self, count: int) -> QFractionIterable: return self._selfcast(super().take(count))
    @override
    def take_while(self, predicate: Predicate[Fraction]) -> QFractionIterable: return self._selfcast(super().take_while(predicate))
    @override
    def take_last(self, count: int) -> QFractionIterable: return self._selfcast(super().take_last(count))
    @override
    def skip(self, count: int) -> QFractionIterable: return self._selfcast(super().skip(count))
    @override
    def skip_last(self, count: int) -> QFractionIterable: return self._selfcast(super().skip_last(count))
    @override
    def reversed(self) -> QFractionIterable: return self._selfcast(super().reversed())

    @override
    def concat(self, *others: Iterable[Fraction]) -> QFractionIterable: return self._selfcast(super().concat(*others))

    @override
    def ordered(self) -> QFractionIterable: return self._selfcast(super().ordered())
    @override
    def order_by(self, key_selector: Selector[Fraction, SupportsRichComparison]) -> QFractionOrderedIterable: return self._selfcast_ordered(super().order_by(key_selector))
    @override
    def order_by_descending(self, key_selector: Selector[Fraction, SupportsRichComparison]) -> QFractionOrderedIterable: return self._selfcast_ordered(super().order_by_descending(key_selector))
    # endregion

    @override
    def to_list(self) -> QFractionList: return QFractionList(self)

    @override
    def to_sequence(self) -> QFractionSequence: return QFractionSequence(self)

    @override
    def to_set(self) -> QFractionSet: return QFractionSet(self)

    @override
    def to_frozenset(self) -> QFractionFrozenSet: return QFractionFrozenSet(self)

class QFractionIterableImplementation(QLazyIterableImplementation[Fraction], QFractionIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[Fraction]]) -> None:
        super().__init__(factory)

class QFractionOrderedIterable(QOrderedIterable[Fraction], QFractionIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[Fraction]], sorting_instructions: list[SortInstruction[Fraction]]) -> None:
        super().__init__(factory, sorting_instructions)

class QFractionList(QList[Fraction], QFractionIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[Fraction] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QFractionIterable: return QFractionIterable.reversed(self)

class QFractionSet(QSet[Fraction], QFractionIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[Fraction] = ()) -> None:
        super().__init__(iterable)

class QFractionFrozenSet(QFrozenSet[Fraction], QFractionIterable):
    __slots__: tuple[str, ...] = ()
    def __new__(cls, iterable: Iterable[Fraction] = ()) -> QFractionFrozenSet:
        return super().__new__(cls, iterable)  # pyright: ignore [reportReturnType]

class QFractionSequence(QImmutableSequence[Fraction], QFractionIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[Fraction] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QFractionIterable: return QFractionIterable.reversed(self)
</file>

<file path="src/queryablecollections/collections/numeric/q_int_types.py">
from __future__ import annotations

import statistics
from abc import ABC
from typing import TYPE_CHECKING, cast, override

from queryablecollections._private_implementation_details.operations.ordering import SortInstruction
from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
from queryablecollections.collections.q_frozen_set import QFrozenSet
from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
from queryablecollections.collections.q_list import QList
from queryablecollections.collections.q_set import QSet
from queryablecollections.q_errors import EmptyIterableError
from queryablecollections.q_iterable import QIterable
from queryablecollections.q_ordered_iterable import QOrderedIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Func, Predicate, Selector

class QIntIterable(QIterable[int], ABC):
    __slots__: tuple[str, ...] = ()

    def sum(self) -> int: return sum(self)

    def min(self) -> int:
        try:
            return min(self)
        except ValueError:
            raise EmptyIterableError() from None

    def max(self) -> int:
        try:
            return max(self)
        except ValueError:
            raise EmptyIterableError() from None

    def min_or_default(self) -> int: return min(self) if self.any() else 0
    def max_or_default(self) -> int: return max(self) if self.any() else 0
    def average(self) -> float: return statistics.mean(self._assert_not_empty())
    def average_or_default(self) -> float: return statistics.mean(self) if self.any() else 0.0

    @override
    def _lazy(self, factory: Func[Iterable[int]]) -> QIntIterable: return QIntIterableImplementation(factory)
    @override
    def _order_by(self, key_selector: Selector[int, SupportsRichComparison], descending: bool) -> QOrderedIterable[int]:
        return QIntOrderedIterable(lambda: self, [SortInstruction(key_selector, descending)])
    def _selfcast(self, iterable: QIterable[int]) -> QIntIterable: return cast(QIntIterable, iterable)
    def _selfcast_ordered(self, iterable: QOrderedIterable[int]) -> QIntOrderedIterable: return cast(QIntOrderedIterable, iterable)

    # region override methods so that typecheckers know that we actually return QIntIterables now, not QIterable[int]
    # call the base method to eliminate code duplication. The base class will call lazy from just above, so it is already the correct type
    @override
    def where(self, predicate: Predicate[int]) -> QIntIterable: return self._selfcast(super().where(predicate))
    @override
    def where_not_none(self) -> QIntIterable: return self._selfcast(super().where_not_none())
    @override
    def distinct(self) -> QIntIterable: return self._selfcast(super().distinct())
    @override
    def distinct_by[TKey](self, key_selector: Selector[int, TKey]) -> QIntIterable: return self._selfcast(super().distinct_by(key_selector))
    @override
    def take(self, count: int) -> QIntIterable: return self._selfcast(super().take(count))
    @override
    def take_while(self, predicate: Predicate[int]) -> QIntIterable: return self._selfcast(super().take_while(predicate))
    @override
    def take_last(self, count: int) -> QIntIterable: return self._selfcast(super().take_last(count))
    @override
    def skip(self, count: int) -> QIntIterable: return self._selfcast(super().skip(count))
    @override
    def skip_last(self, count: int) -> QIntIterable: return self._selfcast(super().skip_last(count))
    @override
    def reversed(self) -> QIntIterable: return self._selfcast(super().reversed())

    @override
    def concat(self, *others: Iterable[int]) -> QIntIterable: return self._selfcast(super().concat(*others))

    @override
    def ordered(self) -> QIntIterable: return self._selfcast(super().ordered())
    @override
    def order_by(self, key_selector: Selector[int, SupportsRichComparison]) -> QIntOrderedIterable: return self._selfcast_ordered(super().order_by(key_selector))
    @override
    def order_by_descending(self, key_selector: Selector[int, SupportsRichComparison]) -> QIntOrderedIterable: return self._selfcast_ordered(super().order_by_descending(key_selector))
    # endregion

    @override
    def to_list(self) -> QIntList: return QIntList(self)

    @override
    def to_sequence(self) -> QIntSequence: return QIntSequence(self)

    @override
    def to_set(self) -> QIntSet: return QIntSet(self)

    @override
    def to_frozenset(self) -> QIntFrozenSet: return QIntFrozenSet(self)

class QIntIterableImplementation(QLazyIterableImplementation[int], QIntIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[int]]) -> None:
        super().__init__(factory)

class QIntOrderedIterable(QOrderedIterable[int], QIntIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[Iterable[int]], sorting_instructions: list[SortInstruction[int]]) -> None:
        super().__init__(factory, sorting_instructions)

class QIntList(QList[int], QIntIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[int] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QIntIterable: return QIntIterable.reversed(self)

class QIntSet(QSet[int], QIntIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[int] = ()) -> None:
        super().__init__(iterable)

class QIntFrozenSet(QFrozenSet[int], QIntIterable):
    __slots__: tuple[str, ...] = ()
    def __new__(cls, iterable: Iterable[int] = ()) -> QIntFrozenSet:
        return super().__new__(cls, iterable)  # pyright: ignore [reportReturnType]

class QIntSequence(QImmutableSequence[int], QIntIterable):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[int] = ()) -> None:
        super().__init__(iterable)

    @override
    def reversed(self) -> QIntIterable: return QIntIterable.reversed(self)
</file>

<file path="src/queryablecollections/collections/q_default_dict.py">
from __future__ import annotations

from collections import defaultdict
from typing import TYPE_CHECKING, override

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C
from queryablecollections.collections.q_key_value_pair import KeyValuePair
from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from queryablecollections._private_implementation_details.type_aliases import Func


class QDefaultDict[TKey, TItem](defaultdict[TKey, TItem], QIterable[TKey]):
    __slots__: tuple[str, ...] = ()
    def __init__(self, factory: Func[TItem]) -> None:
        super().__init__(factory)

    def qitems(self) -> QIterable[KeyValuePair[TKey, TItem]]: return C.lazy_iterable(lambda: self.items()).select(KeyValuePair)

    @override
    def _optimized_length(self) -> int: return len(self)
</file>

<file path="src/queryablecollections/collections/q_dict.py">
from __future__ import annotations

from typing import TYPE_CHECKING, override

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C
from queryablecollections.collections.q_key_value_pair import KeyValuePair
from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

class QDict[TKey, TItem](dict[TKey, TItem], QIterable[TKey]):
    __slots__: tuple[str, ...] = ()
    def __init__(self, elements: Iterable[tuple[TKey, TItem]]) -> None:
        super().__init__(elements)

    def qitems(self) -> QIterable[KeyValuePair[TKey, TItem]]: return C.lazy_iterable(lambda: super().items()).select(KeyValuePair)

    @override
    def _optimized_length(self) -> int: return len(self)
</file>

<file path="src/queryablecollections/collections/q_frozen_set.py">
from __future__ import annotations

from typing import TYPE_CHECKING, cast, override

from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

class QFrozenSet[TItem](frozenset[TItem], QIterable[TItem]):
    __slots__: tuple[str, ...] = ()
    def __new__(cls, iterable: Iterable[TItem] = ()) -> QFrozenSet[TItem]:
        return super().__new__(cls, iterable)

    @override
    def _optimized_length(self) -> int: return len(self)

    _empty_set: QFrozenSet[TItem]

    @staticmethod
    @override
    def empty() -> QFrozenSet[TItem]:
        return cast(QFrozenSet[TItem], QFrozenSet._empty_set)  # pyright: ignore [reportGeneralTypeIssues, reportUnknownMemberType] an empty instance can serve as any item type in python since generic types are not present at runtime and this gives as such an instance at virtually zero cost

QFrozenSet._empty_set = QFrozenSet()  # pyright: ignore [reportGeneralTypeIssues, reportPrivateUsage]
</file>

<file path="src/queryablecollections/collections/q_immutable_sequence.py">
from __future__ import annotations

from typing import TYPE_CHECKING, overload, override

from queryablecollections._private_implementation_details.immutable_sequence import ImmutableSequence
from queryablecollections.collections.q_sequence import QSequence

if TYPE_CHECKING:
    from collections.abc import Iterable


class QImmutableSequence[TItem](ImmutableSequence[TItem], QSequence[TItem]):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[TItem] = ()) -> None:
        super().__init__(list(iterable))

    @overload
    def __getitem__(self, index: int) -> TItem: ...
    @overload
    def __getitem__(self, index: slice) -> QImmutableSequence[TItem]: ...
    @override
    def __getitem__(self, index: int | slice) -> TItem | QImmutableSequence[TItem]:
        if isinstance(index, slice):
            return QImmutableSequence(super().__getitem__(index))
        return super().__getitem__(index)
</file>

<file path="src/queryablecollections/collections/q_key_value_pair.py">
from __future__ import annotations

from typing import TypeVar

TValue = TypeVar("TValue", covariant=True)
TKey = TypeVar("TKey")


class KeyValuePair(tuple[TKey, TValue]):
    __slots__: tuple[str, ...] = ()
    def __new__(cls, value: tuple[TKey, TValue]):
        return super().__new__(cls, value)

    @property
    def key(self) -> TKey: return self[0]
    @property
    def value(self) -> TValue: return self[1]
</file>

<file path="src/queryablecollections/collections/q_list.py">
from __future__ import annotations

import sys
from typing import TYPE_CHECKING, SupportsIndex, overload, override

from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
from queryablecollections.collections.q_sequence import QSequence
from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from collections.abc import Iterable

class QList[TItem](list[TItem], QSequence[TItem], QIterable[TItem]):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[TItem] = ()) -> None:
        super().__init__(iterable)

    @override
    def _optimized_length(self) -> int: return len(self)

    @override
    def reversed(self) -> QIterable[TItem]: return QLazyIterableImplementation[TItem](lambda: reversed(self))

    @override
    def element_at(self, index: int) -> TItem: return self[index]

    @override
    def index(self, value: TItem, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize) -> int:
        return super().index(value, start, stop)

    @override
    def count(self, value: TItem): return super().count(value)

    @overload
    def __getitem__(self, index: SupportsIndex) -> TItem: ...

    @overload
    def __getitem__(self, index: slice) -> QList[TItem]: ...

    @override
    def __getitem__(self, index: SupportsIndex | slice) -> TItem | QList[TItem]:
        if isinstance(index, slice):
            return QList(super().__getitem__(index))
        return super().__getitem__(index)

    @staticmethod
    @override
    def empty() -> QList[TItem]: return QList()  # QList is mutable, so unlike our base types we cannot reuse an instance
</file>

<file path="src/queryablecollections/collections/q_sequence.py">
from __future__ import annotations

from abc import ABC
from collections.abc import Sequence
from typing import override

from queryablecollections._private_implementation_details.q_lazy_iterable import QLazyIterableImplementation
from queryablecollections.q_iterable import QIterable


class QSequence[TItem](Sequence[TItem], QIterable[TItem], ABC):
    __slots__: tuple[str, ...] = ()
    @override
    def _optimized_length(self) -> int: return len(self)

    @override
    def reversed(self) -> QIterable[TItem]: return QLazyIterableImplementation[TItem](lambda: reversed(self))

    @staticmethod
    @override
    def empty() -> QSequence[TItem]:
        from queryablecollections.collections.q_immutable_sequence import QImmutableSequence
        empty = QImmutableSequence[TItem]()
        def get_empty() -> QSequence[TItem]: return empty
        QSequence.empty = get_empty # replace this method with get_empty so that future calls have zero overhead, just returning a reference
        return QSequence[TItem].empty() # call the new version so we know from the very first call that it works
</file>

<file path="src/queryablecollections/collections/q_set.py">
from __future__ import annotations

from typing import TYPE_CHECKING, override

from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from collections.abc import Iterable


class QSet[TItem](set[TItem], QIterable[TItem]):
    __slots__: tuple[str, ...] = ()
    def __init__(self, iterable: Iterable[TItem] = ()) -> None:
        super().__init__(iterable)

    @override
    def _optimized_length(self) -> int: return len(self)

    @staticmethod
    @override
    def empty() -> QSet[TItem]: return QSet()  # QSet is mutable, so unlike our base types we cannot reuse an instance
</file>

<file path="src/queryablecollections/q_cast.py">
from __future__ import annotations

from collections.abc import Iterable
from decimal import Decimal
from fractions import Fraction
from typing import TYPE_CHECKING, cast

from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C
from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from queryablecollections.collections.numeric.q_decimal_types import QDecimalIterable
    from queryablecollections.collections.numeric.q_float_types import QFloatIterable
    from queryablecollections.collections.numeric.q_fraction_types import QFractionIterable
    from queryablecollections.collections.numeric.q_int_types import QIntIterable

class CheckedCast[TValue]:
    __slots__: tuple[str, ...] = ("_type",)
    def __init__(self, type: type[TValue]) -> None:
        self._type: type[TValue] = type

    def __call__(self, value: object) -> TValue:
        if not isinstance(value, self._type): raise TypeError(f"Expected {self._type.__name__}, got {type(value).__name__}")
        return value

_checked_cast_int = CheckedCast(int)
_checked_cast_float = CheckedCast(float)
_checked_cast_fraction = CheckedCast(Fraction)
_checked_cast_decimal = CheckedCast(Decimal)

class QCast[TItem]:
    __slots__: tuple[str, ...] = ("_iterable",)
    def __init__(self, iterable: QIterable[TItem]) -> None:
        self._iterable: QIterable[TItem] = iterable

    @property
    def checked(self) -> QCheckedCast[TItem]:
        return QCheckedCast(self._iterable)

    def int(self) -> QIntIterable:
        return C.int_iterable(lambda: (cast(Iterable[int], self._iterable)))

    def float(self) -> QFloatIterable:
        return C.float_iterable(lambda: (cast(Iterable[float], self._iterable)))

    def fraction(self) -> QFractionIterable:
        return C.fraction_iterable(lambda: (cast(Iterable[Fraction], self._iterable)))

    def decimal(self) -> QDecimalIterable:
        return C.decimal_iterable(lambda: cast(Iterable[Decimal], self._iterable))

    def to[TNew](self, _type: type[TNew]) -> QIterable[TNew]:  # pyright: ignore
        return cast(QIterable[TNew], self._iterable)

class QCheckedCast[TItem]:
    __slots__: tuple[str, ...] = ("_iterable",)
    def __init__(self, iterable: QIterable[TItem]) -> None:
        self._iterable: QIterable[TItem] = iterable

    def int(self) -> QIntIterable:
        return C.int_iterable(lambda: self._iterable.select(_checked_cast_int))

    def float(self) -> QFloatIterable:
        return C.float_iterable(lambda: self._iterable.select(_checked_cast_float))

    def fraction(self) -> QFractionIterable:
        return C.fraction_iterable(lambda: self._iterable.select(_checked_cast_fraction))

    def decimal(self) -> QDecimalIterable:
        return C.decimal_iterable(lambda: self._iterable.select(_checked_cast_decimal))

    def to[TNew](self, _type: type[TNew]) -> QIterable[TNew]:  # pyright: ignore
        return self._iterable.select(CheckedCast(_type))
</file>

<file path="src/queryablecollections/q_errors.py">
from __future__ import annotations


class InvalidOperationError(Exception):
    """Raised when a method call is invalid for the object's current state."""
    def __init__(self, message: str = "The called method cannot be called with the object in the current state") -> None:
        super().__init__(message)

class EmptyIterableError(InvalidOperationError):
    """Raised when an operation is attempted on an empty Iterable."""
    def __init__(self) -> None:
        super().__init__("The operation cannot be performed on an empty Iterable.")

class ArgumentError(Exception):
    """Raised when an argument is invalid."""
    def __init__(self, message: str = "The argument is invalid.") -> None:
        super().__init__(message)

class ArgumentNoneError(ArgumentError):
    """Raised when an argument is None."""
    def __init__(self, argument_name: str) -> None:
        super().__init__(f"{argument_name} cannot be None.")
</file>

<file path="src/queryablecollections/q_grouping.py">
from __future__ import annotations

from queryablecollections.collections.q_list import QList


class QGrouping[TKey, TElement](QList[TElement]):
    """Represents a collection of objects that have a common key."""
    __slots__: tuple[str, ...] = ("key",)

    def __init__(self, values: tuple[TKey, QList[TElement]]) -> None:
        super().__init__(values[1])
        self.key: TKey = values[0]
</file>

<file path="src/queryablecollections/q_iterable.py">
from __future__ import annotations

from abc import ABC
from collections.abc import Callable, Iterable
from typing import TYPE_CHECKING, Self, overload

import queryablecollections._private_implementation_details.operations as ops
from queryablecollections._private_implementation_details.operations.ordering import SortInstruction

# noinspection PyPep8Naming
from queryablecollections._private_implementation_details.q_zero_overhead_collection_contructors import ZeroImportOverheadConstructors as C
from queryablecollections.q_errors import EmptyIterableError

if TYPE_CHECKING:
    from decimal import Decimal
    from fractions import Fraction

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Action1, Func, Predicate, Selector
    from queryablecollections.collections.numeric.q_decimal_types import QDecimalIterable
    from queryablecollections.collections.numeric.q_float_types import QFloatIterable
    from queryablecollections.collections.numeric.q_fraction_types import QFractionIterable
    from queryablecollections.collections.numeric.q_int_types import QIntIterable
    from queryablecollections.collections.q_dict import QDict
    from queryablecollections.collections.q_frozen_set import QFrozenSet
    from queryablecollections.collections.q_list import QList
    from queryablecollections.collections.q_sequence import QSequence
    from queryablecollections.collections.q_set import QSet
    from queryablecollections.q_cast import QCast
    from queryablecollections.q_grouping import QGrouping
    from queryablecollections.q_ordered_iterable import QOrderedIterable

def query[TItem](value: Iterable[TItem]) -> QIterable[TItem]: return C.caching_iterable(value)

# note to coders, you can trust that the on single lines do nothing except delegate to the corresponding operations method,
# or to ZeroImportOverheadConstructors, knowing taht, keeping them on single lines to make it easier to read through the definitions
class QIterable[T](Iterable[T], ABC):
    __slots__: tuple[str, ...] = ()
    @property
    def cast(self) -> QCast[T]: return C.cast(self)

    def _lazy(self, factory: Func[Iterable[T]]) -> QIterable[T]:
        return C.lazy_iterable(factory)

    # region operations on the whole collection, not the items
    def concat(self, *others: Iterable[T]) -> QIterable[T]: return self._lazy(lambda: ops.concat(self, *others))
    # endregion

    # region functional programming helpers
    def pipe[TReturn](self, action: Selector[QIterable[T], TReturn]) -> TReturn: return ops.pipe(self, action)
    def for_each(self, action: Action1[T]) -> Self:
        for item in self: action(item)
        return self
    # endregion

    # region typed convertions to access type specific functionality type checkers will only allow calls if the instance is the correct type

    def as_ints(self: QIterable[int]) -> QIntIterable: return ops.as_ints(self)
    def as_floats(self: QIterable[float]) -> QFloatIterable: return ops.as_floats(self)
    def as_fractions(self: QIterable[Fraction]) -> QFractionIterable: return ops.as_fractions(self)
    def as_decimals(self: QIterable[Decimal]) -> QDecimalIterable: return ops.as_decimals(self)

    # endregion

    # region filtering
    def where(self, predicate: Predicate[T]) -> QIterable[T]: return self._lazy(lambda: ops.where(self, predicate))
    def where_not_none(self) -> QIterable[T]: return self._lazy(lambda: ops.where_not_none(self))

    def distinct(self) -> QIterable[T]: return self._lazy(lambda: ops.distinct(self))

    def distinct_by[TKey](self, key_selector: Selector[T, TKey]) -> QIterable[T]: return self._lazy(lambda: ops.distinct_by(self, key_selector))

    def take(self, count: int) -> QIterable[T]: return self._lazy(lambda: ops.take(self, count))
    def take_while(self, predicate: Predicate[T]) -> QIterable[T]: return self._lazy(lambda: ops.take_while(self, predicate))
    def take_last(self, count: int) -> QIterable[T]: return self._lazy(lambda: ops.take_last(self, count))
    def skip(self, count: int) -> QIterable[T]: return self._lazy(lambda: ops.skip(self, count))
    def skip_last(self, count: int) -> QIterable[T]: return self._lazy(lambda: ops.skip_last(self, count))

    def of_type[TResult](self, target_type: type[TResult]) -> QIterable[TResult]: return C.lazy_iterable(lambda: ops.of_type(self, target_type))

    # endregion

    # region value queries
    def qcount(self, predicate: Predicate[T] | None = None) -> int: return ops.count(self, predicate)
    def none(self, predicate: Predicate[T] | None = None) -> bool: return not ops.any(self, predicate)
    def any(self, predicate: Predicate[T] | None = None) -> bool: return ops.any(self, predicate)
    def all(self, predicate: Predicate[T]) -> bool: return ops.all(self, predicate)

    # endregion

    # region sorting
    def _order_by(self, key_selector: Selector[T, SupportsRichComparison], descending: bool) -> QOrderedIterable[T]:
        return C.ordered_iterable(lambda: self, [SortInstruction(key_selector, descending)])

    def order_by(self, key_selector: Selector[T, SupportsRichComparison]) -> QOrderedIterable[T]:
        return self._order_by(key_selector, False)
    def order_by_descending(self, key_selector: Selector[T, SupportsRichComparison]) -> QOrderedIterable[T]:
        return self._order_by(key_selector, True)

    def reversed(self) -> QIterable[T]: return self._lazy(lambda: ops.reverse_lazy(self))

    def ordered(self) -> QIterable[T]: return self._lazy(lambda: ops.ordered(self))  # pyright: ignore [reportUnknownVariableType, reportArgumentType, reportUnknownLambdaType]
    # endregion

    # region mapping/transformation methods
    def select[TReturn](self, selector: Selector[T, TReturn]) -> QIterable[TReturn]: return ops.select(self, selector)
    def select_many[TInner](self, selector: Selector[T, Iterable[TInner]]) -> QIterable[TInner]: return ops.select_many(self, selector)
    def join[TInner, TKey, TResult](self, other: Iterable[TInner], self_key: Selector[T, TKey], other_key: Selector[TInner, TKey], select: Callable[[T, TInner], TResult]) -> QIterable[TResult]: return ops.join(self, other, self_key, other_key, select)

    def zip[T2, TResult](self, second: Iterable[T2], select: Callable[[T, T2], TResult]) -> QIterable[TResult]:
        return ops.zip(self, second, select)

    def zip2[T2, T3, TResult](self, second: Iterable[T2], third: Iterable[T3], select: Callable[[T, T2, T3], TResult]) -> QIterable[TResult]:
        return ops.zip2(self, second, third, select)

    def zip3[T2, T3, T4, TResult](self, second: Iterable[T2], third: Iterable[T3], fourth: Iterable[T4], select: Callable[[T, T2, T3, T4], TResult]) -> QIterable[TResult]:
        return ops.zip3(self, second, third, fourth, select)

    @overload
    def to_dict[TKey, TValue](self, key_selector: Selector[T, TKey], value_selector: Selector[T, TValue]) -> QDict[TKey, TValue]:
        """Creates a QDict from the sequence using the specified key and value selectors"""
    @overload
    def to_dict[TKey, TValue](self: QIterable[tuple[TKey, TValue]]) -> QDict[TKey, TValue]:
        """Creates a QDict from a sequence of key-value tuples"""
    def to_dict[TKey, TValue](self, key_selector: Selector[T, TKey] | None = None, value_selector: Selector[T, TValue] | None = None) -> QDict[TKey, TValue]: return ops.to_dict(self, key_selector, value_selector)

    @overload
    def group_by[TKey](self, key: Selector[T, TKey]) -> QIterable[QGrouping[TKey, T]]:
        """Groups the elements of a sequence according to the specified key selector"""

    @overload
    def group_by[TKey, TElement](self, key: Selector[T, TKey], element: Selector[T, TElement]) -> QIterable[QGrouping[TKey, TElement]]:
        """Groups the elements of a sequence according to the specified key selector and element selector"""

    def group_by[TKey, TElement](self, key: Selector[T, TKey], element: Selector[T, TElement] | None = None) -> QIterable[QGrouping[TKey, T]] | QIterable[QGrouping[TKey, TElement]]: return ops.group_by_q(self, key, element)
    # endregion

    # region single item selecting methods
    def first(self, predicate: Predicate[T] | None = None) -> T: return ops.first(self, predicate)
    def first_or_none(self, predicate: Predicate[T] | None = None) -> T | None: return ops.first_or_none(self, predicate)
    def single(self, predicate: Predicate[T] | None = None) -> T: return ops.single(self, predicate)
    def single_or_none(self, predicate: Predicate[T] | None = None) -> T | None: return ops.single_or_none(self, predicate)

    def element_at(self, index: int) -> T: return ops.element_at(self, index)
    def element_at_or_none(self, index: int) -> T | None: return ops.element_at_or_none(self, index)
    # endregion

    # region methods subclasses may want to override for perfarmonce reasons

    def _optimized_length(self) -> int: return sum(1 for _ in self)
    def _assert_not_empty(self) -> Self:
        if not self.any(): raise EmptyIterableError()
        return self

    # region factory methods
    # note: we do not "optimize" by returning self in any subclass because the contract is to create a new independent copy
    def to_list(self) -> QList[T]: return C.list_(self)
    def to_set(self) -> QSet[T]: return C.set(self)
    def to_frozenset(self) -> QFrozenSet[T]: return C.frozen_set(self)
    def to_sequence(self) -> QSequence[T]: return C.sequence(self)
    def to_built_in_list(self) -> list[T]: return list(self)

    # endregion

    @staticmethod
    def empty() -> QIterable[T]: return C.empty_iterable()
</file>

<file path="src/queryablecollections/q_ordered_iterable.py">
from __future__ import annotations

from typing import TYPE_CHECKING, override

import queryablecollections._private_implementation_details.operations as ops
from queryablecollections._private_implementation_details.operations.ordering import SortInstruction
from queryablecollections.q_iterable import QIterable

if TYPE_CHECKING:
    from collections.abc import Iterable, Iterator

    from _typeshed import SupportsRichComparison

    from queryablecollections._private_implementation_details.type_aliases import Func, Selector


class QOrderedIterable[TItem](QIterable[TItem]):
    __slots__: tuple[str, ...] = ("sorting_instructions", "_factory")
    def __init__(self, factory: Func[Iterable[TItem]], sorting_instructions: list[SortInstruction[TItem]]) -> None:
        self.sorting_instructions: list[SortInstruction[TItem]] = sorting_instructions
        self._factory: Func[Iterable[TItem]] = factory

    def then_by(self, key_selector: Selector[TItem, SupportsRichComparison]) -> QOrderedIterable[TItem]:
        return QOrderedIterable(self._factory, self.sorting_instructions + [SortInstruction(key_selector, descending=False)])

    def then_by_descending(self, key_selector: Selector[TItem, SupportsRichComparison]) -> QOrderedIterable[TItem]:
        return QOrderedIterable(self._factory, self.sorting_instructions + [SortInstruction(key_selector, descending=True)])

    @override
    def __iter__(self) -> Iterator[TItem]: yield from ops.ordering.sort_by_instructions(self._factory(), self.sorting_instructions)
</file>

<file path="src/zip_test.py">
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Callable


class QIter[T]:
    def zip[T2, TOut](self, second: QIter[T2], select: Callable[[T, T2], TOut]) -> QIter[TOut]:...
    def zip2[T2, T3, TOut](self, second: QIter[T2], third: QIter[T3], select: Callable[[T, T2, T3], TOut]) -> QIter[TOut]: ...
    def zip3[T2, T3, T4, TOut](self, second: QIter[T2], third: QIter[T3], fourth: QIter[T4], select: Callable[[T, T2, T3, T4], TOut]) -> QIter[TOut]: ...
</file>

</files>

from __future__ import annotations

from typing import TYPE_CHECKING, override

from jastudio.ankiutils import app
from autoslot import Slots  # pyright: ignore[reportMissingTypeStubs]
from jastudio.note.note_constants import Tags
from jastudio.note.notefields.require_forbid_flag_field import RequireForbidFlagField
from sysutils.simple_string_builder import SimpleStringBuilder
from sysutils.weak_ref import WeakRef, WeakRefable

if TYPE_CHECKING:
    from configuration.configuration_value import ConfigurationValueBool
    from jastudio.note.vocabulary.vocabnote import VocabNote
    from jastudio.note.vocabulary.vocabnote_parts_of_speech import VocabNotePartsOfSpeech

class YieldLastTokenToOverlappingCompound(RequireForbidFlagField, WeakRefable, Slots):
    automatically_yield_last_token_in_suru_verb_compounds_to_overlapping_compound: ConfigurationValueBool = app.config().automatically_yield_last_token_in_suru_verb_compounds_to_overlapping_compound
    automatically_yield_last_token_in_passive_verb_compounds_to_overlapping_compound: ConfigurationValueBool = app.config().automatically_yield_last_token_in_passive_verb_compounds_to_overlapping_compound
    automatically_yield_last_token_in_causative_verb_compounds_to_overlapping_compound: ConfigurationValueBool = app.config().automatically_yield_last_token_in_causative_verb_compounds_to_overlapping_compound

    def __init__(self, vocab: WeakRef[VocabNote]) -> None:
        super().__init__(vocab, Tags.Vocab.Matching.yield_last_token_to_overlapping_compound, Tags.Vocab.Matching.Forbids.auto_yielding)
        self._pos: VocabNotePartsOfSpeech = vocab().parts_of_speech
<<<<<<< HEAD
        self._required: Lazy[bool] = Lazy(self._decide_if_required)
        self_weakref = WeakRef(self)
        self.automatically_yield_last_token_in_suru_verb_compounds_to_overlapping_compound.on_change(lambda _: self_weakref.run_if_live(lambda me: me._required.reset()))
        self.automatically_yield_last_token_in_passive_verb_compounds_to_overlapping_compound.on_change(lambda _: self_weakref.run_if_live(lambda me: me._required.reset()))
        self.automatically_yield_last_token_in_causative_verb_compounds_to_overlapping_compound.on_change(lambda _: self_weakref.run_if_live(lambda me: me._required.reset()))
=======
>>>>>>> 87ecc945 (Stop Caching YieldLastTokenToOverlappingCompound, 13MB reduced memory usage.)

    def _decide_if_required(self) -> bool:
        return (super().is_required
                or (not self.is_forbidden
                    and (  # na adjectives
                            self._pos.is_complete_na_adjective()
                            # suru verb compounds
                            or (self.automatically_yield_last_token_in_suru_verb_compounds_to_overlapping_compound.get_value()
                                and self._pos.is_suru_verb_included()
                                and not self._pos.is_ni_suru_ga_suru_ku_suru_compound())
                            # passive verb compounds
                            or (self.automatically_yield_last_token_in_passive_verb_compounds_to_overlapping_compound.get_value()
                                and self._pos.is_passive_verb_compound())
                            # causative verb compounds
                            or (self.automatically_yield_last_token_in_causative_verb_compounds_to_overlapping_compound.get_value()
                                and self._pos.is_causative_verb_compound())
                    )))

    @property
    @override
    def is_required(self) -> bool: return self._decide_if_required()

    @override
    def __repr__(self) -> str: return (SimpleStringBuilder()
                                       .append_if(self.is_required, "required")
                                       .append_if(self.is_forbidden, "forbidden")
                                       .build())

import typing, clr, abc
from Avalonia.Styling import IThemeVariantHost, IGlobalStyles, ThemeVariant, Styles, IStyleable, IStyleHost, ControlTheme
from Avalonia.Controls import IGlobalDataTemplates, IResourceDictionary, ISetInheritanceParent, ISetLogicalParent, Classes
from Avalonia.Platform import IOptionalFeatureProvider, IApplicationPlatformEvents, IPlatformSettings
from Avalonia.Controls.ApplicationLifetimes import IApplicationLifetime
from Avalonia.Controls.Templates import DataTemplates
from Avalonia.Data import IndexerDescriptor, IBinding, BindingValue_1, BindingPriority, BindingExpressionBase, Optional_1, BindingMode
from System import IObservable_1, Func_2, IDisposable, IEquatable_1, Func_3, Action_2, EventArgs
from System.ComponentModel import INotifyPropertyChanged, ISupportInitialize
from Avalonia.Data.Core import IPropertyInfo
from System.Numerics import Vector2
from Avalonia.Animation import Animatable, Transitions
from Avalonia.LogicalTree import ILogical
from Avalonia.Media import Geometry, IEffect, FlowDirection, IBrush, ITransform, DrawingContext

class Application(AvaloniaObject, IThemeVariantHost, IGlobalStyles, IGlobalDataTemplates, IOptionalFeatureProvider, IApplicationPlatformEvents, IDataContextProvider):
    def __init__(self) -> None: ...
    ActualThemeVariantProperty : StyledProperty_1[ThemeVariant]
    DataContextProperty : StyledProperty_1[typing.Any]
    NameProperty : DirectProperty_2[Application, str]
    RequestedThemeVariantProperty : StyledProperty_1[ThemeVariant]
    @property
    def ActualThemeVariant(self) -> ThemeVariant: ...
    @property
    def ApplicationLifetime(self) -> IApplicationLifetime: ...
    @ApplicationLifetime.setter
    def ApplicationLifetime(self, value: IApplicationLifetime) -> IApplicationLifetime: ...
    @classmethod
    @property
    def Current(cls) -> Application: ...
    @property
    def DataContext(self) -> typing.Any: ...
    @DataContext.setter
    def DataContext(self, value: typing.Any) -> typing.Any: ...
    @property
    def DataTemplates(self) -> DataTemplates: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def PlatformSettings(self) -> IPlatformSettings: ...
    @property
    def RequestedThemeVariant(self) -> ThemeVariant: ...
    @RequestedThemeVariant.setter
    def RequestedThemeVariant(self, value: ThemeVariant) -> ThemeVariant: ...
    @property
    def Resources(self) -> IResourceDictionary: ...
    @Resources.setter
    def Resources(self, value: IResourceDictionary) -> IResourceDictionary: ...
    @property
    def Styles(self) -> Styles: ...
    def Initialize(self) -> None: ...
    def OnFrameworkInitializationCompleted(self) -> None: ...
    def RegisterServices(self) -> None: ...
    def TryGetFeature(self, featureType: typing.Type[typing.Any]) -> typing.Any: ...
    def TryGetResource(self, key: typing.Any, theme: ThemeVariant, value: clr.Reference[typing.Any]) -> bool: ...
    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


class AttachedProperty_GenericClasses(abc.ABCMeta):
    Generic_AttachedProperty_GenericClasses_AttachedProperty_1_TValue = typing.TypeVar('Generic_AttachedProperty_GenericClasses_AttachedProperty_1_TValue')
    def __getitem__(self, types : typing.Type[Generic_AttachedProperty_GenericClasses_AttachedProperty_1_TValue]) -> typing.Type[AttachedProperty_1[Generic_AttachedProperty_GenericClasses_AttachedProperty_1_TValue]]: ...

AttachedProperty : AttachedProperty_GenericClasses

AttachedProperty_1_TValue = typing.TypeVar('AttachedProperty_1_TValue')
class AttachedProperty_1(typing.Generic[AttachedProperty_1_TValue], StyledProperty_1[AttachedProperty_1_TValue]):
    @property
    def Changed(self) -> IObservable_1[AvaloniaPropertyChangedEventArgs_1[AttachedProperty_1_TValue]]: ...
    @property
    def Changed(self) -> IObservable_1[AvaloniaPropertyChangedEventArgs]: ...
    @property
    def Inherits(self) -> bool: ...
    @Inherits.setter
    def Inherits(self, value: bool) -> bool: ...
    @property
    def IsAttached(self) -> bool: ...
    @IsAttached.setter
    def IsAttached(self, value: bool) -> bool: ...
    @property
    def IsDirect(self) -> bool: ...
    @IsDirect.setter
    def IsDirect(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def OwnerType(self) -> typing.Type[typing.Any]: ...
    @property
    def PropertyType(self) -> typing.Type[typing.Any]: ...
    @property
    def ValidateValue(self) -> Func_2[AttachedProperty_1_TValue, bool]: ...
    # Skipped AddOwner due to it being static, abstract and generic.

    AddOwner : AddOwner_MethodGroup[AttachedProperty_1_TValue]
    AddOwner_MethodGroup_AttachedProperty_1_TValue = typing.TypeVar('AddOwner_MethodGroup_AttachedProperty_1_TValue')
    class AddOwner_MethodGroup(typing.Generic[AddOwner_MethodGroup_AttachedProperty_1_TValue]):
        AddOwner_MethodGroup_AttachedProperty_1_TValue = AttachedProperty_1.AddOwner_MethodGroup_AttachedProperty_1_TValue
        def __getitem__(self, t:typing.Type[AddOwner_1_T1]) -> AddOwner_1[AddOwner_MethodGroup_AttachedProperty_1_TValue, AddOwner_1_T1]: ...

        AddOwner_1_AttachedProperty_1_TValue = typing.TypeVar('AddOwner_1_AttachedProperty_1_TValue')
        AddOwner_1_T1 = typing.TypeVar('AddOwner_1_T1')
        class AddOwner_1(typing.Generic[AddOwner_1_AttachedProperty_1_TValue, AddOwner_1_T1]):
            AddOwner_1_AttachedProperty_1_TValue = AttachedProperty_1.AddOwner_MethodGroup.AddOwner_1_AttachedProperty_1_TValue
            AddOwner_1_TOwner = AttachedProperty_1.AddOwner_MethodGroup.AddOwner_1_T1
            def __call__(self, metadata: StyledPropertyMetadata_1[AddOwner_1_AttachedProperty_1_TValue] = ...) -> AttachedProperty_1[AddOwner_1_AttachedProperty_1_TValue]:...




class AvaloniaObject(INotifyPropertyChanged):
    def __init__(self) -> None: ...
    def CheckAccess(self) -> bool: ...
    def CoerceValue(self, property: AvaloniaProperty) -> None: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsAnimating(self, property: AvaloniaProperty) -> bool: ...
    def IsSet(self, property: AvaloniaProperty) -> bool: ...
    def VerifyAccess(self) -> None: ...
    # Skipped Bind due to it being static, abstract and generic.

    Bind : Bind_MethodGroup
    class Bind_MethodGroup:
        def __getitem__(self, t:typing.Type[Bind_1_T1]) -> Bind_1[Bind_1_T1]: ...

        Bind_1_T1 = typing.TypeVar('Bind_1_T1')
        class Bind_1(typing.Generic[Bind_1_T1]):
            Bind_1_T = AvaloniaObject.Bind_MethodGroup.Bind_1_T1
            @typing.overload
            def __call__(self, property: DirectPropertyBase_1[Bind_1_T], source: IObservable_1[BindingValue_1[Bind_1_T]]) -> IDisposable:...
            @typing.overload
            def __call__(self, property: DirectPropertyBase_1[Bind_1_T], source: IObservable_1[Bind_1_T]) -> IDisposable:...
            @typing.overload
            def __call__(self, property: DirectPropertyBase_1[Bind_1_T], source: IObservable_1[typing.Any]) -> IDisposable:...
            @typing.overload
            def __call__(self, property: StyledProperty_1[Bind_1_T], source: IObservable_1[BindingValue_1[Bind_1_T]], priority: BindingPriority = ...) -> IDisposable:...
            @typing.overload
            def __call__(self, property: StyledProperty_1[Bind_1_T], source: IObservable_1[Bind_1_T], priority: BindingPriority = ...) -> IDisposable:...
            @typing.overload
            def __call__(self, property: StyledProperty_1[Bind_1_T], source: IObservable_1[typing.Any], priority: BindingPriority = ...) -> IDisposable:...

        @typing.overload
        def __call__(self, property: AvaloniaProperty, binding: IBinding) -> BindingExpressionBase:...
        @typing.overload
        def __call__(self, property: AvaloniaProperty, source: IObservable_1[typing.Any], priority: BindingPriority = ...) -> IDisposable:...

    # Skipped ClearValue due to it being static, abstract and generic.

    ClearValue : ClearValue_MethodGroup
    class ClearValue_MethodGroup:
        def __getitem__(self, t:typing.Type[ClearValue_1_T1]) -> ClearValue_1[ClearValue_1_T1]: ...

        ClearValue_1_T1 = typing.TypeVar('ClearValue_1_T1')
        class ClearValue_1(typing.Generic[ClearValue_1_T1]):
            ClearValue_1_T = AvaloniaObject.ClearValue_MethodGroup.ClearValue_1_T1
            @typing.overload
            def __call__(self, property: StyledProperty_1[ClearValue_1_T]) -> None:...
            @typing.overload
            def __call__(self, property: DirectPropertyBase_1[ClearValue_1_T]) -> None:...
            @typing.overload
            def __call__(self, property: AvaloniaProperty_1[ClearValue_1_T]) -> None:...

        def __call__(self, property: AvaloniaProperty) -> None:...

    # Skipped GetBaseValue due to it being static, abstract and generic.

    GetBaseValue : GetBaseValue_MethodGroup
    class GetBaseValue_MethodGroup:
        def __getitem__(self, t:typing.Type[GetBaseValue_1_T1]) -> GetBaseValue_1[GetBaseValue_1_T1]: ...

        GetBaseValue_1_T1 = typing.TypeVar('GetBaseValue_1_T1')
        class GetBaseValue_1(typing.Generic[GetBaseValue_1_T1]):
            GetBaseValue_1_T = AvaloniaObject.GetBaseValue_MethodGroup.GetBaseValue_1_T1
            def __call__(self, property: StyledProperty_1[GetBaseValue_1_T]) -> Optional_1[GetBaseValue_1_T]:...


    # Skipped GetValue due to it being static, abstract and generic.

    GetValue : GetValue_MethodGroup
    class GetValue_MethodGroup:
        def __getitem__(self, t:typing.Type[GetValue_1_T1]) -> GetValue_1[GetValue_1_T1]: ...

        GetValue_1_T1 = typing.TypeVar('GetValue_1_T1')
        class GetValue_1(typing.Generic[GetValue_1_T1]):
            GetValue_1_T = AvaloniaObject.GetValue_MethodGroup.GetValue_1_T1
            @typing.overload
            def __call__(self, property: StyledProperty_1[GetValue_1_T]) -> GetValue_1_T:...
            @typing.overload
            def __call__(self, property: DirectPropertyBase_1[GetValue_1_T]) -> GetValue_1_T:...

        def __call__(self, property: AvaloniaProperty) -> typing.Any:...

    # Skipped SetCurrentValue due to it being static, abstract and generic.

    SetCurrentValue : SetCurrentValue_MethodGroup
    class SetCurrentValue_MethodGroup:
        def __getitem__(self, t:typing.Type[SetCurrentValue_1_T1]) -> SetCurrentValue_1[SetCurrentValue_1_T1]: ...

        SetCurrentValue_1_T1 = typing.TypeVar('SetCurrentValue_1_T1')
        class SetCurrentValue_1(typing.Generic[SetCurrentValue_1_T1]):
            SetCurrentValue_1_T = AvaloniaObject.SetCurrentValue_MethodGroup.SetCurrentValue_1_T1
            def __call__(self, property: StyledProperty_1[SetCurrentValue_1_T], value: SetCurrentValue_1_T) -> None:...

        def __call__(self, property: AvaloniaProperty, value: typing.Any) -> None:...

    # Skipped SetValue due to it being static, abstract and generic.

    SetValue : SetValue_MethodGroup
    class SetValue_MethodGroup:
        def __getitem__(self, t:typing.Type[SetValue_1_T1]) -> SetValue_1[SetValue_1_T1]: ...

        SetValue_1_T1 = typing.TypeVar('SetValue_1_T1')
        class SetValue_1(typing.Generic[SetValue_1_T1]):
            SetValue_1_T = AvaloniaObject.SetValue_MethodGroup.SetValue_1_T1
            @typing.overload
            def __call__(self, property: DirectPropertyBase_1[SetValue_1_T], value: SetValue_1_T) -> None:...
            @typing.overload
            def __call__(self, property: StyledProperty_1[SetValue_1_T], value: SetValue_1_T, priority: BindingPriority = ...) -> IDisposable:...

        def __call__(self, property: AvaloniaProperty, value: typing.Any, priority: BindingPriority = ...) -> IDisposable:...

    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


class AvaloniaProperty_GenericClasses(abc.ABCMeta):
    Generic_AvaloniaProperty_GenericClasses_AvaloniaProperty_1_TValue = typing.TypeVar('Generic_AvaloniaProperty_GenericClasses_AvaloniaProperty_1_TValue')
    def __getitem__(self, types : typing.Type[Generic_AvaloniaProperty_GenericClasses_AvaloniaProperty_1_TValue]) -> typing.Type[AvaloniaProperty_1[Generic_AvaloniaProperty_GenericClasses_AvaloniaProperty_1_TValue]]: ...

class AvaloniaProperty(AvaloniaProperty_0, metaclass =AvaloniaProperty_GenericClasses): ...

class AvaloniaProperty_0(IPropertyInfo, IEquatable_1[AvaloniaProperty], abc.ABC):
    UnsetValue : typing.Any
    @property
    def Changed(self) -> IObservable_1[AvaloniaPropertyChangedEventArgs]: ...
    @property
    def Inherits(self) -> bool: ...
    @Inherits.setter
    def Inherits(self, value: bool) -> bool: ...
    @property
    def IsAttached(self) -> bool: ...
    @IsAttached.setter
    def IsAttached(self, value: bool) -> bool: ...
    @property
    def IsDirect(self) -> bool: ...
    @IsDirect.setter
    def IsDirect(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def OwnerType(self) -> typing.Type[typing.Any]: ...
    @property
    def PropertyType(self) -> typing.Type[typing.Any]: ...
    def Bind(self) -> IndexerDescriptor: ...
    def GetHashCode(self) -> int: ...
    def IsValidValue(self, value: typing.Any) -> bool: ...
    def __eq__(self, a: AvaloniaProperty, b: AvaloniaProperty) -> bool: ...
    def __ne__(self, a: AvaloniaProperty, b: AvaloniaProperty) -> bool: ...
    # Operator not supported op_LogicalNot(property: AvaloniaProperty)
    def __invert__(self, property: AvaloniaProperty) -> IndexerDescriptor: ...
    def ToString(self) -> str: ...
    def Unregister(self, type: typing.Type[typing.Any]) -> None: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: AvaloniaProperty) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped GetMetadata due to it being static, abstract and generic.

    GetMetadata : GetMetadata_MethodGroup
    class GetMetadata_MethodGroup:
        def __getitem__(self, t:typing.Type[GetMetadata_1_T1]) -> GetMetadata_1[GetMetadata_1_T1]: ...

        GetMetadata_1_T1 = typing.TypeVar('GetMetadata_1_T1')
        class GetMetadata_1(typing.Generic[GetMetadata_1_T1]):
            GetMetadata_1_T = AvaloniaProperty_0.GetMetadata_MethodGroup.GetMetadata_1_T1
            def __call__(self) -> AvaloniaPropertyMetadata:...

        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> AvaloniaPropertyMetadata:...
        @typing.overload
        def __call__(self, owner: AvaloniaObject) -> AvaloniaPropertyMetadata:...

    # Skipped Register due to it being static, abstract and generic.

    Register : Register_MethodGroup
    class Register_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[Register_2_T1], typing.Type[Register_2_T2]]) -> Register_2[Register_2_T1, Register_2_T2]: ...

        Register_2_T1 = typing.TypeVar('Register_2_T1')
        Register_2_T2 = typing.TypeVar('Register_2_T2')
        class Register_2(typing.Generic[Register_2_T1, Register_2_T2]):
            Register_2_TOwner = AvaloniaProperty_0.Register_MethodGroup.Register_2_T1
            Register_2_TValue = AvaloniaProperty_0.Register_MethodGroup.Register_2_T2
            def __call__(self, name: str, defaultValue: Register_2_TValue = ..., inherits: bool = ..., defaultBindingMode: BindingMode = ..., validate: Func_2[Register_2_TValue, bool] = ..., coerce: Func_3[AvaloniaObject, Register_2_TValue, Register_2_TValue] = ..., enableDataValidation: bool = ...) -> StyledProperty_1[Register_2_TValue]:...


    # Skipped RegisterAttached due to it being static, abstract and generic.

    RegisterAttached : RegisterAttached_MethodGroup
    class RegisterAttached_MethodGroup:
        @typing.overload
        def __getitem__(self, t:typing.Tuple[typing.Type[RegisterAttached_3_T1], typing.Type[RegisterAttached_3_T2], typing.Type[RegisterAttached_3_T3]]) -> RegisterAttached_3[RegisterAttached_3_T1, RegisterAttached_3_T2, RegisterAttached_3_T3]: ...

        RegisterAttached_3_T1 = typing.TypeVar('RegisterAttached_3_T1')
        RegisterAttached_3_T2 = typing.TypeVar('RegisterAttached_3_T2')
        RegisterAttached_3_T3 = typing.TypeVar('RegisterAttached_3_T3')
        class RegisterAttached_3(typing.Generic[RegisterAttached_3_T1, RegisterAttached_3_T2, RegisterAttached_3_T3]):
            RegisterAttached_3_TOwner = AvaloniaProperty_0.RegisterAttached_MethodGroup.RegisterAttached_3_T1
            RegisterAttached_3_THost = AvaloniaProperty_0.RegisterAttached_MethodGroup.RegisterAttached_3_T2
            RegisterAttached_3_TValue = AvaloniaProperty_0.RegisterAttached_MethodGroup.RegisterAttached_3_T3
            def __call__(self, name: str, defaultValue: RegisterAttached_3_TValue = ..., inherits: bool = ..., defaultBindingMode: BindingMode = ..., validate: Func_2[RegisterAttached_3_TValue, bool] = ..., coerce: Func_3[AvaloniaObject, RegisterAttached_3_TValue, RegisterAttached_3_TValue] = ...) -> AttachedProperty_1[RegisterAttached_3_TValue]:...

        @typing.overload
        def __getitem__(self, t:typing.Tuple[typing.Type[RegisterAttached_2_T1], typing.Type[RegisterAttached_2_T2]]) -> RegisterAttached_2[RegisterAttached_2_T1, RegisterAttached_2_T2]: ...

        RegisterAttached_2_T1 = typing.TypeVar('RegisterAttached_2_T1')
        RegisterAttached_2_T2 = typing.TypeVar('RegisterAttached_2_T2')
        class RegisterAttached_2(typing.Generic[RegisterAttached_2_T1, RegisterAttached_2_T2]):
            RegisterAttached_2_THost = AvaloniaProperty_0.RegisterAttached_MethodGroup.RegisterAttached_2_T1
            RegisterAttached_2_TValue = AvaloniaProperty_0.RegisterAttached_MethodGroup.RegisterAttached_2_T2
            def __call__(self, name: str, ownerType: typing.Type[typing.Any], defaultValue: RegisterAttached_2_TValue = ..., inherits: bool = ..., defaultBindingMode: BindingMode = ..., validate: Func_2[RegisterAttached_2_TValue, bool] = ..., coerce: Func_3[AvaloniaObject, RegisterAttached_2_TValue, RegisterAttached_2_TValue] = ...) -> AttachedProperty_1[RegisterAttached_2_TValue]:...


    # Skipped RegisterDirect due to it being static, abstract and generic.

    RegisterDirect : RegisterDirect_MethodGroup
    class RegisterDirect_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[RegisterDirect_2_T1], typing.Type[RegisterDirect_2_T2]]) -> RegisterDirect_2[RegisterDirect_2_T1, RegisterDirect_2_T2]: ...

        RegisterDirect_2_T1 = typing.TypeVar('RegisterDirect_2_T1')
        RegisterDirect_2_T2 = typing.TypeVar('RegisterDirect_2_T2')
        class RegisterDirect_2(typing.Generic[RegisterDirect_2_T1, RegisterDirect_2_T2]):
            RegisterDirect_2_TOwner = AvaloniaProperty_0.RegisterDirect_MethodGroup.RegisterDirect_2_T1
            RegisterDirect_2_TValue = AvaloniaProperty_0.RegisterDirect_MethodGroup.RegisterDirect_2_T2
            def __call__(self, name: str, getter: Func_2[RegisterDirect_2_TOwner, RegisterDirect_2_TValue], setter: Action_2[RegisterDirect_2_TOwner, RegisterDirect_2_TValue] = ..., unsetValue: RegisterDirect_2_TValue = ..., defaultBindingMode: BindingMode = ..., enableDataValidation: bool = ...) -> DirectProperty_2[RegisterDirect_2_TOwner, RegisterDirect_2_TValue]:...




AvaloniaProperty_1_TValue = typing.TypeVar('AvaloniaProperty_1_TValue')
class AvaloniaProperty_1(typing.Generic[AvaloniaProperty_1_TValue], AvaloniaProperty_0):
    @property
    def Changed(self) -> IObservable_1[AvaloniaPropertyChangedEventArgs_1[AvaloniaProperty_1_TValue]]: ...
    @property
    def Changed(self) -> IObservable_1[AvaloniaPropertyChangedEventArgs]: ...
    @property
    def Inherits(self) -> bool: ...
    @Inherits.setter
    def Inherits(self, value: bool) -> bool: ...
    @property
    def IsAttached(self) -> bool: ...
    @IsAttached.setter
    def IsAttached(self, value: bool) -> bool: ...
    @property
    def IsDirect(self) -> bool: ...
    @IsDirect.setter
    def IsDirect(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def OwnerType(self) -> typing.Type[typing.Any]: ...
    @property
    def PropertyType(self) -> typing.Type[typing.Any]: ...


class AvaloniaPropertyChangedEventArgs_GenericClasses(abc.ABCMeta):
    Generic_AvaloniaPropertyChangedEventArgs_GenericClasses_AvaloniaPropertyChangedEventArgs_1_T = typing.TypeVar('Generic_AvaloniaPropertyChangedEventArgs_GenericClasses_AvaloniaPropertyChangedEventArgs_1_T')
    def __getitem__(self, types : typing.Type[Generic_AvaloniaPropertyChangedEventArgs_GenericClasses_AvaloniaPropertyChangedEventArgs_1_T]) -> typing.Type[AvaloniaPropertyChangedEventArgs_1[Generic_AvaloniaPropertyChangedEventArgs_GenericClasses_AvaloniaPropertyChangedEventArgs_1_T]]: ...

class AvaloniaPropertyChangedEventArgs(AvaloniaPropertyChangedEventArgs_0, metaclass =AvaloniaPropertyChangedEventArgs_GenericClasses): ...

class AvaloniaPropertyChangedEventArgs_0(EventArgs, abc.ABC):
    def __init__(self, sender: AvaloniaObject, priority: BindingPriority) -> None: ...
    @property
    def NewValue(self) -> typing.Any: ...
    @property
    def OldValue(self) -> typing.Any: ...
    @property
    def Priority(self) -> BindingPriority: ...
    @Priority.setter
    def Priority(self, value: BindingPriority) -> BindingPriority: ...
    @property
    def Property(self) -> AvaloniaProperty: ...
    @property
    def Sender(self) -> AvaloniaObject: ...


AvaloniaPropertyChangedEventArgs_1_T = typing.TypeVar('AvaloniaPropertyChangedEventArgs_1_T')
class AvaloniaPropertyChangedEventArgs_1(typing.Generic[AvaloniaPropertyChangedEventArgs_1_T], AvaloniaPropertyChangedEventArgs_0):
    def __init__(self, sender: AvaloniaObject, property: AvaloniaProperty_1[AvaloniaPropertyChangedEventArgs_1_T], oldValue: Optional_1[AvaloniaPropertyChangedEventArgs_1_T], newValue: BindingValue_1[AvaloniaPropertyChangedEventArgs_1_T], priority: BindingPriority) -> None: ...
    @property
    def NewValue(self) -> BindingValue_1[AvaloniaPropertyChangedEventArgs_1_T]: ...
    @NewValue.setter
    def NewValue(self, value: BindingValue_1[AvaloniaPropertyChangedEventArgs_1_T]) -> BindingValue_1[AvaloniaPropertyChangedEventArgs_1_T]: ...
    @property
    def NewValue(self) -> typing.Any: ...
    @property
    def OldValue(self) -> Optional_1[AvaloniaPropertyChangedEventArgs_1_T]: ...
    @OldValue.setter
    def OldValue(self, value: Optional_1[AvaloniaPropertyChangedEventArgs_1_T]) -> Optional_1[AvaloniaPropertyChangedEventArgs_1_T]: ...
    @property
    def OldValue(self) -> typing.Any: ...
    @property
    def Priority(self) -> BindingPriority: ...
    @property
    def Property(self) -> AvaloniaProperty_1[AvaloniaPropertyChangedEventArgs_1_T]: ...
    @property
    def Property(self) -> AvaloniaProperty: ...
    @property
    def Sender(self) -> AvaloniaObject: ...


class AvaloniaPropertyMetadata(abc.ABC):
    def __init__(self, defaultBindingMode: BindingMode = ..., enableDataValidation: typing.Optional[bool] = ...) -> None: ...
    @property
    def DefaultBindingMode(self) -> BindingMode: ...
    @property
    def EnableDataValidation(self) -> typing.Optional[bool]: ...
    @EnableDataValidation.setter
    def EnableDataValidation(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    def Freeze(self) -> None: ...
    @abc.abstractmethod
    def GenerateTypeSafeMetadata(self) -> AvaloniaPropertyMetadata: ...
    def Merge(self, baseMetadata: AvaloniaPropertyMetadata, property: AvaloniaProperty) -> None: ...


class CornerRadius(IEquatable_1[CornerRadius]):
    @typing.overload
    def __init__(self, top: float, bottom: float) -> None: ...
    @typing.overload
    def __init__(self, topLeft: float, topRight: float, bottomRight: float, bottomLeft: float) -> None: ...
    @typing.overload
    def __init__(self, uniformRadius: float) -> None: ...
    @property
    def BottomLeft(self) -> float: ...
    @property
    def BottomRight(self) -> float: ...
    @property
    def IsUniform(self) -> bool: ...
    @property
    def TopLeft(self) -> float: ...
    @property
    def TopRight(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: CornerRadius, right: CornerRadius) -> bool: ...
    def __ne__(self, left: CornerRadius, right: CornerRadius) -> bool: ...
    @staticmethod
    def Parse(s: str) -> CornerRadius: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: CornerRadius) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class DirectProperty_GenericClasses(abc.ABCMeta):
    Generic_DirectProperty_GenericClasses_DirectProperty_2_TOwner = typing.TypeVar('Generic_DirectProperty_GenericClasses_DirectProperty_2_TOwner')
    Generic_DirectProperty_GenericClasses_DirectProperty_2_TValue = typing.TypeVar('Generic_DirectProperty_GenericClasses_DirectProperty_2_TValue')
    def __getitem__(self, types : typing.Tuple[typing.Type[Generic_DirectProperty_GenericClasses_DirectProperty_2_TOwner], typing.Type[Generic_DirectProperty_GenericClasses_DirectProperty_2_TValue]]) -> typing.Type[DirectProperty_2[Generic_DirectProperty_GenericClasses_DirectProperty_2_TOwner, Generic_DirectProperty_GenericClasses_DirectProperty_2_TValue]]: ...

DirectProperty : DirectProperty_GenericClasses

DirectProperty_2_TOwner = typing.TypeVar('DirectProperty_2_TOwner')
DirectProperty_2_TValue = typing.TypeVar('DirectProperty_2_TValue')
class DirectProperty_2(typing.Generic[DirectProperty_2_TOwner, DirectProperty_2_TValue], DirectPropertyBase_1[DirectProperty_2_TValue]):
    @property
    def Changed(self) -> IObservable_1[AvaloniaPropertyChangedEventArgs_1[DirectProperty_2_TValue]]: ...
    @property
    def Changed(self) -> IObservable_1[AvaloniaPropertyChangedEventArgs]: ...
    @property
    def Getter(self) -> Func_2[DirectProperty_2_TOwner, DirectProperty_2_TValue]: ...
    @property
    def Inherits(self) -> bool: ...
    @Inherits.setter
    def Inherits(self, value: bool) -> bool: ...
    @property
    def IsAttached(self) -> bool: ...
    @IsAttached.setter
    def IsAttached(self, value: bool) -> bool: ...
    @property
    def IsDirect(self) -> bool: ...
    @IsDirect.setter
    def IsDirect(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def Owner(self) -> typing.Type[typing.Any]: ...
    @property
    def OwnerType(self) -> typing.Type[typing.Any]: ...
    @property
    def PropertyType(self) -> typing.Type[typing.Any]: ...
    @property
    def Setter(self) -> Action_2[DirectProperty_2_TOwner, DirectProperty_2_TValue]: ...
    # Skipped AddOwner due to it being static, abstract and generic.

    AddOwner : AddOwner_MethodGroup[DirectProperty_2_TOwner, DirectProperty_2_TValue]
    AddOwner_MethodGroup_DirectProperty_2_TOwner = typing.TypeVar('AddOwner_MethodGroup_DirectProperty_2_TOwner')
    AddOwner_MethodGroup_DirectProperty_2_TValue = typing.TypeVar('AddOwner_MethodGroup_DirectProperty_2_TValue')
    class AddOwner_MethodGroup(typing.Generic[AddOwner_MethodGroup_DirectProperty_2_TOwner, AddOwner_MethodGroup_DirectProperty_2_TValue]):
        AddOwner_MethodGroup_DirectProperty_2_TOwner = DirectProperty_2.AddOwner_MethodGroup_DirectProperty_2_TOwner
        AddOwner_MethodGroup_DirectProperty_2_TValue = DirectProperty_2.AddOwner_MethodGroup_DirectProperty_2_TValue
        def __getitem__(self, t:typing.Type[AddOwner_1_T1]) -> AddOwner_1[AddOwner_MethodGroup_DirectProperty_2_TOwner, AddOwner_MethodGroup_DirectProperty_2_TValue, AddOwner_1_T1]: ...

        AddOwner_1_DirectProperty_2_TOwner = typing.TypeVar('AddOwner_1_DirectProperty_2_TOwner')
        AddOwner_1_DirectProperty_2_TValue = typing.TypeVar('AddOwner_1_DirectProperty_2_TValue')
        AddOwner_1_T1 = typing.TypeVar('AddOwner_1_T1')
        class AddOwner_1(typing.Generic[AddOwner_1_DirectProperty_2_TOwner, AddOwner_1_DirectProperty_2_TValue, AddOwner_1_T1]):
            AddOwner_1_DirectProperty_2_TOwner = DirectProperty_2.AddOwner_MethodGroup.AddOwner_1_DirectProperty_2_TOwner
            AddOwner_1_DirectProperty_2_TValue = DirectProperty_2.AddOwner_MethodGroup.AddOwner_1_DirectProperty_2_TValue
            AddOwner_1_TNewOwner = DirectProperty_2.AddOwner_MethodGroup.AddOwner_1_T1
            def __call__(self, getter: Func_2[AddOwner_1_TNewOwner, AddOwner_1_DirectProperty_2_TValue], setter: Action_2[AddOwner_1_TNewOwner, AddOwner_1_DirectProperty_2_TValue] = ..., unsetValue: AddOwner_1_DirectProperty_2_TValue = ..., defaultBindingMode: BindingMode = ..., enableDataValidation: bool = ...) -> DirectProperty_2[AddOwner_1_TNewOwner, AddOwner_1_DirectProperty_2_TValue]:...




class DirectPropertyBase_GenericClasses(abc.ABCMeta):
    Generic_DirectPropertyBase_GenericClasses_DirectPropertyBase_1_TValue = typing.TypeVar('Generic_DirectPropertyBase_GenericClasses_DirectPropertyBase_1_TValue')
    def __getitem__(self, types : typing.Type[Generic_DirectPropertyBase_GenericClasses_DirectPropertyBase_1_TValue]) -> typing.Type[DirectPropertyBase_1[Generic_DirectPropertyBase_GenericClasses_DirectPropertyBase_1_TValue]]: ...

DirectPropertyBase : DirectPropertyBase_GenericClasses

DirectPropertyBase_1_TValue = typing.TypeVar('DirectPropertyBase_1_TValue')
class DirectPropertyBase_1(typing.Generic[DirectPropertyBase_1_TValue], AvaloniaProperty_1[DirectPropertyBase_1_TValue]):
    @property
    def Changed(self) -> IObservable_1[AvaloniaPropertyChangedEventArgs_1[DirectPropertyBase_1_TValue]]: ...
    @property
    def Changed(self) -> IObservable_1[AvaloniaPropertyChangedEventArgs]: ...
    @property
    def Inherits(self) -> bool: ...
    @Inherits.setter
    def Inherits(self, value: bool) -> bool: ...
    @property
    def IsAttached(self) -> bool: ...
    @IsAttached.setter
    def IsAttached(self, value: bool) -> bool: ...
    @property
    def IsDirect(self) -> bool: ...
    @IsDirect.setter
    def IsDirect(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def Owner(self) -> typing.Type[typing.Any]: ...
    @property
    def OwnerType(self) -> typing.Type[typing.Any]: ...
    @property
    def PropertyType(self) -> typing.Type[typing.Any]: ...
    # Skipped GetMetadata due to it being static, abstract and generic.

    GetMetadata : GetMetadata_MethodGroup[DirectPropertyBase_1_TValue]
    GetMetadata_MethodGroup_DirectPropertyBase_1_TValue = typing.TypeVar('GetMetadata_MethodGroup_DirectPropertyBase_1_TValue')
    class GetMetadata_MethodGroup(typing.Generic[GetMetadata_MethodGroup_DirectPropertyBase_1_TValue]):
        GetMetadata_MethodGroup_DirectPropertyBase_1_TValue = DirectPropertyBase_1.GetMetadata_MethodGroup_DirectPropertyBase_1_TValue
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> DirectPropertyMetadata_1[GetMetadata_MethodGroup_DirectPropertyBase_1_TValue]:...
        @typing.overload
        def __call__(self, owner: AvaloniaObject) -> DirectPropertyMetadata_1[GetMetadata_MethodGroup_DirectPropertyBase_1_TValue]:...

    # Skipped GetUnsetValue due to it being static, abstract and generic.

    GetUnsetValue : GetUnsetValue_MethodGroup[DirectPropertyBase_1_TValue]
    GetUnsetValue_MethodGroup_DirectPropertyBase_1_TValue = typing.TypeVar('GetUnsetValue_MethodGroup_DirectPropertyBase_1_TValue')
    class GetUnsetValue_MethodGroup(typing.Generic[GetUnsetValue_MethodGroup_DirectPropertyBase_1_TValue]):
        GetUnsetValue_MethodGroup_DirectPropertyBase_1_TValue = DirectPropertyBase_1.GetUnsetValue_MethodGroup_DirectPropertyBase_1_TValue
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> GetUnsetValue_MethodGroup_DirectPropertyBase_1_TValue:...
        @typing.overload
        def __call__(self, owner: AvaloniaObject) -> GetUnsetValue_MethodGroup_DirectPropertyBase_1_TValue:...

    # Skipped OverrideMetadata due to it being static, abstract and generic.

    OverrideMetadata : OverrideMetadata_MethodGroup[DirectPropertyBase_1_TValue]
    OverrideMetadata_MethodGroup_DirectPropertyBase_1_TValue = typing.TypeVar('OverrideMetadata_MethodGroup_DirectPropertyBase_1_TValue')
    class OverrideMetadata_MethodGroup(typing.Generic[OverrideMetadata_MethodGroup_DirectPropertyBase_1_TValue]):
        OverrideMetadata_MethodGroup_DirectPropertyBase_1_TValue = DirectPropertyBase_1.OverrideMetadata_MethodGroup_DirectPropertyBase_1_TValue
        def __getitem__(self, t:typing.Type[OverrideMetadata_1_T1]) -> OverrideMetadata_1[OverrideMetadata_MethodGroup_DirectPropertyBase_1_TValue, OverrideMetadata_1_T1]: ...

        OverrideMetadata_1_DirectPropertyBase_1_TValue = typing.TypeVar('OverrideMetadata_1_DirectPropertyBase_1_TValue')
        OverrideMetadata_1_T1 = typing.TypeVar('OverrideMetadata_1_T1')
        class OverrideMetadata_1(typing.Generic[OverrideMetadata_1_DirectPropertyBase_1_TValue, OverrideMetadata_1_T1]):
            OverrideMetadata_1_DirectPropertyBase_1_TValue = DirectPropertyBase_1.OverrideMetadata_MethodGroup.OverrideMetadata_1_DirectPropertyBase_1_TValue
            OverrideMetadata_1_T = DirectPropertyBase_1.OverrideMetadata_MethodGroup.OverrideMetadata_1_T1
            def __call__(self, metadata: DirectPropertyMetadata_1[OverrideMetadata_1_DirectPropertyBase_1_TValue]) -> None:...

        def __call__(self, type: typing.Type[typing.Any], metadata: DirectPropertyMetadata_1[OverrideMetadata_MethodGroup_DirectPropertyBase_1_TValue]) -> None:...



class DirectPropertyMetadata_GenericClasses(abc.ABCMeta):
    Generic_DirectPropertyMetadata_GenericClasses_DirectPropertyMetadata_1_TValue = typing.TypeVar('Generic_DirectPropertyMetadata_GenericClasses_DirectPropertyMetadata_1_TValue')
    def __getitem__(self, types : typing.Type[Generic_DirectPropertyMetadata_GenericClasses_DirectPropertyMetadata_1_TValue]) -> typing.Type[DirectPropertyMetadata_1[Generic_DirectPropertyMetadata_GenericClasses_DirectPropertyMetadata_1_TValue]]: ...

DirectPropertyMetadata : DirectPropertyMetadata_GenericClasses

DirectPropertyMetadata_1_TValue = typing.TypeVar('DirectPropertyMetadata_1_TValue')
class DirectPropertyMetadata_1(typing.Generic[DirectPropertyMetadata_1_TValue], AvaloniaPropertyMetadata, IDirectPropertyMetadata):
    def __init__(self, unsetValue: DirectPropertyMetadata_1_TValue = ..., defaultBindingMode: BindingMode = ..., enableDataValidation: typing.Optional[bool] = ...) -> None: ...
    @property
    def DefaultBindingMode(self) -> BindingMode: ...
    @property
    def EnableDataValidation(self) -> typing.Optional[bool]: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def UnsetValue(self) -> DirectPropertyMetadata_1_TValue: ...
    @UnsetValue.setter
    def UnsetValue(self, value: DirectPropertyMetadata_1_TValue) -> DirectPropertyMetadata_1_TValue: ...
    def GenerateTypeSafeMetadata(self) -> AvaloniaPropertyMetadata: ...
    def Merge(self, baseMetadata: AvaloniaPropertyMetadata, property: AvaloniaProperty) -> None: ...


class IAvaloniaDependencyResolver(typing.Protocol):
    @abc.abstractmethod
    def GetService(self, t: typing.Type[typing.Any]) -> typing.Any: ...


class IDataContextProvider(typing.Protocol):
    @property
    def DataContext(self) -> typing.Any: ...
    @DataContext.setter
    def DataContext(self, value: typing.Any) -> typing.Any: ...


class IDescription(typing.Protocol):
    @property
    def Description(self) -> str: ...


class IDirectPropertyMetadata(typing.Protocol):
    @property
    def EnableDataValidation(self) -> typing.Optional[bool]: ...
    @property
    def UnsetValue(self) -> typing.Any: ...


class INamed(typing.Protocol):
    @property
    def Name(self) -> str: ...


class IStyledPropertyMetadata(typing.Protocol):
    @property
    def DefaultValue(self) -> typing.Any: ...


class Matrix(IEquatable_1[Matrix]):
    @typing.overload
    def __init__(self, scaleX: float, skewY: float, perspX: float, skewX: float, scaleY: float, perspY: float, offsetX: float, offsetY: float, perspZ: float) -> None: ...
    @typing.overload
    def __init__(self, scaleX: float, skewY: float, skewX: float, scaleY: float, offsetX: float, offsetY: float) -> None: ...
    @property
    def HasInverse(self) -> bool: ...
    @classmethod
    @property
    def Identity(cls) -> Matrix: ...
    @property
    def IsIdentity(self) -> bool: ...
    @property
    def M11(self) -> float: ...
    @property
    def M12(self) -> float: ...
    @property
    def M13(self) -> float: ...
    @property
    def M21(self) -> float: ...
    @property
    def M22(self) -> float: ...
    @property
    def M23(self) -> float: ...
    @property
    def M31(self) -> float: ...
    @property
    def M32(self) -> float: ...
    @property
    def M33(self) -> float: ...
    def Append(self, value: Matrix) -> Matrix: ...
    def ContainsPerspective(self) -> bool: ...
    @staticmethod
    def CreateRotation(radians: float) -> Matrix: ...
    @staticmethod
    def CreateSkew(xAngle: float, yAngle: float) -> Matrix: ...
    def GetDeterminant(self) -> float: ...
    def GetHashCode(self) -> int: ...
    def Invert(self) -> Matrix: ...
    def __eq__(self, value1: Matrix, value2: Matrix) -> bool: ...
    def __ne__(self, value1: Matrix, value2: Matrix) -> bool: ...
    def __mul__(self, value1: Matrix, value2: Matrix) -> Matrix: ...
    def __neg__(self, value: Matrix) -> Matrix: ...
    @staticmethod
    def Parse(s: str) -> Matrix: ...
    def Prepend(self, value: Matrix) -> Matrix: ...
    @staticmethod
    def ToRadians(angle: float) -> float: ...
    def ToString(self) -> str: ...
    def Transform(self, p: Point) -> Point: ...
    @staticmethod
    def TryDecomposeTransform(matrix: Matrix, decomposed: clr.Reference[Matrix.Decomposed]) -> bool: ...
    def TryInvert(self, inverted: clr.Reference[Matrix]) -> bool: ...
    # Skipped CreateScale due to it being static, abstract and generic.

    CreateScale : CreateScale_MethodGroup
    class CreateScale_MethodGroup:
        @typing.overload
        def __call__(self, scales: Vector) -> Matrix:...
        @typing.overload
        def __call__(self, xScale: float, yScale: float) -> Matrix:...

    # Skipped CreateTranslation due to it being static, abstract and generic.

    CreateTranslation : CreateTranslation_MethodGroup
    class CreateTranslation_MethodGroup:
        @typing.overload
        def __call__(self, position: Vector) -> Matrix:...
        @typing.overload
        def __call__(self, xPosition: float, yPosition: float) -> Matrix:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Matrix) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...


    class Decomposed(IEquatable_1[Matrix.Decomposed]):
        Angle : float
        Scale : Vector
        Skew : Vector
        Translate : Vector
        def GetHashCode(self) -> int: ...
        def __eq__(self, left: Matrix.Decomposed, right: Matrix.Decomposed) -> bool: ...
        def __ne__(self, left: Matrix.Decomposed, right: Matrix.Decomposed) -> bool: ...
        def ToString(self) -> str: ...
        # Skipped Equals due to it being static, abstract and generic.

        Equals : Equals_MethodGroup
        class Equals_MethodGroup:
            @typing.overload
            def __call__(self, other: Matrix.Decomposed) -> bool:...
            @typing.overload
            def __call__(self, obj: typing.Any) -> bool:...




class PixelPoint(IEquatable_1[PixelPoint]):
    def __init__(self, x: int, y: int) -> None: ...
    Origin : PixelPoint
    @property
    def X(self) -> int: ...
    @property
    def Y(self) -> int: ...
    def GetHashCode(self) -> int: ...
    @typing.overload
    def __add__(self, a: PixelPoint, b: PixelPoint) -> PixelPoint: ...
    @typing.overload
    def __add__(self, a: PixelPoint, b: PixelVector) -> PixelPoint: ...
    def __eq__(self, left: PixelPoint, right: PixelPoint) -> bool: ...
    # Operator not supported op_Implicit(p: PixelPoint)
    def __ne__(self, left: PixelPoint, right: PixelPoint) -> bool: ...
    @typing.overload
    def __sub__(self, a: PixelPoint, b: PixelPoint) -> PixelPoint: ...
    @typing.overload
    def __sub__(self, a: PixelPoint, b: PixelVector) -> PixelPoint: ...
    @staticmethod
    def Parse(s: str) -> PixelPoint: ...
    def ToString(self) -> str: ...
    def WithX(self, x: int) -> PixelPoint: ...
    def WithY(self, y: int) -> PixelPoint: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: PixelPoint) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped FromPoint due to it being static, abstract and generic.

    FromPoint : FromPoint_MethodGroup
    class FromPoint_MethodGroup:
        @typing.overload
        def __call__(self, point: Point, scale: float) -> PixelPoint:...
        @typing.overload
        def __call__(self, point: Point, scale: Vector) -> PixelPoint:...

    # Skipped FromPointWithDpi due to it being static, abstract and generic.

    FromPointWithDpi : FromPointWithDpi_MethodGroup
    class FromPointWithDpi_MethodGroup:
        @typing.overload
        def __call__(self, point: Point, dpi: float) -> PixelPoint:...
        @typing.overload
        def __call__(self, point: Point, dpi: Vector) -> PixelPoint:...

    # Skipped ToPoint due to it being static, abstract and generic.

    ToPoint : ToPoint_MethodGroup
    class ToPoint_MethodGroup:
        @typing.overload
        def __call__(self, scale: float) -> Point:...
        @typing.overload
        def __call__(self, scale: Vector) -> Point:...

    # Skipped ToPointWithDpi due to it being static, abstract and generic.

    ToPointWithDpi : ToPointWithDpi_MethodGroup
    class ToPointWithDpi_MethodGroup:
        @typing.overload
        def __call__(self, dpi: float) -> Point:...
        @typing.overload
        def __call__(self, dpi: Vector) -> Point:...



class PixelRect(IEquatable_1[PixelRect]):
    @typing.overload
    def __init__(self, position: PixelPoint, size: PixelSize) -> None: ...
    @typing.overload
    def __init__(self, size: PixelSize) -> None: ...
    @typing.overload
    def __init__(self, topLeft: PixelPoint, bottomRight: PixelPoint) -> None: ...
    @typing.overload
    def __init__(self, x: int, y: int, width: int, height: int) -> None: ...
    @property
    def Bottom(self) -> int: ...
    @property
    def BottomLeft(self) -> PixelPoint: ...
    @property
    def BottomRight(self) -> PixelPoint: ...
    @property
    def Center(self) -> PixelPoint: ...
    @property
    def Height(self) -> int: ...
    @property
    def Position(self) -> PixelPoint: ...
    @property
    def Right(self) -> int: ...
    @property
    def Size(self) -> PixelSize: ...
    @property
    def TopLeft(self) -> PixelPoint: ...
    @property
    def TopRight(self) -> PixelPoint: ...
    @property
    def Width(self) -> int: ...
    @property
    def X(self) -> int: ...
    @property
    def Y(self) -> int: ...
    def CenterRect(self, rect: PixelRect) -> PixelRect: ...
    def ContainsExclusive(self, p: PixelPoint) -> bool: ...
    def GetHashCode(self) -> int: ...
    def Intersect(self, rect: PixelRect) -> PixelRect: ...
    def Intersects(self, rect: PixelRect) -> bool: ...
    def __eq__(self, left: PixelRect, right: PixelRect) -> bool: ...
    def __ne__(self, left: PixelRect, right: PixelRect) -> bool: ...
    @staticmethod
    def Parse(s: str) -> PixelRect: ...
    def ToString(self) -> str: ...
    def Translate(self, offset: PixelVector) -> PixelRect: ...
    def Union(self, rect: PixelRect) -> PixelRect: ...
    def WithHeight(self, height: int) -> PixelRect: ...
    def WithWidth(self, width: int) -> PixelRect: ...
    def WithX(self, x: int) -> PixelRect: ...
    def WithY(self, y: int) -> PixelRect: ...
    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, p: PixelPoint) -> bool:...
        @typing.overload
        def __call__(self, r: PixelRect) -> bool:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: PixelRect) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped FromRect due to it being static, abstract and generic.

    FromRect : FromRect_MethodGroup
    class FromRect_MethodGroup:
        @typing.overload
        def __call__(self, rect: Rect, scale: float) -> PixelRect:...
        @typing.overload
        def __call__(self, rect: Rect, scale: Vector) -> PixelRect:...

    # Skipped FromRectWithDpi due to it being static, abstract and generic.

    FromRectWithDpi : FromRectWithDpi_MethodGroup
    class FromRectWithDpi_MethodGroup:
        @typing.overload
        def __call__(self, rect: Rect, dpi: float) -> PixelRect:...
        @typing.overload
        def __call__(self, rect: Rect, dpi: Vector) -> PixelRect:...

    # Skipped ToRect due to it being static, abstract and generic.

    ToRect : ToRect_MethodGroup
    class ToRect_MethodGroup:
        @typing.overload
        def __call__(self, scale: float) -> Rect:...
        @typing.overload
        def __call__(self, scale: Vector) -> Rect:...

    # Skipped ToRectWithDpi due to it being static, abstract and generic.

    ToRectWithDpi : ToRectWithDpi_MethodGroup
    class ToRectWithDpi_MethodGroup:
        @typing.overload
        def __call__(self, dpi: float) -> Rect:...
        @typing.overload
        def __call__(self, dpi: Vector) -> Rect:...



class PixelSize(IEquatable_1[PixelSize]):
    def __init__(self, width: int, height: int) -> None: ...
    Empty : PixelSize
    @property
    def AspectRatio(self) -> float: ...
    @property
    def Height(self) -> int: ...
    @property
    def Width(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: PixelSize, right: PixelSize) -> bool: ...
    def __ne__(self, left: PixelSize, right: PixelSize) -> bool: ...
    @staticmethod
    def Parse(s: str) -> PixelSize: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(source: str, result: clr.Reference[PixelSize]) -> bool: ...
    def WithHeight(self, height: int) -> PixelSize: ...
    def WithWidth(self, width: int) -> PixelSize: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: PixelSize) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped FromSize due to it being static, abstract and generic.

    FromSize : FromSize_MethodGroup
    class FromSize_MethodGroup:
        @typing.overload
        def __call__(self, size: Size, scale: float) -> PixelSize:...
        @typing.overload
        def __call__(self, size: Size, scale: Vector) -> PixelSize:...

    # Skipped FromSizeWithDpi due to it being static, abstract and generic.

    FromSizeWithDpi : FromSizeWithDpi_MethodGroup
    class FromSizeWithDpi_MethodGroup:
        @typing.overload
        def __call__(self, size: Size, dpi: float) -> PixelSize:...
        @typing.overload
        def __call__(self, size: Size, dpi: Vector) -> PixelSize:...

    # Skipped ToSize due to it being static, abstract and generic.

    ToSize : ToSize_MethodGroup
    class ToSize_MethodGroup:
        @typing.overload
        def __call__(self, scale: float) -> Size:...
        @typing.overload
        def __call__(self, scale: Vector) -> Size:...

    # Skipped ToSizeWithDpi due to it being static, abstract and generic.

    ToSizeWithDpi : ToSizeWithDpi_MethodGroup
    class ToSizeWithDpi_MethodGroup:
        @typing.overload
        def __call__(self, dpi: float) -> Size:...
        @typing.overload
        def __call__(self, dpi: Vector) -> Size:...



class PixelVector:
    def __init__(self, x: int, y: int) -> None: ...
    @property
    def Length(self) -> float: ...
    @property
    def X(self) -> int: ...
    @property
    def Y(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def NearlyEquals(self, other: PixelVector) -> bool: ...
    def __add__(self, a: PixelVector, b: PixelVector) -> PixelVector: ...
    def __truediv__(self, vector: PixelVector, scale: int) -> PixelVector: ...
    def __eq__(self, left: PixelVector, right: PixelVector) -> bool: ...
    # Operator not supported op_Explicit(a: PixelVector)
    def __ne__(self, left: PixelVector, right: PixelVector) -> bool: ...
    @typing.overload
    def __mul__(self, vector: PixelVector, scale: int) -> PixelVector: ...
    @typing.overload
    def __mul__(self, a: PixelVector, b: PixelVector) -> int: ...
    def __sub__(self, a: PixelVector, b: PixelVector) -> PixelVector: ...
    def __neg__(self, a: PixelVector) -> PixelVector: ...
    def ToString(self) -> str: ...
    def WithX(self, x: int) -> PixelVector: ...
    def WithY(self, y: int) -> PixelVector: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: PixelVector) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class Point(IEquatable_1[Point]):
    def __init__(self, x: float, y: float) -> None: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    def Deconstruct(self, x: clr.Reference[float], y: clr.Reference[float]) -> None: ...
    @staticmethod
    def Distance(value1: Point, value2: Point) -> float: ...
    def GetHashCode(self) -> int: ...
    def NearlyEquals(self, other: Point) -> bool: ...
    @typing.overload
    def __add__(self, a: Point, b: Point) -> Point: ...
    @typing.overload
    def __add__(self, a: Point, b: Vector) -> Point: ...
    def __truediv__(self, p: Point, k: float) -> Point: ...
    def __eq__(self, left: Point, right: Point) -> bool: ...
    # Operator not supported op_Implicit(p: Point)
    def __ne__(self, left: Point, right: Point) -> bool: ...
    @typing.overload
    def __mul__(self, k: float, p: Point) -> Point: ...
    @typing.overload
    def __mul__(self, p: Point, k: float) -> Point: ...
    @typing.overload
    def __mul__(self, point: Point, matrix: Matrix) -> Point: ...
    @typing.overload
    def __sub__(self, a: Point, b: Point) -> Point: ...
    @typing.overload
    def __sub__(self, a: Point, b: Vector) -> Point: ...
    def __neg__(self, a: Point) -> Point: ...
    @staticmethod
    def Parse(s: str) -> Point: ...
    def ToString(self) -> str: ...
    def Transform(self, transform: Matrix) -> Point: ...
    def WithX(self, x: float) -> Point: ...
    def WithY(self, y: float) -> Point: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Point) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class Rect(IEquatable_1[Rect]):
    @typing.overload
    def __init__(self, position: Point, size: Size) -> None: ...
    @typing.overload
    def __init__(self, size: Size) -> None: ...
    @typing.overload
    def __init__(self, topLeft: Point, bottomRight: Point) -> None: ...
    @typing.overload
    def __init__(self, x: float, y: float, width: float, height: float) -> None: ...
    @property
    def Bottom(self) -> float: ...
    @property
    def BottomLeft(self) -> Point: ...
    @property
    def BottomRight(self) -> Point: ...
    @property
    def Center(self) -> Point: ...
    @property
    def Height(self) -> float: ...
    @property
    def Left(self) -> float: ...
    @property
    def Position(self) -> Point: ...
    @property
    def Right(self) -> float: ...
    @property
    def Size(self) -> Size: ...
    @property
    def Top(self) -> float: ...
    @property
    def TopLeft(self) -> Point: ...
    @property
    def TopRight(self) -> Point: ...
    @property
    def Width(self) -> float: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    def CenterRect(self, rect: Rect) -> Rect: ...
    def ContainsExclusive(self, p: Point) -> bool: ...
    def GetHashCode(self) -> int: ...
    def Intersect(self, rect: Rect) -> Rect: ...
    def Intersects(self, rect: Rect) -> bool: ...
    def Normalize(self) -> Rect: ...
    def __truediv__(self, rect: Rect, scale: Vector) -> Rect: ...
    def __eq__(self, left: Rect, right: Rect) -> bool: ...
    def __ne__(self, left: Rect, right: Rect) -> bool: ...
    @typing.overload
    def __mul__(self, rect: Rect, scale: float) -> Rect: ...
    @typing.overload
    def __mul__(self, rect: Rect, scale: Vector) -> Rect: ...
    @staticmethod
    def Parse(s: str) -> Rect: ...
    def ToString(self) -> str: ...
    def TransformToAABB(self, matrix: Matrix) -> Rect: ...
    def Translate(self, offset: Vector) -> Rect: ...
    def Union(self, rect: Rect) -> Rect: ...
    def WithHeight(self, height: float) -> Rect: ...
    def WithWidth(self, width: float) -> Rect: ...
    def WithX(self, x: float) -> Rect: ...
    def WithY(self, y: float) -> Rect: ...
    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, p: Point) -> bool:...
        @typing.overload
        def __call__(self, r: Rect) -> bool:...

    # Skipped Deflate due to it being static, abstract and generic.

    Deflate : Deflate_MethodGroup
    class Deflate_MethodGroup:
        @typing.overload
        def __call__(self, thickness: float) -> Rect:...
        @typing.overload
        def __call__(self, thickness: Thickness) -> Rect:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Rect) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped Inflate due to it being static, abstract and generic.

    Inflate : Inflate_MethodGroup
    class Inflate_MethodGroup:
        @typing.overload
        def __call__(self, thickness: float) -> Rect:...
        @typing.overload
        def __call__(self, thickness: Thickness) -> Rect:...



class RelativePoint(IEquatable_1[RelativePoint]):
    @typing.overload
    def __init__(self, point: Point, unit: RelativeUnit) -> None: ...
    @typing.overload
    def __init__(self, x: float, y: float, unit: RelativeUnit) -> None: ...
    BottomRight : RelativePoint
    Center : RelativePoint
    TopLeft : RelativePoint
    @property
    def Point(self) -> Point: ...
    @property
    def Unit(self) -> RelativeUnit: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: RelativePoint, right: RelativePoint) -> bool: ...
    def __ne__(self, left: RelativePoint, right: RelativePoint) -> bool: ...
    @staticmethod
    def Parse(s: str) -> RelativePoint: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, p: RelativePoint) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped ToPixels due to it being static, abstract and generic.

    ToPixels : ToPixels_MethodGroup
    class ToPixels_MethodGroup:
        @typing.overload
        def __call__(self, rect: Rect) -> Point:...
        @typing.overload
        def __call__(self, size: Size) -> Point:...



class RelativeUnit(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Relative : RelativeUnit # 0
    Absolute : RelativeUnit # 1


class RoundedRect:
    @typing.overload
    def __init__(self, bounds: clr.Reference[Rect], radius: clr.Reference[CornerRadius]) -> None: ...
    @typing.overload
    def __init__(self, rect: Rect) -> None: ...
    @typing.overload
    def __init__(self, rect: Rect, radii: Vector) -> None: ...
    @typing.overload
    def __init__(self, rect: Rect, radiiTopLeft: Vector, radiiTopRight: Vector, radiiBottomRight: Vector, radiiBottomLeft: Vector) -> None: ...
    @typing.overload
    def __init__(self, rect: Rect, radius: float) -> None: ...
    @typing.overload
    def __init__(self, rect: Rect, radiusTopLeft: float, radiusTopRight: float, radiusBottomRight: float, radiusBottomLeft: float) -> None: ...
    @typing.overload
    def __init__(self, rect: Rect, radiusX: float, radiusY: float) -> None: ...
    @property
    def IsRounded(self) -> bool: ...
    @property
    def IsUniform(self) -> bool: ...
    @property
    def RadiiBottomLeft(self) -> Vector: ...
    @property
    def RadiiBottomRight(self) -> Vector: ...
    @property
    def RadiiTopLeft(self) -> Vector: ...
    @property
    def RadiiTopRight(self) -> Vector: ...
    @property
    def Rect(self) -> Rect: ...
    def ContainsExclusive(self, p: Point) -> bool: ...
    def Deflate(self, dx: float, dy: float) -> RoundedRect: ...
    def GetHashCode(self) -> int: ...
    def Inflate(self, dx: float, dy: float) -> RoundedRect: ...
    def __eq__(self, left: RoundedRect, right: RoundedRect) -> bool: ...
    # Operator not supported op_Implicit(r: Rect)
    def __ne__(self, left: RoundedRect, right: RoundedRect) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: RoundedRect) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class Size(IEquatable_1[Size]):
    @typing.overload
    def __init__(self, vector2: Vector2) -> None: ...
    @typing.overload
    def __init__(self, width: float, height: float) -> None: ...
    Infinity : Size
    @property
    def AspectRatio(self) -> float: ...
    @property
    def Height(self) -> float: ...
    @property
    def Width(self) -> float: ...
    def Constrain(self, constraint: Size) -> Size: ...
    def Deconstruct(self, width: clr.Reference[float], height: clr.Reference[float]) -> None: ...
    def Deflate(self, thickness: Thickness) -> Size: ...
    def GetHashCode(self) -> int: ...
    def Inflate(self, thickness: Thickness) -> Size: ...
    def NearlyEquals(self, other: Size) -> bool: ...
    def __add__(self, size: Size, toAdd: Size) -> Size: ...
    @typing.overload
    def __truediv__(self, size: Size, scale: float) -> Size: ...
    @typing.overload
    def __truediv__(self, left: Size, right: Size) -> Vector: ...
    @typing.overload
    def __truediv__(self, size: Size, scale: Vector) -> Size: ...
    def __eq__(self, left: Size, right: Size) -> bool: ...
    def __ne__(self, left: Size, right: Size) -> bool: ...
    @typing.overload
    def __mul__(self, size: Size, scale: float) -> Size: ...
    @typing.overload
    def __mul__(self, size: Size, scale: Vector) -> Size: ...
    def __sub__(self, size: Size, toSubtract: Size) -> Size: ...
    @staticmethod
    def Parse(s: str) -> Size: ...
    def ToString(self) -> str: ...
    def WithHeight(self, height: float) -> Size: ...
    def WithWidth(self, width: float) -> Size: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Size) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class StyledElement(Animatable, IThemeVariantHost, IStyleable, ISupportInitialize, ISetInheritanceParent, ISetLogicalParent, IStyleHost, ILogical, IDataContextProvider):
    def __init__(self) -> None: ...
    DataContextProperty : StyledProperty_1[typing.Any]
    NameProperty : DirectProperty_2[StyledElement, str]
    ParentProperty : DirectProperty_2[StyledElement, StyledElement]
    TemplatedParentProperty : DirectProperty_2[StyledElement, AvaloniaObject]
    ThemeProperty : StyledProperty_1[ControlTheme]
    @property
    def ActualThemeVariant(self) -> ThemeVariant: ...
    @property
    def Classes(self) -> Classes: ...
    @property
    def DataContext(self) -> typing.Any: ...
    @DataContext.setter
    def DataContext(self, value: typing.Any) -> typing.Any: ...
    @property
    def IsInitialized(self) -> bool: ...
    @IsInitialized.setter
    def IsInitialized(self, value: bool) -> bool: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Parent(self) -> StyledElement: ...
    @Parent.setter
    def Parent(self, value: StyledElement) -> StyledElement: ...
    @property
    def Resources(self) -> IResourceDictionary: ...
    @Resources.setter
    def Resources(self, value: IResourceDictionary) -> IResourceDictionary: ...
    @property
    def StyleKey(self) -> typing.Type[typing.Any]: ...
    @property
    def Styles(self) -> Styles: ...
    @property
    def TemplatedParent(self) -> AvaloniaObject: ...
    @TemplatedParent.setter
    def TemplatedParent(self, value: AvaloniaObject) -> AvaloniaObject: ...
    @property
    def Theme(self) -> ControlTheme: ...
    @Theme.setter
    def Theme(self, value: ControlTheme) -> ControlTheme: ...
    @property
    def Transitions(self) -> Transitions: ...
    @Transitions.setter
    def Transitions(self, value: Transitions) -> Transitions: ...
    def ApplyStyling(self) -> bool: ...
    def BeginInit(self) -> None: ...
    def EndInit(self) -> None: ...
    def TryGetResource(self, key: typing.Any, theme: ThemeVariant, value: clr.Reference[typing.Any]) -> bool: ...
    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


class StyledProperty_GenericClasses(abc.ABCMeta):
    Generic_StyledProperty_GenericClasses_StyledProperty_1_TValue = typing.TypeVar('Generic_StyledProperty_GenericClasses_StyledProperty_1_TValue')
    def __getitem__(self, types : typing.Type[Generic_StyledProperty_GenericClasses_StyledProperty_1_TValue]) -> typing.Type[StyledProperty_1[Generic_StyledProperty_GenericClasses_StyledProperty_1_TValue]]: ...

StyledProperty : StyledProperty_GenericClasses

StyledProperty_1_TValue = typing.TypeVar('StyledProperty_1_TValue')
class StyledProperty_1(typing.Generic[StyledProperty_1_TValue], AvaloniaProperty_1[StyledProperty_1_TValue]):
    @property
    def Changed(self) -> IObservable_1[AvaloniaPropertyChangedEventArgs_1[StyledProperty_1_TValue]]: ...
    @property
    def Changed(self) -> IObservable_1[AvaloniaPropertyChangedEventArgs]: ...
    @property
    def Inherits(self) -> bool: ...
    @Inherits.setter
    def Inherits(self, value: bool) -> bool: ...
    @property
    def IsAttached(self) -> bool: ...
    @IsAttached.setter
    def IsAttached(self, value: bool) -> bool: ...
    @property
    def IsDirect(self) -> bool: ...
    @IsDirect.setter
    def IsDirect(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def OwnerType(self) -> typing.Type[typing.Any]: ...
    @property
    def PropertyType(self) -> typing.Type[typing.Any]: ...
    @property
    def ValidateValue(self) -> Func_2[StyledProperty_1_TValue, bool]: ...
    def CoerceValue(self, instance: AvaloniaObject, baseValue: StyledProperty_1_TValue) -> StyledProperty_1_TValue: ...
    def ToString(self) -> str: ...
    # Skipped AddOwner due to it being static, abstract and generic.

    AddOwner : AddOwner_MethodGroup[StyledProperty_1_TValue]
    AddOwner_MethodGroup_StyledProperty_1_TValue = typing.TypeVar('AddOwner_MethodGroup_StyledProperty_1_TValue')
    class AddOwner_MethodGroup(typing.Generic[AddOwner_MethodGroup_StyledProperty_1_TValue]):
        AddOwner_MethodGroup_StyledProperty_1_TValue = StyledProperty_1.AddOwner_MethodGroup_StyledProperty_1_TValue
        def __getitem__(self, t:typing.Type[AddOwner_1_T1]) -> AddOwner_1[AddOwner_MethodGroup_StyledProperty_1_TValue, AddOwner_1_T1]: ...

        AddOwner_1_StyledProperty_1_TValue = typing.TypeVar('AddOwner_1_StyledProperty_1_TValue')
        AddOwner_1_T1 = typing.TypeVar('AddOwner_1_T1')
        class AddOwner_1(typing.Generic[AddOwner_1_StyledProperty_1_TValue, AddOwner_1_T1]):
            AddOwner_1_StyledProperty_1_TValue = StyledProperty_1.AddOwner_MethodGroup.AddOwner_1_StyledProperty_1_TValue
            AddOwner_1_TOwner = StyledProperty_1.AddOwner_MethodGroup.AddOwner_1_T1
            def __call__(self, metadata: StyledPropertyMetadata_1[AddOwner_1_StyledProperty_1_TValue] = ...) -> StyledProperty_1[AddOwner_1_StyledProperty_1_TValue]:...


    # Skipped GetDefaultValue due to it being static, abstract and generic.

    GetDefaultValue : GetDefaultValue_MethodGroup[StyledProperty_1_TValue]
    GetDefaultValue_MethodGroup_StyledProperty_1_TValue = typing.TypeVar('GetDefaultValue_MethodGroup_StyledProperty_1_TValue')
    class GetDefaultValue_MethodGroup(typing.Generic[GetDefaultValue_MethodGroup_StyledProperty_1_TValue]):
        GetDefaultValue_MethodGroup_StyledProperty_1_TValue = StyledProperty_1.GetDefaultValue_MethodGroup_StyledProperty_1_TValue
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> GetDefaultValue_MethodGroup_StyledProperty_1_TValue:...
        @typing.overload
        def __call__(self, owner: AvaloniaObject) -> GetDefaultValue_MethodGroup_StyledProperty_1_TValue:...

    # Skipped GetMetadata due to it being static, abstract and generic.

    GetMetadata : GetMetadata_MethodGroup[StyledProperty_1_TValue]
    GetMetadata_MethodGroup_StyledProperty_1_TValue = typing.TypeVar('GetMetadata_MethodGroup_StyledProperty_1_TValue')
    class GetMetadata_MethodGroup(typing.Generic[GetMetadata_MethodGroup_StyledProperty_1_TValue]):
        GetMetadata_MethodGroup_StyledProperty_1_TValue = StyledProperty_1.GetMetadata_MethodGroup_StyledProperty_1_TValue
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> StyledPropertyMetadata_1[GetMetadata_MethodGroup_StyledProperty_1_TValue]:...
        @typing.overload
        def __call__(self, owner: AvaloniaObject) -> StyledPropertyMetadata_1[GetMetadata_MethodGroup_StyledProperty_1_TValue]:...

    # Skipped OverrideDefaultValue due to it being static, abstract and generic.

    OverrideDefaultValue : OverrideDefaultValue_MethodGroup[StyledProperty_1_TValue]
    OverrideDefaultValue_MethodGroup_StyledProperty_1_TValue = typing.TypeVar('OverrideDefaultValue_MethodGroup_StyledProperty_1_TValue')
    class OverrideDefaultValue_MethodGroup(typing.Generic[OverrideDefaultValue_MethodGroup_StyledProperty_1_TValue]):
        OverrideDefaultValue_MethodGroup_StyledProperty_1_TValue = StyledProperty_1.OverrideDefaultValue_MethodGroup_StyledProperty_1_TValue
        def __getitem__(self, t:typing.Type[OverrideDefaultValue_1_T1]) -> OverrideDefaultValue_1[OverrideDefaultValue_MethodGroup_StyledProperty_1_TValue, OverrideDefaultValue_1_T1]: ...

        OverrideDefaultValue_1_StyledProperty_1_TValue = typing.TypeVar('OverrideDefaultValue_1_StyledProperty_1_TValue')
        OverrideDefaultValue_1_T1 = typing.TypeVar('OverrideDefaultValue_1_T1')
        class OverrideDefaultValue_1(typing.Generic[OverrideDefaultValue_1_StyledProperty_1_TValue, OverrideDefaultValue_1_T1]):
            OverrideDefaultValue_1_StyledProperty_1_TValue = StyledProperty_1.OverrideDefaultValue_MethodGroup.OverrideDefaultValue_1_StyledProperty_1_TValue
            OverrideDefaultValue_1_T = StyledProperty_1.OverrideDefaultValue_MethodGroup.OverrideDefaultValue_1_T1
            def __call__(self, defaultValue: OverrideDefaultValue_1_StyledProperty_1_TValue) -> None:...

        def __call__(self, type: typing.Type[typing.Any], defaultValue: OverrideDefaultValue_MethodGroup_StyledProperty_1_TValue) -> None:...

    # Skipped OverrideMetadata due to it being static, abstract and generic.

    OverrideMetadata : OverrideMetadata_MethodGroup[StyledProperty_1_TValue]
    OverrideMetadata_MethodGroup_StyledProperty_1_TValue = typing.TypeVar('OverrideMetadata_MethodGroup_StyledProperty_1_TValue')
    class OverrideMetadata_MethodGroup(typing.Generic[OverrideMetadata_MethodGroup_StyledProperty_1_TValue]):
        OverrideMetadata_MethodGroup_StyledProperty_1_TValue = StyledProperty_1.OverrideMetadata_MethodGroup_StyledProperty_1_TValue
        def __getitem__(self, t:typing.Type[OverrideMetadata_1_T1]) -> OverrideMetadata_1[OverrideMetadata_MethodGroup_StyledProperty_1_TValue, OverrideMetadata_1_T1]: ...

        OverrideMetadata_1_StyledProperty_1_TValue = typing.TypeVar('OverrideMetadata_1_StyledProperty_1_TValue')
        OverrideMetadata_1_T1 = typing.TypeVar('OverrideMetadata_1_T1')
        class OverrideMetadata_1(typing.Generic[OverrideMetadata_1_StyledProperty_1_TValue, OverrideMetadata_1_T1]):
            OverrideMetadata_1_StyledProperty_1_TValue = StyledProperty_1.OverrideMetadata_MethodGroup.OverrideMetadata_1_StyledProperty_1_TValue
            OverrideMetadata_1_T = StyledProperty_1.OverrideMetadata_MethodGroup.OverrideMetadata_1_T1
            def __call__(self, metadata: StyledPropertyMetadata_1[OverrideMetadata_1_StyledProperty_1_TValue]) -> None:...

        def __call__(self, type: typing.Type[typing.Any], metadata: StyledPropertyMetadata_1[OverrideMetadata_MethodGroup_StyledProperty_1_TValue]) -> None:...



class StyledPropertyMetadata_GenericClasses(abc.ABCMeta):
    Generic_StyledPropertyMetadata_GenericClasses_StyledPropertyMetadata_1_TValue = typing.TypeVar('Generic_StyledPropertyMetadata_GenericClasses_StyledPropertyMetadata_1_TValue')
    def __getitem__(self, types : typing.Type[Generic_StyledPropertyMetadata_GenericClasses_StyledPropertyMetadata_1_TValue]) -> typing.Type[StyledPropertyMetadata_1[Generic_StyledPropertyMetadata_GenericClasses_StyledPropertyMetadata_1_TValue]]: ...

StyledPropertyMetadata : StyledPropertyMetadata_GenericClasses

StyledPropertyMetadata_1_TValue = typing.TypeVar('StyledPropertyMetadata_1_TValue')
class StyledPropertyMetadata_1(typing.Generic[StyledPropertyMetadata_1_TValue], AvaloniaPropertyMetadata, IStyledPropertyMetadata):
    def __init__(self, defaultValue: Optional_1[StyledPropertyMetadata_1_TValue] = ..., defaultBindingMode: BindingMode = ..., coerce: Func_3[AvaloniaObject, StyledPropertyMetadata_1_TValue, StyledPropertyMetadata_1_TValue] = ..., enableDataValidation: bool = ...) -> None: ...
    @property
    def CoerceValue(self) -> Func_3[AvaloniaObject, StyledPropertyMetadata_1_TValue, StyledPropertyMetadata_1_TValue]: ...
    @CoerceValue.setter
    def CoerceValue(self, value: Func_3[AvaloniaObject, StyledPropertyMetadata_1_TValue, StyledPropertyMetadata_1_TValue]) -> Func_3[AvaloniaObject, StyledPropertyMetadata_1_TValue, StyledPropertyMetadata_1_TValue]: ...
    @property
    def DefaultBindingMode(self) -> BindingMode: ...
    @property
    def DefaultValue(self) -> StyledPropertyMetadata_1_TValue: ...
    @property
    def EnableDataValidation(self) -> typing.Optional[bool]: ...
    @property
    def IsReadOnly(self) -> bool: ...
    def GenerateTypeSafeMetadata(self) -> AvaloniaPropertyMetadata: ...
    def Merge(self, baseMetadata: AvaloniaPropertyMetadata, property: AvaloniaProperty) -> None: ...


class Thickness(IEquatable_1[Thickness]):
    @typing.overload
    def __init__(self, horizontal: float, vertical: float) -> None: ...
    @typing.overload
    def __init__(self, left: float, top: float, right: float, bottom: float) -> None: ...
    @typing.overload
    def __init__(self, uniformLength: float) -> None: ...
    @property
    def Bottom(self) -> float: ...
    @property
    def IsUniform(self) -> bool: ...
    @property
    def Left(self) -> float: ...
    @property
    def Right(self) -> float: ...
    @property
    def Top(self) -> float: ...
    def Deconstruct(self, left: clr.Reference[float], top: clr.Reference[float], right: clr.Reference[float], bottom: clr.Reference[float]) -> None: ...
    def GetHashCode(self) -> int: ...
    @typing.overload
    def __add__(self, a: Thickness, b: Thickness) -> Thickness: ...
    @typing.overload
    def __add__(self, size: Size, thickness: Thickness) -> Size: ...
    def __eq__(self, a: Thickness, b: Thickness) -> bool: ...
    def __ne__(self, a: Thickness, b: Thickness) -> bool: ...
    def __mul__(self, a: Thickness, b: float) -> Thickness: ...
    @typing.overload
    def __sub__(self, a: Thickness, b: Thickness) -> Thickness: ...
    @typing.overload
    def __sub__(self, size: Size, thickness: Thickness) -> Size: ...
    @staticmethod
    def Parse(s: str) -> Thickness: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Thickness) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class Vector(IEquatable_1[Vector]):
    def __init__(self, x: float, y: float) -> None: ...
    @property
    def Length(self) -> float: ...
    @classmethod
    @property
    def One(cls) -> Vector: ...
    @property
    def SquaredLength(self) -> float: ...
    @classmethod
    @property
    def UnitX(cls) -> Vector: ...
    @classmethod
    @property
    def UnitY(cls) -> Vector: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    @classmethod
    @property
    def Zero(cls) -> Vector: ...
    def Abs(self) -> Vector: ...
    @staticmethod
    def Add(a: Vector, b: Vector) -> Vector: ...
    @staticmethod
    def Clamp(value: Vector, min: Vector, max: Vector) -> Vector: ...
    @staticmethod
    def Cross(a: Vector, b: Vector) -> float: ...
    def Deconstruct(self, x: clr.Reference[float], y: clr.Reference[float]) -> None: ...
    @staticmethod
    def Distance(value1: Vector, value2: Vector) -> float: ...
    @staticmethod
    def DistanceSquared(value1: Vector, value2: Vector) -> float: ...
    @staticmethod
    def Dot(a: Vector, b: Vector) -> float: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Max(left: Vector, right: Vector) -> Vector: ...
    @staticmethod
    def Min(left: Vector, right: Vector) -> Vector: ...
    def NearlyEquals(self, other: Vector) -> bool: ...
    def __add__(self, a: Vector, b: Vector) -> Vector: ...
    def __truediv__(self, vector: Vector, scale: float) -> Vector: ...
    def __eq__(self, left: Vector, right: Vector) -> bool: ...
    # Operator not supported op_Explicit(a: Vector)
    # Operator not supported op_Implicit(v: Vector2)
    def __ne__(self, left: Vector, right: Vector) -> bool: ...
    @typing.overload
    def __mul__(self, scale: float, vector: Vector) -> Vector: ...
    @typing.overload
    def __mul__(self, vector: Vector, scale: float) -> Vector: ...
    @typing.overload
    def __mul__(self, a: Vector, b: Vector) -> float: ...
    def __sub__(self, a: Vector, b: Vector) -> Vector: ...
    def __neg__(self, a: Vector) -> Vector: ...
    @staticmethod
    def Parse(s: str) -> Vector: ...
    @staticmethod
    def Subtract(a: Vector, b: Vector) -> Vector: ...
    def ToString(self) -> str: ...
    def WithX(self, x: float) -> Vector: ...
    def WithY(self, y: float) -> Vector: ...
    # Skipped Divide due to it being static, abstract and generic.

    Divide : Divide_MethodGroup
    class Divide_MethodGroup:
        @typing.overload
        def __call__(self, vector: Vector, scalar: float) -> Vector:...
        @typing.overload
        def __call__(self, a: Vector, b: Vector) -> Vector:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Vector) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped Multiply due to it being static, abstract and generic.

    Multiply : Multiply_MethodGroup
    class Multiply_MethodGroup:
        @typing.overload
        def __call__(self, vector: Vector, scalar: float) -> Vector:...
        @typing.overload
        def __call__(self, a: Vector, b: Vector) -> Vector:...

    # Skipped Negate due to it being static, abstract and generic.

    Negate : Negate_MethodGroup
    class Negate_MethodGroup:
        @typing.overload
        def __call__(self) -> Vector:...
        @typing.overload
        def __call__(self, vector: Vector) -> Vector:...

    # Skipped Normalize due to it being static, abstract and generic.

    Normalize : Normalize_MethodGroup
    class Normalize_MethodGroup:
        @typing.overload
        def __call__(self) -> Vector:...
        @typing.overload
        def __call__(self, vector: Vector) -> Vector:...



class Vector3D(IEquatable_1[Vector3D]):
    def __init__(self, X: float, Y: float, Z: float) -> None: ...
    @property
    def Length(self) -> float: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> float: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> float: ...
    @property
    def Z(self) -> float: ...
    @Z.setter
    def Z(self, value: float) -> float: ...
    def Abs(self) -> Vector3D: ...
    @staticmethod
    def Add(left: Vector3D, right: Vector3D) -> Vector3D: ...
    @staticmethod
    def Clamp(value: Vector3D, min: Vector3D, max: Vector3D) -> Vector3D: ...
    def Deconstruct(self, X: clr.Reference[float], Y: clr.Reference[float], Z: clr.Reference[float]) -> None: ...
    @staticmethod
    def Distance(value1: Vector3D, value2: Vector3D) -> float: ...
    @staticmethod
    def DistanceSquared(value1: Vector3D, value2: Vector3D) -> float: ...
    @staticmethod
    def Dot(vector1: Vector3D, vector2: Vector3D) -> float: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Max(left: Vector3D, right: Vector3D) -> Vector3D: ...
    @staticmethod
    def Min(left: Vector3D, right: Vector3D) -> Vector3D: ...
    @staticmethod
    def Normalize(value: Vector3D) -> Vector3D: ...
    def __add__(self, left: Vector3D, right: Vector3D) -> Vector3D: ...
    def __eq__(self, left: Vector3D, right: Vector3D) -> bool: ...
    # Operator not supported op_Implicit(vector: Vector3)
    def __ne__(self, left: Vector3D, right: Vector3D) -> bool: ...
    def __mul__(self, left: Vector3D, right: float) -> Vector3D: ...
    def __sub__(self, left: Vector3D, right: Vector3D) -> Vector3D: ...
    def __neg__(self, v: Vector3D) -> Vector3D: ...
    @staticmethod
    def Parse(s: str) -> Vector3D: ...
    @staticmethod
    def Substract(left: Vector3D, right: Vector3D) -> Vector3D: ...
    def ToString(self) -> str: ...
    # Skipped Divide due to it being static, abstract and generic.

    Divide : Divide_MethodGroup
    class Divide_MethodGroup:
        @typing.overload
        def __call__(self, left: Vector3D, right: float) -> Vector3D:...
        @typing.overload
        def __call__(self, left: Vector3D, right: Vector3D) -> Vector3D:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Vector3D) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped Multiply due to it being static, abstract and generic.

    Multiply : Multiply_MethodGroup
    class Multiply_MethodGroup:
        @typing.overload
        def __call__(self, left: Vector3D, right: float) -> Vector3D:...
        @typing.overload
        def __call__(self, left: Vector3D, right: Vector3D) -> Vector3D:...



class Visual(StyledElement):
    def __init__(self) -> None: ...
    BoundsProperty : DirectProperty_2[Visual, Rect]
    ClipProperty : StyledProperty_1[Geometry]
    ClipToBoundsProperty : StyledProperty_1[bool]
    EffectProperty : StyledProperty_1[IEffect]
    FlowDirectionProperty : AttachedProperty_1[FlowDirection]
    HasMirrorTransformProperty : DirectProperty_2[Visual, bool]
    IsVisibleProperty : StyledProperty_1[bool]
    OpacityMaskProperty : StyledProperty_1[IBrush]
    OpacityProperty : StyledProperty_1[float]
    RenderTransformOriginProperty : StyledProperty_1[RelativePoint]
    RenderTransformProperty : StyledProperty_1[ITransform]
    VisualParentProperty : DirectProperty_2[Visual, Visual]
    ZIndexProperty : StyledProperty_1[int]
    @property
    def ActualThemeVariant(self) -> ThemeVariant: ...
    @property
    def Bounds(self) -> Rect: ...
    @Bounds.setter
    def Bounds(self, value: Rect) -> Rect: ...
    @property
    def Classes(self) -> Classes: ...
    @property
    def Clip(self) -> Geometry: ...
    @Clip.setter
    def Clip(self, value: Geometry) -> Geometry: ...
    @property
    def ClipToBounds(self) -> bool: ...
    @ClipToBounds.setter
    def ClipToBounds(self, value: bool) -> bool: ...
    @property
    def DataContext(self) -> typing.Any: ...
    @DataContext.setter
    def DataContext(self, value: typing.Any) -> typing.Any: ...
    @property
    def Effect(self) -> IEffect: ...
    @Effect.setter
    def Effect(self, value: IEffect) -> IEffect: ...
    @property
    def FlowDirection(self) -> FlowDirection: ...
    @FlowDirection.setter
    def FlowDirection(self, value: FlowDirection) -> FlowDirection: ...
    @property
    def HasMirrorTransform(self) -> bool: ...
    @HasMirrorTransform.setter
    def HasMirrorTransform(self, value: bool) -> bool: ...
    @property
    def IsEffectivelyVisible(self) -> bool: ...
    @IsEffectivelyVisible.setter
    def IsEffectivelyVisible(self, value: bool) -> bool: ...
    @property
    def IsInitialized(self) -> bool: ...
    @property
    def IsVisible(self) -> bool: ...
    @IsVisible.setter
    def IsVisible(self, value: bool) -> bool: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Opacity(self) -> float: ...
    @Opacity.setter
    def Opacity(self, value: float) -> float: ...
    @property
    def OpacityMask(self) -> IBrush: ...
    @OpacityMask.setter
    def OpacityMask(self, value: IBrush) -> IBrush: ...
    @property
    def Parent(self) -> StyledElement: ...
    @property
    def RenderTransform(self) -> ITransform: ...
    @RenderTransform.setter
    def RenderTransform(self, value: ITransform) -> ITransform: ...
    @property
    def RenderTransformOrigin(self) -> RelativePoint: ...
    @RenderTransformOrigin.setter
    def RenderTransformOrigin(self, value: RelativePoint) -> RelativePoint: ...
    @property
    def Resources(self) -> IResourceDictionary: ...
    @Resources.setter
    def Resources(self, value: IResourceDictionary) -> IResourceDictionary: ...
    @property
    def StyleKey(self) -> typing.Type[typing.Any]: ...
    @property
    def Styles(self) -> Styles: ...
    @property
    def TemplatedParent(self) -> AvaloniaObject: ...
    @TemplatedParent.setter
    def TemplatedParent(self, value: AvaloniaObject) -> AvaloniaObject: ...
    @property
    def Theme(self) -> ControlTheme: ...
    @Theme.setter
    def Theme(self, value: ControlTheme) -> ControlTheme: ...
    @property
    def Transitions(self) -> Transitions: ...
    @Transitions.setter
    def Transitions(self, value: Transitions) -> Transitions: ...
    @property
    def ZIndex(self) -> int: ...
    @ZIndex.setter
    def ZIndex(self, value: int) -> int: ...
    @staticmethod
    def GetFlowDirection(visual: Visual) -> FlowDirection: ...
    def InvalidateVisual(self) -> None: ...
    def Render(self, context: DrawingContext) -> None: ...
    @staticmethod
    def SetFlowDirection(visual: Visual, value: FlowDirection) -> None: ...
    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


import typing, clr, abc
from Avalonia import Rect, StyledProperty_1, RelativePoint, AvaloniaProperty, Point, Matrix, RoundedRect, AvaloniaObject, Size, Visual
from System import Array_1, IEquatable_1, ReadOnlySpan_1, IDisposable, Uri, Action_1, ReadOnlyMemory_1
from Avalonia.Animation import Animatable, Transitions
from Avalonia.Data import IndexerDescriptor, IBinding
from Avalonia.Rendering.SceneGraph import ICustomDrawOperation
from Avalonia.Platform import IGeometryImpl, IOptionalFeatureProvider, IDrawingContextImpl
from Avalonia.Media.Fonts import FamilyNameCollection, FontFamilyKey
from Avalonia.Collections import AvaloniaList_1, ResetBehavior
from System.Globalization import CultureInfo
from System.Collections.Generic import IReadOnlyList_1, IEnumerable_1
from Avalonia.Media.TextFormatting import GlyphInfo, TextRunProperties, TextCollapsingProperties
from Avalonia.Media.Immutable import ImmutablePen, ImmutableTransform
from Avalonia.Media.Imaging import Bitmap, BitmapBlendingMode, BitmapInterpolationMode

class BackgroundSizing(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    InnerBorderEdge : BackgroundSizing # 0
    OuterBorderEdge : BackgroundSizing # 1
    CenterBorder : BackgroundSizing # 2


class BaselineAlignment(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Top : BaselineAlignment # 0
    Center : BaselineAlignment # 1
    Bottom : BaselineAlignment # 2
    Baseline : BaselineAlignment # 3
    TextTop : BaselineAlignment # 4
    TextBottom : BaselineAlignment # 5
    Subscript : BaselineAlignment # 6
    Superscript : BaselineAlignment # 7


class BoxShadow:
    @property
    def Blur(self) -> float: ...
    @Blur.setter
    def Blur(self, value: float) -> float: ...
    @property
    def Color(self) -> Color: ...
    @Color.setter
    def Color(self, value: Color) -> Color: ...
    @property
    def IsInset(self) -> bool: ...
    @IsInset.setter
    def IsInset(self, value: bool) -> bool: ...
    @property
    def OffsetX(self) -> float: ...
    @OffsetX.setter
    def OffsetX(self, value: float) -> float: ...
    @property
    def OffsetY(self) -> float: ...
    @OffsetY.setter
    def OffsetY(self, value: float) -> float: ...
    @property
    def Spread(self) -> float: ...
    @Spread.setter
    def Spread(self, value: float) -> float: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: BoxShadow, right: BoxShadow) -> bool: ...
    def __ne__(self, left: BoxShadow, right: BoxShadow) -> bool: ...
    @staticmethod
    def Parse(s: str) -> BoxShadow: ...
    def ToString(self) -> str: ...
    def TransformBounds(self, rect: clr.Reference[Rect]) -> Rect: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: clr.Reference[BoxShadow]) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class BoxShadows:
    @typing.overload
    def __init__(self, first: BoxShadow, rest: Array_1[BoxShadow]) -> None: ...
    @typing.overload
    def __init__(self, shadow: BoxShadow) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def HasInsetShadows(self) -> bool: ...
    def GetEnumerator(self) -> BoxShadows.BoxShadowsEnumerator: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: BoxShadows, right: BoxShadows) -> bool: ...
    def __ne__(self, left: BoxShadows, right: BoxShadows) -> bool: ...
    @staticmethod
    def Parse(s: str) -> BoxShadows: ...
    def ToString(self) -> str: ...
    def TransformBounds(self, rect: clr.Reference[Rect]) -> Rect: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: BoxShadows) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...


    class BoxShadowsEnumerator:
        def __init__(self, shadows: BoxShadows) -> None: ...
        @property
        def Current(self) -> BoxShadow: ...
        def MoveNext(self) -> bool: ...

    def __getitem__(self, c: int) -> BoxShadow: ...


class Brush(Animatable, IBrush, abc.ABC):
    OpacityProperty : StyledProperty_1[float]
    TransformOriginProperty : StyledProperty_1[RelativePoint]
    TransformProperty : StyledProperty_1[ITransform]
    @property
    def Opacity(self) -> float: ...
    @Opacity.setter
    def Opacity(self, value: float) -> float: ...
    @property
    def Transform(self) -> ITransform: ...
    @Transform.setter
    def Transform(self, value: ITransform) -> ITransform: ...
    @property
    def TransformOrigin(self) -> RelativePoint: ...
    @TransformOrigin.setter
    def TransformOrigin(self, value: RelativePoint) -> RelativePoint: ...
    @property
    def Transitions(self) -> Transitions: ...
    @Transitions.setter
    def Transitions(self, value: Transitions) -> Transitions: ...
    @staticmethod
    def Parse(s: str) -> IBrush: ...
    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


class CharacterHit(IEquatable_1[CharacterHit]):
    def __init__(self, firstCharacterIndex: int, trailingLength: int = ...) -> None: ...
    @property
    def FirstCharacterIndex(self) -> int: ...
    @property
    def TrailingLength(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: CharacterHit, right: CharacterHit) -> bool: ...
    def __ne__(self, left: CharacterHit, right: CharacterHit) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: CharacterHit) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class Color(IEquatable_1[Color]):
    def __init__(self, a: int, r: int, g: int, b: int) -> None: ...
    @property
    def A(self) -> int: ...
    @property
    def B(self) -> int: ...
    @property
    def G(self) -> int: ...
    @property
    def R(self) -> int: ...
    @staticmethod
    def FromArgb(a: int, r: int, g: int, b: int) -> Color: ...
    @staticmethod
    def FromRgb(r: int, g: int, b: int) -> Color: ...
    @staticmethod
    def FromUInt32(value: int) -> Color: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: Color, right: Color) -> bool: ...
    def __ne__(self, left: Color, right: Color) -> bool: ...
    def ToString(self) -> str: ...
    def ToUint32(self) -> int: ...
    def ToUInt32(self) -> int: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Color) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped Parse due to it being static, abstract and generic.

    Parse : Parse_MethodGroup
    class Parse_MethodGroup:
        @typing.overload
        def __call__(self, s: ReadOnlySpan_1[str]) -> Color:...
        @typing.overload
        def __call__(self, s: str) -> Color:...

    # Skipped ToHsl due to it being static, abstract and generic.

    ToHsl : ToHsl_MethodGroup
    class ToHsl_MethodGroup:
        @typing.overload
        def __call__(self) -> HslColor:...
        @typing.overload
        def __call__(self, red: int, green: int, blue: int, alpha: int = ...) -> HslColor:...

    # Skipped ToHsv due to it being static, abstract and generic.

    ToHsv : ToHsv_MethodGroup
    class ToHsv_MethodGroup:
        @typing.overload
        def __call__(self) -> HsvColor:...
        @typing.overload
        def __call__(self, red: int, green: int, blue: int, alpha: int = ...) -> HsvColor:...

    # Skipped TryParse due to it being static, abstract and generic.

    TryParse : TryParse_MethodGroup
    class TryParse_MethodGroup:
        @typing.overload
        def __call__(self, s: ReadOnlySpan_1[str], color: clr.Reference[Color]) -> bool:...
        @typing.overload
        def __call__(self, s: str, color: clr.Reference[Color]) -> bool:...



class DrawingContext(IDisposable, abc.ABC):
    @abc.abstractmethod
    def Custom(self, custom: ICustomDrawOperation) -> None: ...
    def Dispose(self) -> None: ...
    @abc.abstractmethod
    def DrawGlyphRun(self, foreground: IBrush, glyphRun: GlyphRun) -> None: ...
    def DrawLine(self, pen: IPen, p1: Point, p2: Point) -> None: ...
    def DrawText(self, text: FormattedText, origin: Point) -> None: ...
    def FillRectangle(self, brush: IBrush, rect: Rect, cornerRadius: float = ...) -> None: ...
    def PushGeometryClip(self, clip: Geometry) -> DrawingContext.PushedState: ...
    def PushOpacity(self, opacity: float) -> DrawingContext.PushedState: ...
    def PushOpacityMask(self, mask: IBrush, bounds: Rect) -> DrawingContext.PushedState: ...
    def PushPostTransform(self, matrix: Matrix) -> DrawingContext.PushedState: ...
    def PushPreTransform(self, matrix: Matrix) -> DrawingContext.PushedState: ...
    def PushRenderOptions(self, renderOptions: RenderOptions) -> DrawingContext.PushedState: ...
    def PushTransform(self, matrix: Matrix) -> DrawingContext.PushedState: ...
    def PushTransformContainer(self) -> DrawingContext.PushedState: ...
    # Skipped DrawEllipse due to it being static, abstract and generic.

    DrawEllipse : DrawEllipse_MethodGroup
    class DrawEllipse_MethodGroup:
        @typing.overload
        def __call__(self, brush: IBrush, pen: IPen, rect: Rect) -> None:...
        @typing.overload
        def __call__(self, brush: IBrush, pen: IPen, center: Point, radiusX: float, radiusY: float) -> None:...

    # Skipped DrawGeometry due to it being static, abstract and generic.

    DrawGeometry : DrawGeometry_MethodGroup
    class DrawGeometry_MethodGroup:
        @typing.overload
        def __call__(self, brush: IBrush, pen: IPen, geometry: Geometry) -> None:...
        @typing.overload
        def __call__(self, brush: IBrush, pen: IPen, geometry: IGeometryImpl) -> None:...

    # Skipped DrawImage due to it being static, abstract and generic.

    DrawImage : DrawImage_MethodGroup
    class DrawImage_MethodGroup:
        @typing.overload
        def __call__(self, source: IImage, rect: Rect) -> None:...
        @typing.overload
        def __call__(self, source: IImage, sourceRect: Rect, destRect: Rect) -> None:...

    # Skipped DrawRectangle due to it being static, abstract and generic.

    DrawRectangle : DrawRectangle_MethodGroup
    class DrawRectangle_MethodGroup:
        @typing.overload
        def __call__(self, pen: IPen, rect: Rect, cornerRadius: float = ...) -> None:...
        @typing.overload
        def __call__(self, brush: IBrush, pen: IPen, rrect: RoundedRect, boxShadows: BoxShadows = ...) -> None:...
        @typing.overload
        def __call__(self, brush: IBrush, pen: IPen, rect: Rect, radiusX: float = ..., radiusY: float = ..., boxShadows: BoxShadows = ...) -> None:...

    # Skipped PushClip due to it being static, abstract and generic.

    PushClip : PushClip_MethodGroup
    class PushClip_MethodGroup:
        @typing.overload
        def __call__(self, clip: RoundedRect) -> DrawingContext.PushedState:...
        @typing.overload
        def __call__(self, clip: Rect) -> DrawingContext.PushedState:...


    class PushedState(IEquatable_1[DrawingContext.PushedState], IDisposable):
        def __init__(self, context: DrawingContext) -> None: ...
        def Dispose(self) -> None: ...
        def GetHashCode(self) -> int: ...
        def __eq__(self, left: DrawingContext.PushedState, right: DrawingContext.PushedState) -> bool: ...
        def __ne__(self, left: DrawingContext.PushedState, right: DrawingContext.PushedState) -> bool: ...
        def ToString(self) -> str: ...
        # Skipped Equals due to it being static, abstract and generic.

        Equals : Equals_MethodGroup
        class Equals_MethodGroup:
            @typing.overload
            def __call__(self, other: DrawingContext.PushedState) -> bool:...
            @typing.overload
            def __call__(self, obj: typing.Any) -> bool:...




class EdgeMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unspecified : EdgeMode # 0
    Antialias : EdgeMode # 1
    Aliased : EdgeMode # 2


class FlowDirection(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    LeftToRight : FlowDirection # 0
    RightToLeft : FlowDirection # 1


class FontFamily:
    @typing.overload
    def __init__(self, baseUri: Uri, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    DefaultFontFamilyName : str
    @classmethod
    @property
    def Default(cls) -> FontFamily: ...
    @property
    def FamilyNames(self) -> FamilyNameCollection: ...
    @property
    def Key(self) -> FontFamilyKey: ...
    @property
    def Name(self) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: FontFamily, b: FontFamily) -> bool: ...
    # Operator not supported op_Implicit(s: String)
    def __ne__(self, a: FontFamily, b: FontFamily) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Parse due to it being static, abstract and generic.

    Parse : Parse_MethodGroup
    class Parse_MethodGroup:
        @typing.overload
        def __call__(self, s: str) -> FontFamily:...
        @typing.overload
        def __call__(self, s: str, baseUri: Uri) -> FontFamily:...



class FontFeature(IEquatable_1[FontFeature]):
    def __init__(self) -> None: ...
    @property
    def End(self) -> int: ...
    @End.setter
    def End(self, value: int) -> int: ...
    @property
    def Start(self) -> int: ...
    @Start.setter
    def Start(self, value: int) -> int: ...
    @property
    def Tag(self) -> str: ...
    @Tag.setter
    def Tag(self, value: str) -> str: ...
    @property
    def Value(self) -> int: ...
    @Value.setter
    def Value(self, value: int) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: FontFeature, right: FontFeature) -> bool: ...
    def __ne__(self, left: FontFeature, right: FontFeature) -> bool: ...
    @staticmethod
    def Parse(s: str) -> FontFeature: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: FontFeature) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class FontFeatureCollection(AvaloniaList_1[FontFeature]):
    def __init__(self) -> None: ...
    @property
    def Capacity(self) -> int: ...
    @Capacity.setter
    def Capacity(self, value: int) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def ResetBehavior(self) -> ResetBehavior: ...
    @ResetBehavior.setter
    def ResetBehavior(self, value: ResetBehavior) -> ResetBehavior: ...
    @property
    def Validate(self) -> Action_1[FontFeature]: ...
    @Validate.setter
    def Validate(self, value: Action_1[FontFeature]) -> Action_1[FontFeature]: ...
    def __getitem__(self, index: int) -> FontFeature: ...
    def __setitem__(self, index: int, value: FontFeature) -> None: ...


class FontMetrics(IEquatable_1[FontMetrics]):
    @property
    def Ascent(self) -> int: ...
    @Ascent.setter
    def Ascent(self, value: int) -> int: ...
    @property
    def Descent(self) -> int: ...
    @Descent.setter
    def Descent(self, value: int) -> int: ...
    @property
    def DesignEmHeight(self) -> int: ...
    @DesignEmHeight.setter
    def DesignEmHeight(self, value: int) -> int: ...
    @property
    def IsFixedPitch(self) -> bool: ...
    @IsFixedPitch.setter
    def IsFixedPitch(self, value: bool) -> bool: ...
    @property
    def LineGap(self) -> int: ...
    @LineGap.setter
    def LineGap(self, value: int) -> int: ...
    @property
    def LineSpacing(self) -> int: ...
    @property
    def StrikethroughPosition(self) -> int: ...
    @StrikethroughPosition.setter
    def StrikethroughPosition(self, value: int) -> int: ...
    @property
    def StrikethroughThickness(self) -> int: ...
    @StrikethroughThickness.setter
    def StrikethroughThickness(self, value: int) -> int: ...
    @property
    def UnderlinePosition(self) -> int: ...
    @UnderlinePosition.setter
    def UnderlinePosition(self, value: int) -> int: ...
    @property
    def UnderlineThickness(self) -> int: ...
    @UnderlineThickness.setter
    def UnderlineThickness(self, value: int) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: FontMetrics, right: FontMetrics) -> bool: ...
    def __ne__(self, left: FontMetrics, right: FontMetrics) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: FontMetrics) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class FontSimulations(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : FontSimulations # 0
    Bold : FontSimulations # 1
    Oblique : FontSimulations # 2


class FontStretch(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UltraCondensed : FontStretch # 1
    ExtraCondensed : FontStretch # 2
    Condensed : FontStretch # 3
    SemiCondensed : FontStretch # 4
    Normal : FontStretch # 5
    SemiExpanded : FontStretch # 6
    Expanded : FontStretch # 7
    ExtraExpanded : FontStretch # 8
    UltraExpanded : FontStretch # 9


class FontStyle(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Normal : FontStyle # 0
    Italic : FontStyle # 1
    Oblique : FontStyle # 2


class FontWeight(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Thin : FontWeight # 100
    ExtraLight : FontWeight # 200
    UltraLight : FontWeight # 200
    Light : FontWeight # 300
    SemiLight : FontWeight # 350
    Normal : FontWeight # 400
    Regular : FontWeight # 400
    Medium : FontWeight # 500
    DemiBold : FontWeight # 600
    SemiBold : FontWeight # 600
    Bold : FontWeight # 700
    ExtraBold : FontWeight # 800
    UltraBold : FontWeight # 800
    Black : FontWeight # 900
    Heavy : FontWeight # 900
    Solid : FontWeight # 900
    ExtraBlack : FontWeight # 950
    UltraBlack : FontWeight # 950


class FormattedText:
    def __init__(self, textToFormat: str, culture: CultureInfo, flowDirection: FlowDirection, typeface: Typeface, emSize: float, foreground: IBrush) -> None: ...
    DefaultIdealToReal : float
    DefaultRealToIdeal : float
    GreatestMultiplierOfEm : float
    IdealInfiniteWidth : int
    RealInfiniteWidth : float
    @property
    def Baseline(self) -> float: ...
    @property
    def Extent(self) -> float: ...
    @property
    def FlowDirection(self) -> FlowDirection: ...
    @FlowDirection.setter
    def FlowDirection(self, value: FlowDirection) -> FlowDirection: ...
    @property
    def Height(self) -> float: ...
    @property
    def LineHeight(self) -> float: ...
    @LineHeight.setter
    def LineHeight(self, value: float) -> float: ...
    @property
    def MaxLineCount(self) -> int: ...
    @MaxLineCount.setter
    def MaxLineCount(self, value: int) -> int: ...
    @property
    def MaxTextHeight(self) -> float: ...
    @MaxTextHeight.setter
    def MaxTextHeight(self, value: float) -> float: ...
    @property
    def MaxTextWidth(self) -> float: ...
    @MaxTextWidth.setter
    def MaxTextWidth(self, value: float) -> float: ...
    @property
    def OverhangAfter(self) -> float: ...
    @property
    def OverhangLeading(self) -> float: ...
    @property
    def OverhangTrailing(self) -> float: ...
    @property
    def TextAlignment(self) -> TextAlignment: ...
    @TextAlignment.setter
    def TextAlignment(self, value: TextAlignment) -> TextAlignment: ...
    @property
    def Trimming(self) -> TextTrimming: ...
    @Trimming.setter
    def Trimming(self, value: TextTrimming) -> TextTrimming: ...
    @property
    def Width(self) -> float: ...
    @property
    def WidthIncludingTrailingWhitespace(self) -> float: ...
    def BuildGeometry(self, origin: Point) -> Geometry: ...
    def GetMaxTextWidths(self) -> Array_1[float]: ...
    def SetMaxTextWidths(self, maxTextWidths: Array_1[float]) -> None: ...
    # Skipped BuildHighlightGeometry due to it being static, abstract and generic.

    BuildHighlightGeometry : BuildHighlightGeometry_MethodGroup
    class BuildHighlightGeometry_MethodGroup:
        @typing.overload
        def __call__(self, origin: Point) -> Geometry:...
        @typing.overload
        def __call__(self, origin: Point, startIndex: int, count: int) -> Geometry:...

    # Skipped SetCulture due to it being static, abstract and generic.

    SetCulture : SetCulture_MethodGroup
    class SetCulture_MethodGroup:
        @typing.overload
        def __call__(self, culture: CultureInfo) -> None:...
        @typing.overload
        def __call__(self, culture: CultureInfo, startIndex: int, count: int) -> None:...

    # Skipped SetFontFamily due to it being static, abstract and generic.

    SetFontFamily : SetFontFamily_MethodGroup
    class SetFontFamily_MethodGroup:
        @typing.overload
        def __call__(self, fontFamily: str) -> None:...
        @typing.overload
        def __call__(self, fontFamily: FontFamily) -> None:...
        @typing.overload
        def __call__(self, fontFamily: str, startIndex: int, count: int) -> None:...
        @typing.overload
        def __call__(self, fontFamily: FontFamily, startIndex: int, count: int) -> None:...

    # Skipped SetFontFeatures due to it being static, abstract and generic.

    SetFontFeatures : SetFontFeatures_MethodGroup
    class SetFontFeatures_MethodGroup:
        @typing.overload
        def __call__(self, fontFeatures: FontFeatureCollection) -> None:...
        @typing.overload
        def __call__(self, fontFeatures: FontFeatureCollection, startIndex: int, count: int) -> None:...

    # Skipped SetFontSize due to it being static, abstract and generic.

    SetFontSize : SetFontSize_MethodGroup
    class SetFontSize_MethodGroup:
        @typing.overload
        def __call__(self, emSize: float) -> None:...
        @typing.overload
        def __call__(self, emSize: float, startIndex: int, count: int) -> None:...

    # Skipped SetFontStyle due to it being static, abstract and generic.

    SetFontStyle : SetFontStyle_MethodGroup
    class SetFontStyle_MethodGroup:
        @typing.overload
        def __call__(self, style: FontStyle) -> None:...
        @typing.overload
        def __call__(self, style: FontStyle, startIndex: int, count: int) -> None:...

    # Skipped SetFontTypeface due to it being static, abstract and generic.

    SetFontTypeface : SetFontTypeface_MethodGroup
    class SetFontTypeface_MethodGroup:
        @typing.overload
        def __call__(self, typeface: Typeface) -> None:...
        @typing.overload
        def __call__(self, typeface: Typeface, startIndex: int, count: int) -> None:...

    # Skipped SetFontWeight due to it being static, abstract and generic.

    SetFontWeight : SetFontWeight_MethodGroup
    class SetFontWeight_MethodGroup:
        @typing.overload
        def __call__(self, weight: FontWeight) -> None:...
        @typing.overload
        def __call__(self, weight: FontWeight, startIndex: int, count: int) -> None:...

    # Skipped SetForegroundBrush due to it being static, abstract and generic.

    SetForegroundBrush : SetForegroundBrush_MethodGroup
    class SetForegroundBrush_MethodGroup:
        @typing.overload
        def __call__(self, foregroundBrush: IBrush) -> None:...
        @typing.overload
        def __call__(self, foregroundBrush: IBrush, startIndex: int, count: int) -> None:...

    # Skipped SetTextDecorations due to it being static, abstract and generic.

    SetTextDecorations : SetTextDecorations_MethodGroup
    class SetTextDecorations_MethodGroup:
        @typing.overload
        def __call__(self, textDecorations: TextDecorationCollection) -> None:...
        @typing.overload
        def __call__(self, textDecorations: TextDecorationCollection, startIndex: int, count: int) -> None:...



class Geometry(AvaloniaObject, abc.ABC):
    TransformProperty : StyledProperty_1[Transform]
    @property
    def Bounds(self) -> Rect: ...
    @property
    def ContourLength(self) -> float: ...
    @property
    def Transform(self) -> Transform: ...
    @Transform.setter
    def Transform(self, value: Transform) -> Transform: ...
    @abc.abstractmethod
    def Clone(self) -> Geometry: ...
    @staticmethod
    def Combine(geometry1: Geometry, geometry2: RectangleGeometry, combineMode: GeometryCombineMode, transform: Transform = ...) -> Geometry: ...
    def FillContains(self, point: Point) -> bool: ...
    def GetRenderBounds(self, pen: IPen) -> Rect: ...
    def GetWidenedGeometry(self, pen: IPen) -> Geometry: ...
    @staticmethod
    def Parse(s: str) -> Geometry: ...
    def StrokeContains(self, pen: IPen, point: Point) -> bool: ...
    def TryGetPointAndTangentAtDistance(self, distance: float, point: clr.Reference[Point], tangent: clr.Reference[Point]) -> bool: ...
    def TryGetPointAtDistance(self, distance: float, point: clr.Reference[Point]) -> bool: ...
    def TryGetSegment(self, startDistance: float, stopDistance: float, startOnBeginFigure: bool, segmentGeometry: clr.Reference[Geometry]) -> bool: ...
    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


class GeometryCombineMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Union : GeometryCombineMode # 0
    Intersect : GeometryCombineMode # 1
    Xor : GeometryCombineMode # 2
    Exclude : GeometryCombineMode # 3


class GlyphMetrics(IEquatable_1[GlyphMetrics]):
    @property
    def Height(self) -> int: ...
    @Height.setter
    def Height(self, value: int) -> int: ...
    @property
    def Width(self) -> int: ...
    @Width.setter
    def Width(self, value: int) -> int: ...
    @property
    def XBearing(self) -> int: ...
    @XBearing.setter
    def XBearing(self, value: int) -> int: ...
    @property
    def YBearing(self) -> int: ...
    @YBearing.setter
    def YBearing(self, value: int) -> int: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: GlyphMetrics, right: GlyphMetrics) -> bool: ...
    def __ne__(self, left: GlyphMetrics, right: GlyphMetrics) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: GlyphMetrics) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class GlyphRun(IDisposable):
    @typing.overload
    def __init__(self, glyphTypeface: IGlyphTypeface, fontRenderingEmSize: float, characters: ReadOnlyMemory_1[str], glyphIndices: IReadOnlyList_1[int], baselineOrigin: typing.Optional[Point] = ..., biDiLevel: int = ...) -> None: ...
    @typing.overload
    def __init__(self, glyphTypeface: IGlyphTypeface, fontRenderingEmSize: float, characters: ReadOnlyMemory_1[str], glyphInfos: IReadOnlyList_1[GlyphInfo], baselineOrigin: typing.Optional[Point] = ..., biDiLevel: int = ...) -> None: ...
    @property
    def BaselineOrigin(self) -> Point: ...
    @BaselineOrigin.setter
    def BaselineOrigin(self, value: Point) -> Point: ...
    @property
    def BiDiLevel(self) -> int: ...
    @BiDiLevel.setter
    def BiDiLevel(self, value: int) -> int: ...
    @property
    def Bounds(self) -> Rect: ...
    @property
    def Characters(self) -> ReadOnlyMemory_1[str]: ...
    @Characters.setter
    def Characters(self, value: ReadOnlyMemory_1[str]) -> ReadOnlyMemory_1[str]: ...
    @property
    def FontRenderingEmSize(self) -> float: ...
    @FontRenderingEmSize.setter
    def FontRenderingEmSize(self, value: float) -> float: ...
    @property
    def GlyphInfos(self) -> IReadOnlyList_1[GlyphInfo]: ...
    @GlyphInfos.setter
    def GlyphInfos(self, value: IReadOnlyList_1[GlyphInfo]) -> IReadOnlyList_1[GlyphInfo]: ...
    @property
    def GlyphTypeface(self) -> IGlyphTypeface: ...
    @property
    def InkBounds(self) -> Rect: ...
    @property
    def IsLeftToRight(self) -> bool: ...
    @property
    def Metrics(self) -> GlyphRunMetrics: ...
    def BuildGeometry(self) -> Geometry: ...
    def Dispose(self) -> None: ...
    def FindGlyphIndex(self, characterIndex: int) -> int: ...
    def FindNearestCharacterHit(self, index: int, width: clr.Reference[float]) -> CharacterHit: ...
    def GetCharacterHitFromDistance(self, distance: float, isInside: clr.Reference[bool]) -> CharacterHit: ...
    def GetDistanceFromCharacterHit(self, characterHit: CharacterHit) -> float: ...
    def GetIntersections(self, lowerLimit: float, upperLimit: float) -> IReadOnlyList_1[float]: ...
    def GetNextCaretCharacterHit(self, characterHit: CharacterHit) -> CharacterHit: ...
    def GetPreviousCaretCharacterHit(self, characterHit: CharacterHit) -> CharacterHit: ...
    def TryCreateImmutableGlyphRunReference(self) -> IImmutableGlyphRunReference: ...


class GlyphRunMetrics(IEquatable_1[GlyphRunMetrics]):
    @property
    def Baseline(self) -> float: ...
    @Baseline.setter
    def Baseline(self, value: float) -> float: ...
    @property
    def FirstCluster(self) -> int: ...
    @FirstCluster.setter
    def FirstCluster(self, value: int) -> int: ...
    @property
    def Height(self) -> float: ...
    @Height.setter
    def Height(self, value: float) -> float: ...
    @property
    def LastCluster(self) -> int: ...
    @LastCluster.setter
    def LastCluster(self, value: int) -> int: ...
    @property
    def NewLineLength(self) -> int: ...
    @NewLineLength.setter
    def NewLineLength(self, value: int) -> int: ...
    @property
    def TrailingWhitespaceLength(self) -> int: ...
    @TrailingWhitespaceLength.setter
    def TrailingWhitespaceLength(self, value: int) -> int: ...
    @property
    def Width(self) -> float: ...
    @Width.setter
    def Width(self, value: float) -> float: ...
    @property
    def WidthIncludingTrailingWhitespace(self) -> float: ...
    @WidthIncludingTrailingWhitespace.setter
    def WidthIncludingTrailingWhitespace(self, value: float) -> float: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: GlyphRunMetrics, right: GlyphRunMetrics) -> bool: ...
    def __ne__(self, left: GlyphRunMetrics, right: GlyphRunMetrics) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: GlyphRunMetrics) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class HslColor(IEquatable_1[HslColor]):
    @typing.overload
    def __init__(self, alpha: float, hue: float, saturation: float, lightness: float) -> None: ...
    @typing.overload
    def __init__(self, color: Color) -> None: ...
    @property
    def A(self) -> float: ...
    @property
    def H(self) -> float: ...
    @property
    def L(self) -> float: ...
    @property
    def S(self) -> float: ...
    @staticmethod
    def FromAhsl(a: float, h: float, s: float, l: float) -> HslColor: ...
    @staticmethod
    def FromHsl(h: float, s: float, l: float) -> HslColor: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: HslColor, right: HslColor) -> bool: ...
    # Operator not supported op_Explicit(hslColor: HslColor)
    def __ne__(self, left: HslColor, right: HslColor) -> bool: ...
    @staticmethod
    def Parse(s: str) -> HslColor: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(s: str, hslColor: clr.Reference[HslColor]) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: HslColor) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped ToHsv due to it being static, abstract and generic.

    ToHsv : ToHsv_MethodGroup
    class ToHsv_MethodGroup:
        @typing.overload
        def __call__(self) -> HsvColor:...
        @typing.overload
        def __call__(self, hue: float, saturation: float, lightness: float, alpha: float = ...) -> HsvColor:...

    # Skipped ToRgb due to it being static, abstract and generic.

    ToRgb : ToRgb_MethodGroup
    class ToRgb_MethodGroup:
        @typing.overload
        def __call__(self) -> Color:...
        @typing.overload
        def __call__(self, hue: float, saturation: float, lightness: float, alpha: float = ...) -> Color:...



class HsvColor(IEquatable_1[HsvColor]):
    @typing.overload
    def __init__(self, alpha: float, hue: float, saturation: float, value: float) -> None: ...
    @typing.overload
    def __init__(self, color: Color) -> None: ...
    @property
    def A(self) -> float: ...
    @property
    def H(self) -> float: ...
    @property
    def S(self) -> float: ...
    @property
    def V(self) -> float: ...
    @staticmethod
    def FromAhsv(a: float, h: float, s: float, v: float) -> HsvColor: ...
    @staticmethod
    def FromHsv(h: float, s: float, v: float) -> HsvColor: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: HsvColor, right: HsvColor) -> bool: ...
    # Operator not supported op_Explicit(hsvColor: HsvColor)
    def __ne__(self, left: HsvColor, right: HsvColor) -> bool: ...
    @staticmethod
    def Parse(s: str) -> HsvColor: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(s: str, hsvColor: clr.Reference[HsvColor]) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: HsvColor) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped ToHsl due to it being static, abstract and generic.

    ToHsl : ToHsl_MethodGroup
    class ToHsl_MethodGroup:
        @typing.overload
        def __call__(self) -> HslColor:...
        @typing.overload
        def __call__(self, hue: float, saturation: float, value: float, alpha: float = ...) -> HslColor:...

    # Skipped ToRgb due to it being static, abstract and generic.

    ToRgb : ToRgb_MethodGroup
    class ToRgb_MethodGroup:
        @typing.overload
        def __call__(self) -> Color:...
        @typing.overload
        def __call__(self, hue: float, saturation: float, value: float, alpha: float = ...) -> Color:...



class IBrush(typing.Protocol):
    @property
    def Opacity(self) -> float: ...
    @property
    def Transform(self) -> ITransform: ...
    @property
    def TransformOrigin(self) -> RelativePoint: ...


class IDashStyle(typing.Protocol):
    @property
    def Dashes(self) -> IReadOnlyList_1[float]: ...
    @property
    def Offset(self) -> float: ...


class IEffect(typing.Protocol):
    pass


class IGlyphTypeface(IDisposable, typing.Protocol):
    @property
    def FamilyName(self) -> str: ...
    @property
    def FontSimulations(self) -> FontSimulations: ...
    @property
    def GlyphCount(self) -> int: ...
    @property
    def Metrics(self) -> FontMetrics: ...
    @property
    def Stretch(self) -> FontStretch: ...
    @property
    def Style(self) -> FontStyle: ...
    @property
    def Weight(self) -> FontWeight: ...
    @abc.abstractmethod
    def GetGlyph(self, codepoint: int) -> int: ...
    @abc.abstractmethod
    def GetGlyphAdvance(self, glyph: int) -> int: ...
    @abc.abstractmethod
    def GetGlyphAdvances(self, glyphs: ReadOnlySpan_1[int]) -> Array_1[int]: ...
    @abc.abstractmethod
    def GetGlyphs(self, codepoints: ReadOnlySpan_1[int]) -> Array_1[int]: ...
    @abc.abstractmethod
    def TryGetGlyph(self, codepoint: int, glyph: clr.Reference[int]) -> bool: ...
    @abc.abstractmethod
    def TryGetGlyphMetrics(self, glyph: int, metrics: clr.Reference[GlyphMetrics]) -> bool: ...
    @abc.abstractmethod
    def TryGetTable(self, tag: int, table: clr.Reference[Array_1[int]]) -> bool: ...


class IImage(typing.Protocol):
    @property
    def Size(self) -> Size: ...
    @abc.abstractmethod
    def Draw(self, context: DrawingContext, sourceRect: Rect, destRect: Rect) -> None: ...


class IImageBrushSource(typing.Protocol):
    pass


class IImmutableBrush(IBrush, typing.Protocol):
    pass


class IImmutableGlyphRunReference(IDisposable, typing.Protocol):
    pass


class ImmediateDrawingContext(IOptionalFeatureProvider, IDisposable):
    @property
    def CurrentTransform(self) -> Matrix: ...
    @CurrentTransform.setter
    def CurrentTransform(self, value: Matrix) -> Matrix: ...
    @property
    def PlatformImpl(self) -> IDrawingContextImpl: ...
    def Dispose(self) -> None: ...
    def DrawEllipse(self, brush: IImmutableBrush, pen: ImmutablePen, center: Point, radiusX: float, radiusY: float) -> None: ...
    def DrawGlyphRun(self, foreground: IImmutableBrush, glyphRun: IImmutableGlyphRunReference) -> None: ...
    def DrawLine(self, pen: ImmutablePen, p1: Point, p2: Point) -> None: ...
    def FillRectangle(self, brush: IImmutableBrush, rect: Rect, cornerRadius: float = ...) -> None: ...
    def PushOpacity(self, opacity: float, bounds: Rect) -> ImmediateDrawingContext.PushedState: ...
    def PushOpacityMask(self, mask: IImmutableBrush, bounds: Rect) -> ImmediateDrawingContext.PushedState: ...
    def PushPostTransform(self, matrix: Matrix) -> ImmediateDrawingContext.PushedState: ...
    def PushPreTransform(self, matrix: Matrix) -> ImmediateDrawingContext.PushedState: ...
    def PushSetTransform(self, matrix: Matrix) -> ImmediateDrawingContext.PushedState: ...
    def PushTransformContainer(self) -> ImmediateDrawingContext.PushedState: ...
    def TryGetFeature(self, type: typing.Type[typing.Any]) -> typing.Any: ...
    # Skipped DrawBitmap due to it being static, abstract and generic.

    DrawBitmap : DrawBitmap_MethodGroup
    class DrawBitmap_MethodGroup:
        @typing.overload
        def __call__(self, source: Bitmap, rect: Rect) -> None:...
        @typing.overload
        def __call__(self, source: Bitmap, sourceRect: Rect, destRect: Rect) -> None:...

    # Skipped DrawRectangle due to it being static, abstract and generic.

    DrawRectangle : DrawRectangle_MethodGroup
    class DrawRectangle_MethodGroup:
        @typing.overload
        def __call__(self, pen: ImmutablePen, rect: Rect, cornerRadius: float = ...) -> None:...
        @typing.overload
        def __call__(self, brush: IImmutableBrush, pen: ImmutablePen, rect: Rect, radiusX: float = ..., radiusY: float = ..., boxShadows: BoxShadows = ...) -> None:...

    # Skipped PushClip due to it being static, abstract and generic.

    PushClip : PushClip_MethodGroup
    class PushClip_MethodGroup:
        @typing.overload
        def __call__(self, clip: RoundedRect) -> ImmediateDrawingContext.PushedState:...
        @typing.overload
        def __call__(self, clip: Rect) -> ImmediateDrawingContext.PushedState:...


    class PushedState(IEquatable_1[ImmediateDrawingContext.PushedState], IDisposable):
        def Dispose(self) -> None: ...
        def GetHashCode(self) -> int: ...
        def __eq__(self, left: ImmediateDrawingContext.PushedState, right: ImmediateDrawingContext.PushedState) -> bool: ...
        def __ne__(self, left: ImmediateDrawingContext.PushedState, right: ImmediateDrawingContext.PushedState) -> bool: ...
        def ToString(self) -> str: ...
        # Skipped Equals due to it being static, abstract and generic.

        Equals : Equals_MethodGroup
        class Equals_MethodGroup:
            @typing.overload
            def __call__(self, other: ImmediateDrawingContext.PushedState) -> bool:...
            @typing.overload
            def __call__(self, obj: typing.Any) -> bool:...


        class PushedStateType(typing.SupportsInt):
            @typing.overload
            def __init__(self, value : int) -> None: ...
            @typing.overload
            def __init__(self, value : int, force_if_true: bool) -> None: ...
            def __int__(self) -> int: ...
            
            # Values:
            None_ : ImmediateDrawingContext.PushedState.PushedStateType # 0
            Matrix : ImmediateDrawingContext.PushedState.PushedStateType # 1
            Opacity : ImmediateDrawingContext.PushedState.PushedStateType # 2
            Clip : ImmediateDrawingContext.PushedState.PushedStateType # 3
            MatrixContainer : ImmediateDrawingContext.PushedState.PushedStateType # 4
            GeometryClip : ImmediateDrawingContext.PushedState.PushedStateType # 5
            OpacityMask : ImmediateDrawingContext.PushedState.PushedStateType # 6




class IMutableTransform(ITransform, typing.Protocol):
    pass


class IPen(typing.Protocol):
    @property
    def Brush(self) -> IBrush: ...
    @property
    def DashStyle(self) -> IDashStyle: ...
    @property
    def LineCap(self) -> PenLineCap: ...
    @property
    def LineJoin(self) -> PenLineJoin: ...
    @property
    def MiterLimit(self) -> float: ...
    @property
    def Thickness(self) -> float: ...


class ISolidColorBrush(IBrush, typing.Protocol):
    @property
    def Color(self) -> Color: ...


class ITransform(typing.Protocol):
    @property
    def Value(self) -> Matrix: ...


class PenLineCap(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Flat : PenLineCap # 0
    Round : PenLineCap # 1
    Square : PenLineCap # 2


class PenLineJoin(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Bevel : PenLineJoin # 0
    Miter : PenLineJoin # 1
    Round : PenLineJoin # 2


class RectangleGeometry(Geometry):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, rect: Rect) -> None: ...
    @typing.overload
    def __init__(self, rect: Rect, radiusX: float, radiusY: float) -> None: ...
    RadiusXProperty : StyledProperty_1[float]
    RadiusYProperty : StyledProperty_1[float]
    RectProperty : StyledProperty_1[Rect]
    @property
    def Bounds(self) -> Rect: ...
    @property
    def ContourLength(self) -> float: ...
    @property
    def RadiusX(self) -> float: ...
    @RadiusX.setter
    def RadiusX(self, value: float) -> float: ...
    @property
    def RadiusY(self) -> float: ...
    @RadiusY.setter
    def RadiusY(self, value: float) -> float: ...
    @property
    def Rect(self) -> Rect: ...
    @Rect.setter
    def Rect(self, value: Rect) -> Rect: ...
    @property
    def Transform(self) -> Transform: ...
    @Transform.setter
    def Transform(self, value: Transform) -> Transform: ...
    def Clone(self) -> Geometry: ...
    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


class RenderOptions(IEquatable_1[RenderOptions]):
    @property
    def BitmapBlendingMode(self) -> BitmapBlendingMode: ...
    @BitmapBlendingMode.setter
    def BitmapBlendingMode(self, value: BitmapBlendingMode) -> BitmapBlendingMode: ...
    @property
    def BitmapInterpolationMode(self) -> BitmapInterpolationMode: ...
    @BitmapInterpolationMode.setter
    def BitmapInterpolationMode(self, value: BitmapInterpolationMode) -> BitmapInterpolationMode: ...
    @property
    def EdgeMode(self) -> EdgeMode: ...
    @EdgeMode.setter
    def EdgeMode(self, value: EdgeMode) -> EdgeMode: ...
    @property
    def RequiresFullOpacityHandling(self) -> typing.Optional[bool]: ...
    @RequiresFullOpacityHandling.setter
    def RequiresFullOpacityHandling(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def TextRenderingMode(self) -> TextRenderingMode: ...
    @TextRenderingMode.setter
    def TextRenderingMode(self, value: TextRenderingMode) -> TextRenderingMode: ...
    @staticmethod
    def GetBitmapBlendingMode(visual: Visual) -> BitmapBlendingMode: ...
    @staticmethod
    def GetBitmapInterpolationMode(visual: Visual) -> BitmapInterpolationMode: ...
    @staticmethod
    def GetEdgeMode(visual: Visual) -> EdgeMode: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def GetRequiresFullOpacityHandling(visual: Visual) -> typing.Optional[bool]: ...
    @staticmethod
    def GetTextRenderingMode(visual: Visual) -> TextRenderingMode: ...
    def MergeWith(self, other: RenderOptions) -> RenderOptions: ...
    def __eq__(self, left: RenderOptions, right: RenderOptions) -> bool: ...
    def __ne__(self, left: RenderOptions, right: RenderOptions) -> bool: ...
    @staticmethod
    def SetBitmapBlendingMode(visual: Visual, value: BitmapBlendingMode) -> None: ...
    @staticmethod
    def SetBitmapInterpolationMode(visual: Visual, value: BitmapInterpolationMode) -> None: ...
    @staticmethod
    def SetEdgeMode(visual: Visual, value: EdgeMode) -> None: ...
    @staticmethod
    def SetRequiresFullOpacityHandling(visual: Visual, value: typing.Optional[bool]) -> None: ...
    @staticmethod
    def SetTextRenderingMode(visual: Visual, value: TextRenderingMode) -> None: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: RenderOptions) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class SolidColorBrush(Brush, ISolidColorBrush):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, color: int) -> None: ...
    @typing.overload
    def __init__(self, color: Color, opacity: float = ...) -> None: ...
    ColorProperty : StyledProperty_1[Color]
    @property
    def Color(self) -> Color: ...
    @Color.setter
    def Color(self, value: Color) -> Color: ...
    @property
    def Opacity(self) -> float: ...
    @Opacity.setter
    def Opacity(self, value: float) -> float: ...
    @property
    def Transform(self) -> ITransform: ...
    @Transform.setter
    def Transform(self, value: ITransform) -> ITransform: ...
    @property
    def TransformOrigin(self) -> RelativePoint: ...
    @TransformOrigin.setter
    def TransformOrigin(self, value: RelativePoint) -> RelativePoint: ...
    @property
    def Transitions(self) -> Transitions: ...
    @Transitions.setter
    def Transitions(self, value: Transitions) -> Transitions: ...
    @staticmethod
    def Parse(s: str) -> SolidColorBrush: ...
    def ToImmutable(self) -> IImmutableBrush: ...
    def ToString(self) -> str: ...
    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


class TextAlignment(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Left : TextAlignment # 0
    Center : TextAlignment # 1
    Right : TextAlignment # 2
    Start : TextAlignment # 3
    End : TextAlignment # 4
    DetectFromContent : TextAlignment # 5
    Justify : TextAlignment # 6


class TextCollapsingCreateInfo(IEquatable_1[TextCollapsingCreateInfo]):
    def __init__(self, width: float, textRunProperties: TextRunProperties, flowDirection: FlowDirection) -> None: ...
    FlowDirection : FlowDirection
    TextRunProperties : TextRunProperties
    Width : float
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: TextCollapsingCreateInfo, right: TextCollapsingCreateInfo) -> bool: ...
    def __ne__(self, left: TextCollapsingCreateInfo, right: TextCollapsingCreateInfo) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: TextCollapsingCreateInfo) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class TextDecoration(AvaloniaObject):
    def __init__(self) -> None: ...
    LocationProperty : StyledProperty_1[TextDecorationLocation]
    StrokeDashArrayProperty : StyledProperty_1[AvaloniaList_1[float]]
    StrokeDashOffsetProperty : StyledProperty_1[float]
    StrokeLineCapProperty : StyledProperty_1[PenLineCap]
    StrokeOffsetProperty : StyledProperty_1[float]
    StrokeOffsetUnitProperty : StyledProperty_1[TextDecorationUnit]
    StrokeProperty : StyledProperty_1[IBrush]
    StrokeThicknessProperty : StyledProperty_1[float]
    StrokeThicknessUnitProperty : StyledProperty_1[TextDecorationUnit]
    @property
    def Location(self) -> TextDecorationLocation: ...
    @Location.setter
    def Location(self, value: TextDecorationLocation) -> TextDecorationLocation: ...
    @property
    def Stroke(self) -> IBrush: ...
    @Stroke.setter
    def Stroke(self, value: IBrush) -> IBrush: ...
    @property
    def StrokeDashArray(self) -> AvaloniaList_1[float]: ...
    @StrokeDashArray.setter
    def StrokeDashArray(self, value: AvaloniaList_1[float]) -> AvaloniaList_1[float]: ...
    @property
    def StrokeDashOffset(self) -> float: ...
    @StrokeDashOffset.setter
    def StrokeDashOffset(self, value: float) -> float: ...
    @property
    def StrokeLineCap(self) -> PenLineCap: ...
    @StrokeLineCap.setter
    def StrokeLineCap(self, value: PenLineCap) -> PenLineCap: ...
    @property
    def StrokeOffset(self) -> float: ...
    @StrokeOffset.setter
    def StrokeOffset(self, value: float) -> float: ...
    @property
    def StrokeOffsetUnit(self) -> TextDecorationUnit: ...
    @StrokeOffsetUnit.setter
    def StrokeOffsetUnit(self, value: TextDecorationUnit) -> TextDecorationUnit: ...
    @property
    def StrokeThickness(self) -> float: ...
    @StrokeThickness.setter
    def StrokeThickness(self, value: float) -> float: ...
    @property
    def StrokeThicknessUnit(self) -> TextDecorationUnit: ...
    @StrokeThicknessUnit.setter
    def StrokeThicknessUnit(self, value: TextDecorationUnit) -> TextDecorationUnit: ...
    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


class TextDecorationCollection(AvaloniaList_1[TextDecoration]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, textDecorations: IEnumerable_1[TextDecoration]) -> None: ...
    @property
    def Capacity(self) -> int: ...
    @Capacity.setter
    def Capacity(self, value: int) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def ResetBehavior(self) -> ResetBehavior: ...
    @ResetBehavior.setter
    def ResetBehavior(self, value: ResetBehavior) -> ResetBehavior: ...
    @property
    def Validate(self) -> Action_1[TextDecoration]: ...
    @Validate.setter
    def Validate(self, value: Action_1[TextDecoration]) -> Action_1[TextDecoration]: ...
    @staticmethod
    def Parse(s: str) -> TextDecorationCollection: ...
    def __getitem__(self, index: int) -> TextDecoration: ...
    def __setitem__(self, index: int, value: TextDecoration) -> None: ...


class TextDecorationLocation(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Underline : TextDecorationLocation # 0
    Overline : TextDecorationLocation # 1
    Strikethrough : TextDecorationLocation # 2
    Baseline : TextDecorationLocation # 3


class TextDecorationUnit(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    FontRecommended : TextDecorationUnit # 0
    FontRenderingEmSize : TextDecorationUnit # 1
    Pixel : TextDecorationUnit # 2


class TextRenderingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unspecified : TextRenderingMode # 0
    SubpixelAntialias : TextRenderingMode # 1
    Antialias : TextRenderingMode # 2
    Alias : TextRenderingMode # 3


class TextTrimming(abc.ABC):
    @classmethod
    @property
    def CharacterEllipsis(cls) -> TextTrimming: ...
    @classmethod
    @property
    def LeadingCharacterEllipsis(cls) -> TextTrimming: ...
    # Skipped property None since it is a reserved python word. Use reflection to access.
    @classmethod
    @property
    def PrefixCharacterEllipsis(cls) -> TextTrimming: ...
    @classmethod
    @property
    def WordEllipsis(cls) -> TextTrimming: ...
    @abc.abstractmethod
    def CreateCollapsingProperties(self, createInfo: TextCollapsingCreateInfo) -> TextCollapsingProperties: ...
    @staticmethod
    def Parse(s: str) -> TextTrimming: ...


class TextWrapping(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    NoWrap : TextWrapping # 0
    Wrap : TextWrapping # 1
    WrapWithOverflow : TextWrapping # 2


class Transform(Animatable, IMutableTransform, abc.ABC):
    @property
    def Transitions(self) -> Transitions: ...
    @Transitions.setter
    def Transitions(self, value: Transitions) -> Transitions: ...
    @property
    def Value(self) -> Matrix: ...
    @staticmethod
    def Parse(s: str) -> Transform: ...
    def ToImmutable(self) -> ImmutableTransform: ...
    def ToString(self) -> str: ...
    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


class Typeface(IEquatable_1[Typeface]):
    @typing.overload
    def __init__(self, fontFamily: FontFamily, style: FontStyle = ..., weight: FontWeight = ..., stretch: FontStretch = ...) -> None: ...
    @typing.overload
    def __init__(self, fontFamilyName: str, style: FontStyle = ..., weight: FontWeight = ..., stretch: FontStretch = ...) -> None: ...
    @classmethod
    @property
    def Default(cls) -> Typeface: ...
    @property
    def FontFamily(self) -> FontFamily: ...
    @property
    def GlyphTypeface(self) -> IGlyphTypeface: ...
    @property
    def Stretch(self) -> FontStretch: ...
    @property
    def Style(self) -> FontStyle: ...
    @property
    def Weight(self) -> FontWeight: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, a: Typeface, b: Typeface) -> bool: ...
    def __ne__(self, a: Typeface, b: Typeface) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Typeface) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



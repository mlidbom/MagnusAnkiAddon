import typing, clr, abc
from System.Collections.Generic import IList_1, IReadOnlyList_1, IEnumerable_1
from Avalonia.Animation import IAnimation
from Avalonia.Controls import IResourceHost, IResourceDictionary, IResourceNode, IResourceProvider
from Avalonia import AvaloniaProperty, INamed, AvaloniaObject
from Avalonia.Data import IndexerDescriptor, IBinding
from Avalonia.Collections import IAvaloniaReadOnlyList_1, IAvaloniaList_1, AvaloniaList_1
from System import Array_1, IEquatable_1

class ControlTheme(StyleBase):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, targetType: typing.Type[typing.Any]) -> None: ...
    @property
    def Animations(self) -> IList_1[IAnimation]: ...
    @property
    def BasedOn(self) -> ControlTheme: ...
    @BasedOn.setter
    def BasedOn(self, value: ControlTheme) -> ControlTheme: ...
    @property
    def Children(self) -> IList_1[IStyle]: ...
    @property
    def Owner(self) -> IResourceHost: ...
    @property
    def Parent(self) -> IStyle: ...
    @property
    def Resources(self) -> IResourceDictionary: ...
    @Resources.setter
    def Resources(self, value: IResourceDictionary) -> IResourceDictionary: ...
    @property
    def Setters(self) -> IList_1[SetterBase]: ...
    @property
    def TargetType(self) -> typing.Type[typing.Any]: ...
    @TargetType.setter
    def TargetType(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    def ToString(self) -> str: ...
    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


class IGlobalStyles(IStyleHost, typing.Protocol):
    pass


class ISetterInstance(typing.Protocol):
    pass


class ISetterValue(typing.Protocol):
    @abc.abstractmethod
    def Initialize(self, setter: SetterBase) -> None: ...


class IStyle(IResourceNode, typing.Protocol):
    @property
    def Children(self) -> IReadOnlyList_1[IStyle]: ...


class IStyleable(INamed, typing.Protocol):
    @property
    def Classes(self) -> IAvaloniaReadOnlyList_1[str]: ...
    @property
    def StyleKey(self) -> typing.Type[typing.Any]: ...
    @property
    def TemplatedParent(self) -> AvaloniaObject: ...


class IStyleHost(typing.Protocol):
    @property
    def IsStylesInitialized(self) -> bool: ...
    @property
    def Styles(self) -> Styles: ...
    @property
    def StylingParent(self) -> IStyleHost: ...
    @abc.abstractmethod
    def StylesAdded(self, styles: IReadOnlyList_1[IStyle]) -> None: ...
    @abc.abstractmethod
    def StylesRemoved(self, styles: IReadOnlyList_1[IStyle]) -> None: ...


class IThemeVariantHost(IResourceHost, typing.Protocol):
    @property
    def ActualThemeVariant(self) -> ThemeVariant: ...


class SetterBase(abc.ABC):
    pass


class StyleBase(AvaloniaObject, IResourceProvider, IStyle, abc.ABC):
    @property
    def Animations(self) -> IList_1[IAnimation]: ...
    @property
    def Children(self) -> IList_1[IStyle]: ...
    @property
    def Owner(self) -> IResourceHost: ...
    @Owner.setter
    def Owner(self, value: IResourceHost) -> IResourceHost: ...
    @property
    def Parent(self) -> IStyle: ...
    @Parent.setter
    def Parent(self, value: IStyle) -> IStyle: ...
    @property
    def Resources(self) -> IResourceDictionary: ...
    @Resources.setter
    def Resources(self, value: IResourceDictionary) -> IResourceDictionary: ...
    @property
    def Setters(self) -> IList_1[SetterBase]: ...
    def TryGetResource(self, key: typing.Any, themeVariant: ThemeVariant, result: clr.Reference[typing.Any]) -> bool: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, setter: SetterBase) -> None:...
        @typing.overload
        def __call__(self, style: IStyle) -> None:...

    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


class Styles(AvaloniaObject, IAvaloniaList_1[IStyle], IResourceProvider, IStyle):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, owner: IResourceHost) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Owner(self) -> IResourceHost: ...
    @Owner.setter
    def Owner(self, value: IResourceHost) -> IResourceHost: ...
    @property
    def Resources(self) -> IResourceDictionary: ...
    @Resources.setter
    def Resources(self, value: IResourceDictionary) -> IResourceDictionary: ...
    def Add(self, item: IStyle) -> None: ...
    def AddRange(self, items: IEnumerable_1[IStyle]) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, item: IStyle) -> bool: ...
    def CopyTo(self, array: Array_1[IStyle], arrayIndex: int) -> None: ...
    def GetEnumerator(self) -> AvaloniaList_1.Enumerator_1[IStyle]: ...
    def IndexOf(self, item: IStyle) -> int: ...
    def Insert(self, index: int, item: IStyle) -> None: ...
    def InsertRange(self, index: int, items: IEnumerable_1[IStyle]) -> None: ...
    def Move(self, oldIndex: int, newIndex: int) -> None: ...
    def MoveRange(self, oldIndex: int, count: int, newIndex: int) -> None: ...
    def Remove(self, item: IStyle) -> bool: ...
    def RemoveAll(self, items: IEnumerable_1[IStyle]) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    def RemoveRange(self, index: int, count: int) -> None: ...
    def TryGetResource(self, key: typing.Any, theme: ThemeVariant, value: clr.Reference[typing.Any]) -> bool: ...
    def __getitem__(self, index: int) -> IStyle: ...
    def __setitem__(self, index: int, value: IStyle) -> None: ...
    def __getitem__(self, property: AvaloniaProperty) -> typing.Any: ...
    def __setitem__(self, property: AvaloniaProperty, value: typing.Any) -> None: ...
    def __getitem__(self, binding: IndexerDescriptor) -> IBinding: ...
    def __setitem__(self, binding: IndexerDescriptor, value: IBinding) -> None: ...


class ThemeVariant(IEquatable_1[ThemeVariant]):
    def __init__(self, key: typing.Any, inheritVariant: ThemeVariant) -> None: ...
    @classmethod
    @property
    def Dark(cls) -> ThemeVariant: ...
    @classmethod
    @property
    def Default(cls) -> ThemeVariant: ...
    @property
    def InheritVariant(self) -> ThemeVariant: ...
    @property
    def Key(self) -> typing.Any: ...
    @classmethod
    @property
    def Light(cls) -> ThemeVariant: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: ThemeVariant, right: ThemeVariant) -> bool: ...
    # Operator not supported op_Explicit(themeVariant: PlatformThemeVariant)
    # Operator not supported op_Explicit(themeVariant: ThemeVariant)
    def __ne__(self, left: ThemeVariant, right: ThemeVariant) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: ThemeVariant) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



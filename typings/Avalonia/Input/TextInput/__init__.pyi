import typing, clr, abc
from Avalonia import Rect, Visual, AttachedProperty_1, StyledElement
from Avalonia.Input import IInputRoot
from Avalonia.Interactivity import RoutedEventArgs, RoutingStrategies, RoutedEvent
from System import IEquatable_1

class ContextMenuAction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Copy : ContextMenuAction # 0
    Cut : ContextMenuAction # 1
    Paste : ContextMenuAction # 2
    SelectAll : ContextMenuAction # 3


class ITextInputMethodImpl(typing.Protocol):
    @abc.abstractmethod
    def Reset(self) -> None: ...
    @abc.abstractmethod
    def SetClient(self, client: TextInputMethodClient) -> None: ...
    @abc.abstractmethod
    def SetCursorRect(self, rect: Rect) -> None: ...
    @abc.abstractmethod
    def SetOptions(self, options: TextInputOptions) -> None: ...


class ITextInputMethodRoot(IInputRoot, typing.Protocol):
    @property
    def InputMethod(self) -> ITextInputMethodImpl: ...


class TextInputContentType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Normal : TextInputContentType # 0
    Alpha : TextInputContentType # 1
    Digits : TextInputContentType # 2
    Pin : TextInputContentType # 3
    Number : TextInputContentType # 4
    Email : TextInputContentType # 5
    Url : TextInputContentType # 6
    Name : TextInputContentType # 7
    Password : TextInputContentType # 8
    Social : TextInputContentType # 9
    Search : TextInputContentType # 10


class TextInputMethodClient(abc.ABC):
    @property
    def CursorRectangle(self) -> Rect: ...
    @property
    def Selection(self) -> TextSelection: ...
    @Selection.setter
    def Selection(self, value: TextSelection) -> TextSelection: ...
    @property
    def SupportsPreedit(self) -> bool: ...
    @property
    def SupportsSurroundingText(self) -> bool: ...
    @property
    def SurroundingText(self) -> str: ...
    @property
    def TextViewVisual(self) -> Visual: ...
    def ExecuteContextMenuAction(self, action: ContextMenuAction) -> None: ...
    def ShowInputPanel(self) -> None: ...
    # Skipped SetPreeditText due to it being static, abstract and generic.

    SetPreeditText : SetPreeditText_MethodGroup
    class SetPreeditText_MethodGroup:
        @typing.overload
        def __call__(self, preeditText: str) -> None:...
        @typing.overload
        def __call__(self, preeditText: str, cursorPos: typing.Optional[int]) -> None:...



class TextInputMethodClientRequestedEventArgs(RoutedEventArgs):
    def __init__(self) -> None: ...
    @property
    def Client(self) -> TextInputMethodClient: ...
    @Client.setter
    def Client(self, value: TextInputMethodClient) -> TextInputMethodClient: ...
    @property
    def Handled(self) -> bool: ...
    @Handled.setter
    def Handled(self, value: bool) -> bool: ...
    @property
    def Route(self) -> RoutingStrategies: ...
    @Route.setter
    def Route(self, value: RoutingStrategies) -> RoutingStrategies: ...
    @property
    def RoutedEvent(self) -> RoutedEvent: ...
    @RoutedEvent.setter
    def RoutedEvent(self, value: RoutedEvent) -> RoutedEvent: ...
    @property
    def Source(self) -> typing.Any: ...
    @Source.setter
    def Source(self, value: typing.Any) -> typing.Any: ...


class TextInputOptions:
    def __init__(self) -> None: ...
    AutoCapitalizationProperty : AttachedProperty_1[bool]
    ContentTypeProperty : AttachedProperty_1[TextInputContentType]
    Default : TextInputOptions
    IsSensitiveProperty : AttachedProperty_1[bool]
    LowercaseProperty : AttachedProperty_1[bool]
    MultilineProperty : AttachedProperty_1[bool]
    ReturnKeyTypeProperty : AttachedProperty_1[TextInputReturnKeyType]
    UppercaseProperty : AttachedProperty_1[bool]
    @property
    def AutoCapitalization(self) -> bool: ...
    @AutoCapitalization.setter
    def AutoCapitalization(self, value: bool) -> bool: ...
    @property
    def ContentType(self) -> TextInputContentType: ...
    @ContentType.setter
    def ContentType(self, value: TextInputContentType) -> TextInputContentType: ...
    @property
    def IsSensitive(self) -> bool: ...
    @IsSensitive.setter
    def IsSensitive(self, value: bool) -> bool: ...
    @property
    def Lowercase(self) -> bool: ...
    @Lowercase.setter
    def Lowercase(self, value: bool) -> bool: ...
    @property
    def Multiline(self) -> bool: ...
    @Multiline.setter
    def Multiline(self, value: bool) -> bool: ...
    @property
    def ReturnKeyType(self) -> TextInputReturnKeyType: ...
    @ReturnKeyType.setter
    def ReturnKeyType(self, value: TextInputReturnKeyType) -> TextInputReturnKeyType: ...
    @property
    def Uppercase(self) -> bool: ...
    @Uppercase.setter
    def Uppercase(self, value: bool) -> bool: ...
    @staticmethod
    def FromStyledElement(avaloniaObject: StyledElement) -> TextInputOptions: ...
    @staticmethod
    def GetAutoCapitalization(avaloniaObject: StyledElement) -> bool: ...
    @staticmethod
    def GetContentType(avaloniaObject: StyledElement) -> TextInputContentType: ...
    @staticmethod
    def GetIsSensitive(avaloniaObject: StyledElement) -> bool: ...
    @staticmethod
    def GetLowercase(avaloniaObject: StyledElement) -> bool: ...
    @staticmethod
    def GetMultiline(avaloniaObject: StyledElement) -> bool: ...
    @staticmethod
    def GetReturnKeyType(avaloniaObject: StyledElement) -> TextInputReturnKeyType: ...
    @staticmethod
    def GetUppercase(avaloniaObject: StyledElement) -> bool: ...
    @staticmethod
    def SetAutoCapitalization(avaloniaObject: StyledElement, value: bool) -> None: ...
    @staticmethod
    def SetContentType(avaloniaObject: StyledElement, value: TextInputContentType) -> None: ...
    @staticmethod
    def SetIsSensitive(avaloniaObject: StyledElement, value: bool) -> None: ...
    @staticmethod
    def SetLowercase(avaloniaObject: StyledElement, value: bool) -> None: ...
    @staticmethod
    def SetMultiline(avaloniaObject: StyledElement, value: bool) -> None: ...
    @staticmethod
    def SetReturnKeyType(avaloniaObject: StyledElement, value: TextInputReturnKeyType) -> None: ...
    @staticmethod
    def SetUppercase(avaloniaObject: StyledElement, value: bool) -> None: ...


class TextInputReturnKeyType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : TextInputReturnKeyType # 0
    Return : TextInputReturnKeyType # 1
    Done : TextInputReturnKeyType # 2
    Go : TextInputReturnKeyType # 3
    Send : TextInputReturnKeyType # 4
    Search : TextInputReturnKeyType # 5
    Next : TextInputReturnKeyType # 6
    Previous : TextInputReturnKeyType # 7


class TextSelection(IEquatable_1[TextSelection]):
    def __init__(self, Start: int, End: int) -> None: ...
    @property
    def End(self) -> int: ...
    @End.setter
    def End(self, value: int) -> int: ...
    @property
    def Start(self) -> int: ...
    @Start.setter
    def Start(self, value: int) -> int: ...
    def Deconstruct(self, Start: clr.Reference[int], End: clr.Reference[int]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: TextSelection, right: TextSelection) -> bool: ...
    def __ne__(self, left: TextSelection, right: TextSelection) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: TextSelection) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



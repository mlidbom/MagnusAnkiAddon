import typing, clr
from System import Array_1, DateTime, DateTimeOffset, Decimal, Guid, ReadOnlySpan_1, IEquatable_1, SequencePosition, Span_1, IAsyncDisposable, IDisposable
from System.Collections.Generic import IEnumerator_1, IEnumerable_1
from System.Text.Encodings.Web import JavaScriptEncoder
from System.Buffers import ReadOnlySequence_1, IBufferWriter_1
from System.IO import Stream
from System.Threading.Tasks import ValueTask, Task
from System.Threading import CancellationToken

class JsonCommentHandling(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Disallow : JsonCommentHandling # 0
    Skip : JsonCommentHandling # 1
    Allow : JsonCommentHandling # 2


class JsonDocumentOptions:
    @property
    def AllowDuplicateProperties(self) -> bool: ...
    @AllowDuplicateProperties.setter
    def AllowDuplicateProperties(self, value: bool) -> bool: ...
    @property
    def AllowTrailingCommas(self) -> bool: ...
    @AllowTrailingCommas.setter
    def AllowTrailingCommas(self, value: bool) -> bool: ...
    @property
    def CommentHandling(self) -> JsonCommentHandling: ...
    @CommentHandling.setter
    def CommentHandling(self, value: JsonCommentHandling) -> JsonCommentHandling: ...
    @property
    def MaxDepth(self) -> int: ...
    @MaxDepth.setter
    def MaxDepth(self, value: int) -> int: ...


class JsonElement:
    @property
    def ValueKind(self) -> JsonValueKind: ...
    def Clone(self) -> JsonElement: ...
    @staticmethod
    def DeepEquals(element1: JsonElement, element2: JsonElement) -> bool: ...
    def EnumerateArray(self) -> JsonElement.ArrayEnumerator: ...
    def EnumerateObject(self) -> JsonElement.ObjectEnumerator: ...
    def GetArrayLength(self) -> int: ...
    def GetBoolean(self) -> bool: ...
    def GetByte(self) -> int: ...
    def GetBytesFromBase64(self) -> Array_1[int]: ...
    def GetDateTime(self) -> DateTime: ...
    def GetDateTimeOffset(self) -> DateTimeOffset: ...
    def GetDecimal(self) -> Decimal: ...
    def GetDouble(self) -> float: ...
    def GetGuid(self) -> Guid: ...
    def GetInt16(self) -> int: ...
    def GetInt32(self) -> int: ...
    def GetInt64(self) -> int: ...
    def GetPropertyCount(self) -> int: ...
    def GetRawText(self) -> str: ...
    def GetSByte(self) -> int: ...
    def GetSingle(self) -> float: ...
    def GetString(self) -> str: ...
    def GetUInt16(self) -> int: ...
    def GetUInt32(self) -> int: ...
    def GetUInt64(self) -> int: ...
    @staticmethod
    def ParseValue(reader: clr.Reference[Utf8JsonReader]) -> JsonElement: ...
    def ToString(self) -> str: ...
    def TryGetByte(self, value: clr.Reference[int]) -> bool: ...
    def TryGetBytesFromBase64(self, value: clr.Reference[Array_1[int]]) -> bool: ...
    def TryGetDateTime(self, value: clr.Reference[DateTime]) -> bool: ...
    def TryGetDateTimeOffset(self, value: clr.Reference[DateTimeOffset]) -> bool: ...
    def TryGetDecimal(self, value: clr.Reference[Decimal]) -> bool: ...
    def TryGetDouble(self, value: clr.Reference[float]) -> bool: ...
    def TryGetGuid(self, value: clr.Reference[Guid]) -> bool: ...
    def TryGetInt16(self, value: clr.Reference[int]) -> bool: ...
    def TryGetInt32(self, value: clr.Reference[int]) -> bool: ...
    def TryGetInt64(self, value: clr.Reference[int]) -> bool: ...
    def TryGetSByte(self, value: clr.Reference[int]) -> bool: ...
    def TryGetSingle(self, value: clr.Reference[float]) -> bool: ...
    def TryGetUInt16(self, value: clr.Reference[int]) -> bool: ...
    def TryGetUInt32(self, value: clr.Reference[int]) -> bool: ...
    def TryGetUInt64(self, value: clr.Reference[int]) -> bool: ...
    @staticmethod
    def TryParseValue(reader: clr.Reference[Utf8JsonReader], element: clr.Reference[typing.Optional[JsonElement]]) -> bool: ...
    def WriteTo(self, writer: Utf8JsonWriter) -> None: ...
    # Skipped GetProperty due to it being static, abstract and generic.

    GetProperty : GetProperty_MethodGroup
    class GetProperty_MethodGroup:
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str]) -> JsonElement:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int]) -> JsonElement:...
        @typing.overload
        def __call__(self, propertyName: str) -> JsonElement:...

    # Skipped Parse due to it being static, abstract and generic.

    Parse : Parse_MethodGroup
    class Parse_MethodGroup:
        @typing.overload
        def __call__(self, json: ReadOnlySpan_1[str], options: JsonDocumentOptions = ...) -> JsonElement:...
        @typing.overload
        def __call__(self, utf8Json: ReadOnlySpan_1[int], options: JsonDocumentOptions = ...) -> JsonElement:...
        @typing.overload
        def __call__(self, json: str, options: JsonDocumentOptions = ...) -> JsonElement:...

    # Skipped TryGetProperty due to it being static, abstract and generic.

    TryGetProperty : TryGetProperty_MethodGroup
    class TryGetProperty_MethodGroup:
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str], value: clr.Reference[JsonElement]) -> bool:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int], value: clr.Reference[JsonElement]) -> bool:...
        @typing.overload
        def __call__(self, propertyName: str, value: clr.Reference[JsonElement]) -> bool:...

    # Skipped ValueEquals due to it being static, abstract and generic.

    ValueEquals : ValueEquals_MethodGroup
    class ValueEquals_MethodGroup:
        @typing.overload
        def __call__(self, text: ReadOnlySpan_1[str]) -> bool:...
        @typing.overload
        def __call__(self, utf8Text: ReadOnlySpan_1[int]) -> bool:...
        @typing.overload
        def __call__(self, text: str) -> bool:...


    class ArrayEnumerator(IEnumerator_1[JsonElement], IEnumerable_1[JsonElement]):
        @property
        def Current(self) -> JsonElement: ...
        def Dispose(self) -> None: ...
        def GetEnumerator(self) -> JsonElement.ArrayEnumerator: ...
        def MoveNext(self) -> bool: ...
        def Reset(self) -> None: ...


    class ObjectEnumerator(IEnumerator_1[JsonProperty], IEnumerable_1[JsonProperty]):
        @property
        def Current(self) -> JsonProperty: ...
        def Dispose(self) -> None: ...
        def GetEnumerator(self) -> JsonElement.ObjectEnumerator: ...
        def MoveNext(self) -> bool: ...
        def Reset(self) -> None: ...

    def __getitem__(self, index: int) -> JsonElement: ...


class JsonEncodedText(IEquatable_1[JsonEncodedText]):
    @property
    def EncodedUtf8Bytes(self) -> ReadOnlySpan_1[int]: ...
    @property
    def Value(self) -> str: ...
    def GetHashCode(self) -> int: ...
    def ToString(self) -> str: ...
    # Skipped Encode due to it being static, abstract and generic.

    Encode : Encode_MethodGroup
    class Encode_MethodGroup:
        @typing.overload
        def __call__(self, utf8Value: ReadOnlySpan_1[int], encoder: JavaScriptEncoder = ...) -> JsonEncodedText:...
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[str], encoder: JavaScriptEncoder = ...) -> JsonEncodedText:...
        @typing.overload
        def __call__(self, value: str, encoder: JavaScriptEncoder = ...) -> JsonEncodedText:...

    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: JsonEncodedText) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class JsonProperty:
    @property
    def Name(self) -> str: ...
    @property
    def Value(self) -> JsonElement: ...
    def ToString(self) -> str: ...
    def WriteTo(self, writer: Utf8JsonWriter) -> None: ...
    # Skipped NameEquals due to it being static, abstract and generic.

    NameEquals : NameEquals_MethodGroup
    class NameEquals_MethodGroup:
        @typing.overload
        def __call__(self, text: ReadOnlySpan_1[str]) -> bool:...
        @typing.overload
        def __call__(self, utf8Text: ReadOnlySpan_1[int]) -> bool:...
        @typing.overload
        def __call__(self, text: str) -> bool:...



class JsonReaderOptions:
    @property
    def AllowMultipleValues(self) -> bool: ...
    @AllowMultipleValues.setter
    def AllowMultipleValues(self, value: bool) -> bool: ...
    @property
    def AllowTrailingCommas(self) -> bool: ...
    @AllowTrailingCommas.setter
    def AllowTrailingCommas(self, value: bool) -> bool: ...
    @property
    def CommentHandling(self) -> JsonCommentHandling: ...
    @CommentHandling.setter
    def CommentHandling(self, value: JsonCommentHandling) -> JsonCommentHandling: ...
    @property
    def MaxDepth(self) -> int: ...
    @MaxDepth.setter
    def MaxDepth(self, value: int) -> int: ...


class JsonReaderState:
    def __init__(self, options: JsonReaderOptions = ...) -> None: ...
    @property
    def Options(self) -> JsonReaderOptions: ...


class JsonTokenType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : JsonTokenType # 0
    StartObject : JsonTokenType # 1
    EndObject : JsonTokenType # 2
    StartArray : JsonTokenType # 3
    EndArray : JsonTokenType # 4
    PropertyName : JsonTokenType # 5
    Comment : JsonTokenType # 6
    String : JsonTokenType # 7
    Number : JsonTokenType # 8
    True : JsonTokenType # 9
    False : JsonTokenType # 10
    Null : JsonTokenType # 11


class JsonValueKind(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Undefined : JsonValueKind # 0
    Object : JsonValueKind # 1
    Array : JsonValueKind # 2
    String : JsonValueKind # 3
    Number : JsonValueKind # 4
    True : JsonValueKind # 5
    False : JsonValueKind # 6
    Null : JsonValueKind # 7


class JsonWriterOptions:
    @property
    def Encoder(self) -> JavaScriptEncoder: ...
    @Encoder.setter
    def Encoder(self, value: JavaScriptEncoder) -> JavaScriptEncoder: ...
    @property
    def IndentCharacter(self) -> str: ...
    @IndentCharacter.setter
    def IndentCharacter(self, value: str) -> str: ...
    @property
    def Indented(self) -> bool: ...
    @Indented.setter
    def Indented(self, value: bool) -> bool: ...
    @property
    def IndentSize(self) -> int: ...
    @IndentSize.setter
    def IndentSize(self, value: int) -> int: ...
    @property
    def MaxDepth(self) -> int: ...
    @MaxDepth.setter
    def MaxDepth(self, value: int) -> int: ...
    @property
    def NewLine(self) -> str: ...
    @NewLine.setter
    def NewLine(self, value: str) -> str: ...
    @property
    def SkipValidation(self) -> bool: ...
    @SkipValidation.setter
    def SkipValidation(self, value: bool) -> bool: ...


class Utf8JsonReader:
    @typing.overload
    def __init__(self, jsonData: ReadOnlySpan_1[int], isFinalBlock: bool, state: JsonReaderState) -> None: ...
    @typing.overload
    def __init__(self, jsonData: ReadOnlySequence_1[int], isFinalBlock: bool, state: JsonReaderState) -> None: ...
    @typing.overload
    def __init__(self, jsonData: ReadOnlySpan_1[int], options: JsonReaderOptions = ...) -> None: ...
    @typing.overload
    def __init__(self, jsonData: ReadOnlySequence_1[int], options: JsonReaderOptions = ...) -> None: ...
    @property
    def BytesConsumed(self) -> int: ...
    @property
    def CurrentDepth(self) -> int: ...
    @property
    def CurrentState(self) -> JsonReaderState: ...
    @property
    def HasValueSequence(self) -> bool: ...
    @HasValueSequence.setter
    def HasValueSequence(self, value: bool) -> bool: ...
    @property
    def IsFinalBlock(self) -> bool: ...
    @property
    def Position(self) -> SequencePosition: ...
    @property
    def TokenStartIndex(self) -> int: ...
    @TokenStartIndex.setter
    def TokenStartIndex(self, value: int) -> int: ...
    @property
    def TokenType(self) -> JsonTokenType: ...
    @property
    def ValueIsEscaped(self) -> bool: ...
    @ValueIsEscaped.setter
    def ValueIsEscaped(self, value: bool) -> bool: ...
    @property
    def ValueSequence(self) -> ReadOnlySequence_1[int]: ...
    @ValueSequence.setter
    def ValueSequence(self, value: ReadOnlySequence_1[int]) -> ReadOnlySequence_1[int]: ...
    @property
    def ValueSpan(self) -> ReadOnlySpan_1[int]: ...
    @ValueSpan.setter
    def ValueSpan(self, value: ReadOnlySpan_1[int]) -> ReadOnlySpan_1[int]: ...
    def GetBoolean(self) -> bool: ...
    def GetByte(self) -> int: ...
    def GetBytesFromBase64(self) -> Array_1[int]: ...
    def GetComment(self) -> str: ...
    def GetDateTime(self) -> DateTime: ...
    def GetDateTimeOffset(self) -> DateTimeOffset: ...
    def GetDecimal(self) -> Decimal: ...
    def GetDouble(self) -> float: ...
    def GetGuid(self) -> Guid: ...
    def GetInt16(self) -> int: ...
    def GetInt32(self) -> int: ...
    def GetInt64(self) -> int: ...
    def GetSByte(self) -> int: ...
    def GetSingle(self) -> float: ...
    def GetString(self) -> str: ...
    def GetUInt16(self) -> int: ...
    def GetUInt32(self) -> int: ...
    def GetUInt64(self) -> int: ...
    def Read(self) -> bool: ...
    def Skip(self) -> None: ...
    def TryGetByte(self, value: clr.Reference[int]) -> bool: ...
    def TryGetBytesFromBase64(self, value: clr.Reference[Array_1[int]]) -> bool: ...
    def TryGetDateTime(self, value: clr.Reference[DateTime]) -> bool: ...
    def TryGetDateTimeOffset(self, value: clr.Reference[DateTimeOffset]) -> bool: ...
    def TryGetDecimal(self, value: clr.Reference[Decimal]) -> bool: ...
    def TryGetDouble(self, value: clr.Reference[float]) -> bool: ...
    def TryGetGuid(self, value: clr.Reference[Guid]) -> bool: ...
    def TryGetInt16(self, value: clr.Reference[int]) -> bool: ...
    def TryGetInt32(self, value: clr.Reference[int]) -> bool: ...
    def TryGetInt64(self, value: clr.Reference[int]) -> bool: ...
    def TryGetSByte(self, value: clr.Reference[int]) -> bool: ...
    def TryGetSingle(self, value: clr.Reference[float]) -> bool: ...
    def TryGetUInt16(self, value: clr.Reference[int]) -> bool: ...
    def TryGetUInt32(self, value: clr.Reference[int]) -> bool: ...
    def TryGetUInt64(self, value: clr.Reference[int]) -> bool: ...
    def TrySkip(self) -> bool: ...
    # Skipped CopyString due to it being static, abstract and generic.

    CopyString : CopyString_MethodGroup
    class CopyString_MethodGroup:
        @typing.overload
        def __call__(self, destination: Span_1[str]) -> int:...
        @typing.overload
        def __call__(self, utf8Destination: Span_1[int]) -> int:...

    # Skipped ValueTextEquals due to it being static, abstract and generic.

    ValueTextEquals : ValueTextEquals_MethodGroup
    class ValueTextEquals_MethodGroup:
        @typing.overload
        def __call__(self, text: ReadOnlySpan_1[str]) -> bool:...
        @typing.overload
        def __call__(self, utf8Text: ReadOnlySpan_1[int]) -> bool:...
        @typing.overload
        def __call__(self, text: str) -> bool:...



class Utf8JsonWriter(IAsyncDisposable, IDisposable):
    @typing.overload
    def __init__(self, bufferWriter: IBufferWriter_1[int], options: JsonWriterOptions = ...) -> None: ...
    @typing.overload
    def __init__(self, utf8Json: Stream, options: JsonWriterOptions = ...) -> None: ...
    @property
    def BytesCommitted(self) -> int: ...
    @BytesCommitted.setter
    def BytesCommitted(self, value: int) -> int: ...
    @property
    def BytesPending(self) -> int: ...
    @BytesPending.setter
    def BytesPending(self, value: int) -> int: ...
    @property
    def CurrentDepth(self) -> int: ...
    @property
    def Options(self) -> JsonWriterOptions: ...
    def Dispose(self) -> None: ...
    def DisposeAsync(self) -> ValueTask: ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: CancellationToken = ...) -> Task: ...
    def WriteBase64StringSegment(self, value: ReadOnlySpan_1[int], isFinalSegment: bool) -> None: ...
    def WriteBase64StringValue(self, bytes: ReadOnlySpan_1[int]) -> None: ...
    def WriteBooleanValue(self, value: bool) -> None: ...
    def WriteEndArray(self) -> None: ...
    def WriteEndObject(self) -> None: ...
    def WriteNullValue(self) -> None: ...
    # Skipped Reset due to it being static, abstract and generic.

    Reset : Reset_MethodGroup
    class Reset_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, utf8Json: Stream) -> None:...
        @typing.overload
        def __call__(self, bufferWriter: IBufferWriter_1[int]) -> None:...

    # Skipped WriteBase64String due to it being static, abstract and generic.

    WriteBase64String : WriteBase64String_MethodGroup
    class WriteBase64String_MethodGroup:
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str], bytes: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int], bytes: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText, bytes: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, bytes: ReadOnlySpan_1[int]) -> None:...

    # Skipped WriteBoolean due to it being static, abstract and generic.

    WriteBoolean : WriteBoolean_MethodGroup
    class WriteBoolean_MethodGroup:
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str], value: bool) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int], value: bool) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText, value: bool) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, value: bool) -> None:...

    # Skipped WriteCommentValue due to it being static, abstract and generic.

    WriteCommentValue : WriteCommentValue_MethodGroup
    class WriteCommentValue_MethodGroup:
        @typing.overload
        def __call__(self, utf8Value: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, value: str) -> None:...

    # Skipped WriteNull due to it being static, abstract and generic.

    WriteNull : WriteNull_MethodGroup
    class WriteNull_MethodGroup:
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText) -> None:...
        @typing.overload
        def __call__(self, propertyName: str) -> None:...

    # Skipped WriteNumber due to it being static, abstract and generic.

    WriteNumber : WriteNumber_MethodGroup
    class WriteNumber_MethodGroup:
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str], value: float) -> None:...
        # Method WriteNumber(propertyName : ReadOnlySpan`1, value : Single) was skipped since it collides with above method
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int], value: float) -> None:...
        # Method WriteNumber(utf8PropertyName : ReadOnlySpan`1, value : Single) was skipped since it collides with above method
        # Method WriteNumber(propertyName : ReadOnlySpan`1, value : Int64) was skipped since it collides with above method
        # Method WriteNumber(propertyName : ReadOnlySpan`1, value : Int32) was skipped since it collides with above method
        # Method WriteNumber(propertyName : ReadOnlySpan`1, value : UInt64) was skipped since it collides with above method
        # Method WriteNumber(propertyName : ReadOnlySpan`1, value : UInt32) was skipped since it collides with above method
        # Method WriteNumber(utf8PropertyName : ReadOnlySpan`1, value : Int64) was skipped since it collides with above method
        # Method WriteNumber(utf8PropertyName : ReadOnlySpan`1, value : Int32) was skipped since it collides with above method
        # Method WriteNumber(utf8PropertyName : ReadOnlySpan`1, value : UInt64) was skipped since it collides with above method
        # Method WriteNumber(utf8PropertyName : ReadOnlySpan`1, value : UInt32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str], value: Decimal) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int], value: Decimal) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText, value: float) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, value: float) -> None:...
        # Method WriteNumber(propertyName : JsonEncodedText, value : Single) was skipped since it collides with above method
        # Method WriteNumber(propertyName : String, value : Single) was skipped since it collides with above method
        # Method WriteNumber(propertyName : JsonEncodedText, value : Int64) was skipped since it collides with above method
        # Method WriteNumber(propertyName : String, value : Int64) was skipped since it collides with above method
        # Method WriteNumber(propertyName : JsonEncodedText, value : Int32) was skipped since it collides with above method
        # Method WriteNumber(propertyName : String, value : Int32) was skipped since it collides with above method
        # Method WriteNumber(propertyName : JsonEncodedText, value : UInt64) was skipped since it collides with above method
        # Method WriteNumber(propertyName : String, value : UInt64) was skipped since it collides with above method
        # Method WriteNumber(propertyName : JsonEncodedText, value : UInt32) was skipped since it collides with above method
        # Method WriteNumber(propertyName : String, value : UInt32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText, value: Decimal) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, value: Decimal) -> None:...

    # Skipped WriteNumberValue due to it being static, abstract and generic.

    WriteNumberValue : WriteNumberValue_MethodGroup
    class WriteNumberValue_MethodGroup:
        @typing.overload
        def __call__(self, value: float) -> None:...
        # Method WriteNumberValue(value : Single) was skipped since it collides with above method
        # Method WriteNumberValue(value : Int32) was skipped since it collides with above method
        # Method WriteNumberValue(value : Int64) was skipped since it collides with above method
        # Method WriteNumberValue(value : UInt32) was skipped since it collides with above method
        # Method WriteNumberValue(value : UInt64) was skipped since it collides with above method
        @typing.overload
        def __call__(self, value: Decimal) -> None:...

    # Skipped WritePropertyName due to it being static, abstract and generic.

    WritePropertyName : WritePropertyName_MethodGroup
    class WritePropertyName_MethodGroup:
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText) -> None:...
        @typing.overload
        def __call__(self, propertyName: str) -> None:...

    # Skipped WriteRawValue due to it being static, abstract and generic.

    WriteRawValue : WriteRawValue_MethodGroup
    class WriteRawValue_MethodGroup:
        @typing.overload
        def __call__(self, json: ReadOnlySpan_1[str], skipInputValidation: bool = ...) -> None:...
        @typing.overload
        def __call__(self, utf8Json: ReadOnlySpan_1[int], skipInputValidation: bool = ...) -> None:...
        @typing.overload
        def __call__(self, utf8Json: ReadOnlySequence_1[int], skipInputValidation: bool = ...) -> None:...
        @typing.overload
        def __call__(self, json: str, skipInputValidation: bool = ...) -> None:...

    # Skipped WriteStartArray due to it being static, abstract and generic.

    WriteStartArray : WriteStartArray_MethodGroup
    class WriteStartArray_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText) -> None:...
        @typing.overload
        def __call__(self, propertyName: str) -> None:...

    # Skipped WriteStartObject due to it being static, abstract and generic.

    WriteStartObject : WriteStartObject_MethodGroup
    class WriteStartObject_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText) -> None:...
        @typing.overload
        def __call__(self, propertyName: str) -> None:...

    # Skipped WriteString due to it being static, abstract and generic.

    WriteString : WriteString_MethodGroup
    class WriteString_MethodGroup:
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str], utf8Value: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str], value: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int], utf8Value: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int], value: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str], value: DateTime) -> None:...
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str], value: DateTimeOffset) -> None:...
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str], value: Guid) -> None:...
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str], value: JsonEncodedText) -> None:...
        @typing.overload
        def __call__(self, propertyName: ReadOnlySpan_1[str], value: str) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int], value: DateTime) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int], value: DateTimeOffset) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int], value: Guid) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int], value: JsonEncodedText) -> None:...
        @typing.overload
        def __call__(self, utf8PropertyName: ReadOnlySpan_1[int], value: str) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText, utf8Value: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, utf8Value: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText, value: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, value: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText, value: DateTime) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, value: DateTime) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText, value: DateTimeOffset) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, value: DateTimeOffset) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText, value: Guid) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, value: Guid) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText, value: JsonEncodedText) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, value: JsonEncodedText) -> None:...
        @typing.overload
        def __call__(self, propertyName: str, value: str) -> None:...
        @typing.overload
        def __call__(self, propertyName: JsonEncodedText, value: str) -> None:...

    # Skipped WriteStringValue due to it being static, abstract and generic.

    WriteStringValue : WriteStringValue_MethodGroup
    class WriteStringValue_MethodGroup:
        @typing.overload
        def __call__(self, utf8Value: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, value: DateTime) -> None:...
        @typing.overload
        def __call__(self, value: DateTimeOffset) -> None:...
        @typing.overload
        def __call__(self, value: Guid) -> None:...
        @typing.overload
        def __call__(self, value: JsonEncodedText) -> None:...
        @typing.overload
        def __call__(self, value: str) -> None:...

    # Skipped WriteStringValueSegment due to it being static, abstract and generic.

    WriteStringValueSegment : WriteStringValueSegment_MethodGroup
    class WriteStringValueSegment_MethodGroup:
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[str], isFinalSegment: bool) -> None:...
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[int], isFinalSegment: bool) -> None:...



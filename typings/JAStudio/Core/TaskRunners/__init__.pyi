import typing, abc
from System import Action, Func_1, Exception, IDisposable, Action_1, Func_2, TimeSpan, IEquatable_1
from System.Threading.Tasks import Task, Task_1, ParallelOptions
from System.Diagnostics import Stopwatch
from System.Collections.Generic import List_1, IEnumerable_1
from System.ComponentModel import INotifyPropertyChanged
from System.Collections.ObjectModel import ObservableCollection_1

class BackgroundTaskManager:
    def Run(self, action: Action) -> None: ...
    def RunAsync(self, action: Func_1[Task]) -> None: ...


class BatchTaskProgressViewModel(TaskProgressViewModel):
    def __init__(self) -> None: ...
    @property
    def Current(self) -> int: ...
    @Current.setter
    def Current(self, value: int) -> int: ...
    @property
    def IsCancelVisible(self) -> bool: ...
    @IsCancelVisible.setter
    def IsCancelVisible(self, value: bool) -> bool: ...
    @property
    def Message(self) -> str: ...
    @Message.setter
    def Message(self, value: str) -> str: ...
    @property
    def StatsText(self) -> str: ...
    @StatsText.setter
    def StatsText(self, value: str) -> str: ...
    @property
    def Total(self) -> int: ...
    @Total.setter
    def Total(self, value: int) -> int: ...
    @property
    def WasCanceled(self) -> bool: ...
    def SetProgress(self, current: int, total: int) -> None: ...
    def UpdateProgressWithTiming(self, current: int, total: int, stopwatch: Stopwatch) -> None: ...


class IFatalErrorHandler(typing.Protocol):
    @abc.abstractmethod
    def Handle(self, exception: Exception) -> None: ...


class IScopePanel(IDisposable, typing.Protocol):
    @property
    def ViewModel(self) -> TaskProgressScopeViewModel: ...


class ITaskProgressRunner(IDisposable, typing.Protocol):
    @abc.abstractmethod
    def IsHidden(self) -> bool: ...
    @abc.abstractmethod
    def SetLabelText(self, text: str) -> None: ...
    # Skipped RunBatch due to it being static, abstract and generic.

    RunBatch : RunBatch_MethodGroup
    class RunBatch_MethodGroup:
        @typing.overload
        def __getitem__(self, t:typing.Type[RunBatch_1_T1]) -> RunBatch_1[RunBatch_1_T1]: ...

        RunBatch_1_T1 = typing.TypeVar('RunBatch_1_T1')
        class RunBatch_1(typing.Generic[RunBatch_1_T1]):
            RunBatch_1_TInput = ITaskProgressRunner.RunBatch_MethodGroup.RunBatch_1_T1
            @typing.overload
            def __call__(self, items: List_1[RunBatch_1_TInput], processItem: Action_1[RunBatch_1_TInput], message: str) -> None:...
            @typing.overload
            def __call__(self, items: List_1[RunBatch_1_TInput], processItem: Action_1[RunBatch_1_TInput], message: str, threads: ThreadCount) -> None:...

        @typing.overload
        def __getitem__(self, t:typing.Tuple[typing.Type[RunBatch_2_T1], typing.Type[RunBatch_2_T2]]) -> RunBatch_2[RunBatch_2_T1, RunBatch_2_T2]: ...

        RunBatch_2_T1 = typing.TypeVar('RunBatch_2_T1')
        RunBatch_2_T2 = typing.TypeVar('RunBatch_2_T2')
        class RunBatch_2(typing.Generic[RunBatch_2_T1, RunBatch_2_T2]):
            RunBatch_2_TInput = ITaskProgressRunner.RunBatch_MethodGroup.RunBatch_2_T1
            RunBatch_2_TOutput = ITaskProgressRunner.RunBatch_MethodGroup.RunBatch_2_T2
            @typing.overload
            def __call__(self, items: List_1[RunBatch_2_TInput], processItem: Func_2[RunBatch_2_TInput, RunBatch_2_TOutput], message: str) -> List_1[RunBatch_2_TOutput]:...
            @typing.overload
            def __call__(self, items: List_1[RunBatch_2_TInput], processItem: Func_2[RunBatch_2_TInput, RunBatch_2_TOutput], message: str, threads: ThreadCount) -> List_1[RunBatch_2_TOutput]:...


    # Skipped RunBatchAsync due to it being static, abstract and generic.

    RunBatchAsync : RunBatchAsync_MethodGroup
    class RunBatchAsync_MethodGroup:
        @typing.overload
        def __getitem__(self, t:typing.Tuple[typing.Type[RunBatchAsync_2_T1], typing.Type[RunBatchAsync_2_T2]]) -> RunBatchAsync_2[RunBatchAsync_2_T1, RunBatchAsync_2_T2]: ...

        RunBatchAsync_2_T1 = typing.TypeVar('RunBatchAsync_2_T1')
        RunBatchAsync_2_T2 = typing.TypeVar('RunBatchAsync_2_T2')
        class RunBatchAsync_2(typing.Generic[RunBatchAsync_2_T1, RunBatchAsync_2_T2]):
            RunBatchAsync_2_TInput = ITaskProgressRunner.RunBatchAsync_MethodGroup.RunBatchAsync_2_T1
            RunBatchAsync_2_TOutput = ITaskProgressRunner.RunBatchAsync_MethodGroup.RunBatchAsync_2_T2
            @typing.overload
            def __call__(self, items: List_1[RunBatchAsync_2_TInput], processItem: Func_2[RunBatchAsync_2_TInput, RunBatchAsync_2_TOutput], message: str) -> Task_1[List_1[RunBatchAsync_2_TOutput]]:...
            @typing.overload
            def __call__(self, items: List_1[RunBatchAsync_2_TInput], processItem: Func_2[RunBatchAsync_2_TInput, RunBatchAsync_2_TOutput], message: str, threadCount: ThreadCount) -> Task_1[List_1[RunBatchAsync_2_TOutput]]:...

        @typing.overload
        def __getitem__(self, t:typing.Type[RunBatchAsync_1_T1]) -> RunBatchAsync_1[RunBatchAsync_1_T1]: ...

        RunBatchAsync_1_T1 = typing.TypeVar('RunBatchAsync_1_T1')
        class RunBatchAsync_1(typing.Generic[RunBatchAsync_1_T1]):
            RunBatchAsync_1_TInput = ITaskProgressRunner.RunBatchAsync_MethodGroup.RunBatchAsync_1_T1
            @typing.overload
            def __call__(self, items: List_1[RunBatchAsync_1_TInput], processItem: Action_1[RunBatchAsync_1_TInput], message: str) -> Task:...
            @typing.overload
            def __call__(self, items: List_1[RunBatchAsync_1_TInput], processItem: Action_1[RunBatchAsync_1_TInput], message: str, threadCount: ThreadCount) -> Task:...


    # Skipped RunIndeterminate due to it being static, abstract and generic.

    RunIndeterminate : RunIndeterminate_MethodGroup
    class RunIndeterminate_MethodGroup:
        def __getitem__(self, t:typing.Type[RunIndeterminate_1_T1]) -> RunIndeterminate_1[RunIndeterminate_1_T1]: ...

        RunIndeterminate_1_T1 = typing.TypeVar('RunIndeterminate_1_T1')
        class RunIndeterminate_1(typing.Generic[RunIndeterminate_1_T1]):
            RunIndeterminate_1_TResult = ITaskProgressRunner.RunIndeterminate_MethodGroup.RunIndeterminate_1_T1
            def __call__(self, message: str, action: Func_1[RunIndeterminate_1_TResult]) -> RunIndeterminate_1_TResult:...

        def __call__(self, message: str, action: Action) -> None:...

    # Skipped RunIndeterminateAsync due to it being static, abstract and generic.

    RunIndeterminateAsync : RunIndeterminateAsync_MethodGroup
    class RunIndeterminateAsync_MethodGroup:
        def __getitem__(self, t:typing.Type[RunIndeterminateAsync_1_T1]) -> RunIndeterminateAsync_1[RunIndeterminateAsync_1_T1]: ...

        RunIndeterminateAsync_1_T1 = typing.TypeVar('RunIndeterminateAsync_1_T1')
        class RunIndeterminateAsync_1(typing.Generic[RunIndeterminateAsync_1_T1]):
            RunIndeterminateAsync_1_TResult = ITaskProgressRunner.RunIndeterminateAsync_MethodGroup.RunIndeterminateAsync_1_T1
            def __call__(self, message: str, action: Func_1[RunIndeterminateAsync_1_TResult]) -> Task_1[RunIndeterminateAsync_1_TResult]:...

        def __call__(self, message: str, action: Action) -> Task:...



class ITaskProgressUI(typing.Protocol):
    @abc.abstractmethod
    def CreateScopePanel(self, scopeTitle: str, depth: int, parentScope: IScopePanel) -> IScopePanel: ...
    @abc.abstractmethod
    def CreateTaskRunner(self, scopePanel: IScopePanel, labelText: str, allowCancel: bool) -> ITaskProgressRunner: ...
    @abc.abstractmethod
    def HoldDialog(self) -> None: ...
    @abc.abstractmethod
    def ReleaseDialog(self) -> None: ...


class NotifyPropertyChangedBase(INotifyPropertyChanged, abc.ABC):
    pass


class TaskLogEntry:
    def __init__(self, title: str) -> None: ...
    @property
    def Children(self) -> IEnumerable_1[TaskLogEntry]: ...
    @property
    def Elapsed(self) -> TimeSpan: ...
    @Elapsed.setter
    def Elapsed(self, value: TimeSpan) -> TimeSpan: ...
    @property
    def Title(self) -> str: ...
    def AddChild(self, child: TaskLogEntry) -> None: ...
    def FormatTree(self) -> str: ...
    def MarkCompleted(self) -> None: ...


class TaskProgressScopeViewModel(NotifyPropertyChangedBase, IDisposable):
    def __init__(self, heading: str, depth: int) -> None: ...
    @property
    def Children(self) -> ObservableCollection_1[NotifyPropertyChangedBase]: ...
    @property
    def Depth(self) -> int: ...
    @property
    def ElapsedText(self) -> str: ...
    @ElapsedText.setter
    def ElapsedText(self, value: str) -> str: ...
    @property
    def Heading(self) -> str: ...
    @Heading.setter
    def Heading(self, value: str) -> str: ...
    def Dispose(self) -> None: ...


class TaskProgressViewModel(NotifyPropertyChangedBase):
    def __init__(self) -> None: ...
    @property
    def IsCancelVisible(self) -> bool: ...
    @IsCancelVisible.setter
    def IsCancelVisible(self, value: bool) -> bool: ...
    @property
    def Message(self) -> str: ...
    @Message.setter
    def Message(self, value: str) -> str: ...
    @property
    def WasCanceled(self) -> bool: ...
    def RequestCancel(self) -> None: ...


class TaskRunner:
    def Current(self, scopeTitle: str, forceHide: bool = ..., allowCancel: bool = ...) -> ITaskProgressRunner: ...


class ThreadCount(IEquatable_1[ThreadCount]):
    AllLogicalCores : ThreadCount
    HalfLogicalCores : ThreadCount
    One : ThreadCount
    @property
    def IsSequential(self) -> bool: ...
    @property
    def ParallelOptions(self) -> ParallelOptions: ...
    @property
    def Threads(self) -> int: ...
    @staticmethod
    def FractionOfLogicalCores(fraction: float) -> ThreadCount: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: ThreadCount, right: ThreadCount) -> bool: ...
    def __ne__(self, left: ThreadCount, right: ThreadCount) -> bool: ...
    def ToString(self) -> str: ...
    @staticmethod
    def WithThreads(count: int) -> ThreadCount: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: ThreadCount) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



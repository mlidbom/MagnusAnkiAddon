import typing, clr, abc
from System.Collections.Generic import List_1
from System import IEquatable_1

class ITokenizer(typing.Protocol):
    @abc.abstractmethod
    def Tokenize(self, text: str) -> List_1[Token]: ...


class Token(IEquatable_1[Token]):
    def __init__(self, Surface: str, BaseForm: str, PartOfSpeech: str, Reading: str, Phonetic: str, InflectionType: str, InflectionForm: str) -> None: ...
    @property
    def BaseForm(self) -> str: ...
    @BaseForm.setter
    def BaseForm(self, value: str) -> str: ...
    @property
    def InflectionForm(self) -> str: ...
    @InflectionForm.setter
    def InflectionForm(self, value: str) -> str: ...
    @property
    def InflectionType(self) -> str: ...
    @InflectionType.setter
    def InflectionType(self, value: str) -> str: ...
    @property
    def PartOfSpeech(self) -> str: ...
    @PartOfSpeech.setter
    def PartOfSpeech(self, value: str) -> str: ...
    @property
    def Phonetic(self) -> str: ...
    @Phonetic.setter
    def Phonetic(self, value: str) -> str: ...
    @property
    def Reading(self) -> str: ...
    @Reading.setter
    def Reading(self, value: str) -> str: ...
    @property
    def Surface(self) -> str: ...
    @Surface.setter
    def Surface(self, value: str) -> str: ...
    def Deconstruct(self, Surface: clr.Reference[str], BaseForm: clr.Reference[str], PartOfSpeech: clr.Reference[str], Reading: clr.Reference[str], Phonetic: clr.Reference[str], InflectionType: clr.Reference[str], InflectionForm: clr.Reference[str]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: Token, right: Token) -> bool: ...
    def __ne__(self, left: Token, right: Token) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Token) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



import typing, abc
from System.Collections.Generic import HashSet_1, List_1, IEnumerable_1, Dictionary_2
from JAStudio.Core.Note.Sentences import SentenceConfiguration
from JAStudio.Core.LanguageServices.JanomeEx.WordExtraction.Matches import Match, VocabMatch
from JAStudio.Core.LanguageServices.JanomeEx import AnalysisServices
from JAStudio.Core.LanguageServices.JanomeEx.Tokenizing import IAnalysisToken, JNTokenizedText
from JAStudio.Core.SysUtils.Json import JsonReader

class AnalysisConstants(abc.ABC):
    AllPunctuationCharacters : HashSet_1[str]
    AllQuoteCharacters : HashSet_1[str]
    CausativeVerbEndings : HashSet_1[str]
    Commas : HashSet_1[str]
    Exclamations : HashSet_1[str]
    NoiseCharacters : HashSet_1[str]
    PassiveVerbEndings : HashSet_1[str]
    Periods : HashSet_1[str]
    PseudoQuoteCharacters : HashSet_1[str]
    QuestionMarks : HashSet_1[str]
    RealQuoteCharacters : HashSet_1[str]
    SentenceEndCharacters : HashSet_1[str]
    SentenceStartCharacters : HashSet_1[str]
    SpaceCharacters : HashSet_1[str]
    Tilde : HashSet_1[str]


class CandidateWord:
    def __init__(self, locations: List_1[TextAnalysisLocation]) -> None: ...
    @property
    def Analysis(self) -> TextAnalysis: ...
    @property
    def BaseForm(self) -> str: ...
    @property
    def BaseVariant(self) -> CandidateWordVariant: ...
    @property
    def DisplayVariants(self) -> List_1[CandidateWordVariant]: ...
    @DisplayVariants.setter
    def DisplayVariants(self, value: List_1[CandidateWordVariant]) -> List_1[CandidateWordVariant]: ...
    @property
    def EndLocation(self) -> TextAnalysisLocation: ...
    @property
    def HasBaseVariantWithValidMatch(self) -> bool: ...
    @property
    def HasSeeminglyValidSingleToken(self) -> bool: ...
    @property
    def IndexingVariants(self) -> List_1[CandidateWordVariant]: ...
    @IndexingVariants.setter
    def IndexingVariants(self, value: List_1[CandidateWordVariant]) -> List_1[CandidateWordVariant]: ...
    @property
    def IsCompound(self) -> bool: ...
    @property
    def IsInflectableWord(self) -> bool: ...
    @property
    def IsInflectedWord(self) -> bool: ...
    @property
    def IsShadowed(self) -> bool: ...
    @property
    def IsWord(self) -> bool: ...
    @property
    def LocationCount(self) -> int: ...
    @property
    def Locations(self) -> List_1[TextAnalysisLocation]: ...
    @property
    def NextTokenIsInflectingWord(self) -> bool: ...
    @property
    def ShadowedBy(self) -> str: ...
    @property
    def ShouldIncludeSurfaceInAllWords(self) -> bool: ...
    @property
    def ShouldIndexBase(self) -> bool: ...
    @property
    def ShouldIndexSurface(self) -> bool: ...
    @property
    def StartLocation(self) -> TextAnalysisLocation: ...
    @property
    def StartsWithNonWordCharacter(self) -> bool: ...
    @property
    def StartsWithNonWordToken(self) -> bool: ...
    @property
    def SurfaceForm(self) -> str: ...
    @property
    def SurfaceVariant(self) -> CandidateWordVariant: ...
    @property
    def ValidVariants(self) -> List_1[CandidateWordVariant]: ...
    @ValidVariants.setter
    def ValidVariants(self, value: List_1[CandidateWordVariant]) -> List_1[CandidateWordVariant]: ...
    def HasValidWords(self) -> bool: ...
    def RunDisplayAnalysisPassTrueIfThereWereChanges(self) -> bool: ...
    def RunValidityAnalysis(self) -> None: ...
    def ToString(self) -> str: ...


class CandidateWordVariant:
    def __init__(self, word: CandidateWord, form: str) -> None: ...
    @property
    def Configuration(self) -> SentenceConfiguration: ...
    @property
    def DisplayMatches(self) -> List_1[Match]: ...
    @property
    def Form(self) -> str: ...
    @property
    def HasValidMatch(self) -> bool: ...
    @property
    def IsKnownWord(self) -> bool: ...
    @property
    def IsSurface(self) -> bool: ...
    @property
    def Matches(self) -> List_1[Match]: ...
    @Matches.setter
    def Matches(self, value: List_1[Match]) -> List_1[Match]: ...
    @property
    def StartIndex(self) -> int: ...
    @property
    def ValidMatches(self) -> IEnumerable_1[Match]: ...
    @property
    def VocabMatches(self) -> List_1[VocabMatch]: ...
    @property
    def VocabsControlMatchStatus(self) -> bool: ...
    @property
    def Word(self) -> CandidateWord: ...
    def RunValidityAnalysis(self) -> None: ...
    def RunVisibilityAnalysis(self) -> None: ...
    def ToExclusion(self) -> WordExclusion: ...
    def ToString(self) -> str: ...


class TextAnalysis:
    def __init__(self, services: AnalysisServices, sentence: str, sentenceConfiguration: SentenceConfiguration, forUI: bool = ...) -> None: ...
    Version : str
    @property
    def Configuration(self) -> SentenceConfiguration: ...
    @property
    def DisplayMatches(self) -> List_1[Match]: ...
    @property
    def DisplayWordVariants(self) -> List_1[CandidateWordVariant]: ...
    @property
    def ForUI(self) -> bool: ...
    @property
    def IndexingWordVariants(self) -> List_1[CandidateWordVariant]: ...
    @property
    def Locations(self) -> List_1[TextAnalysisLocation]: ...
    @property
    def PreProcessedTokens(self) -> List_1[IAnalysisToken]: ...
    @property
    def Services(self) -> AnalysisServices: ...
    @property
    def StartLocation(self) -> TextAnalysisLocation: ...
    @property
    def Text(self) -> str: ...
    @property
    def TokenizedText(self) -> JNTokenizedText: ...
    @property
    def ValidMatches(self) -> List_1[Match]: ...
    def AllWordsStrings(self) -> List_1[str]: ...
    @staticmethod
    def FromText(services: AnalysisServices, text: str) -> TextAnalysis: ...
    def ToString(self) -> str: ...


class TextAnalysisLocation:
    def __init__(self, analysis: TextAnalysis, token: IAnalysisToken, characterStartIndex: int, tokenIndex: int) -> None: ...
    @property
    def Analysis(self) -> TextAnalysis: ...
    @property
    def CandidateWords(self) -> List_1[CandidateWord]: ...
    @CandidateWords.setter
    def CandidateWords(self, value: List_1[CandidateWord]) -> List_1[CandidateWord]: ...
    @property
    def CharacterEndIndex(self) -> int: ...
    @property
    def CharacterStartIndex(self) -> int: ...
    @property
    def DisplayVariants(self) -> List_1[CandidateWordVariant]: ...
    @DisplayVariants.setter
    def DisplayVariants(self, value: List_1[CandidateWordVariant]) -> List_1[CandidateWordVariant]: ...
    @property
    def DisplayWords(self) -> List_1[CandidateWord]: ...
    @DisplayWords.setter
    def DisplayWords(self, value: List_1[CandidateWord]) -> List_1[CandidateWord]: ...
    @property
    def IndexingVariants(self) -> List_1[CandidateWordVariant]: ...
    @IndexingVariants.setter
    def IndexingVariants(self, value: List_1[CandidateWordVariant]) -> List_1[CandidateWordVariant]: ...
    @property
    def IsShadowedBy(self) -> List_1[TextAnalysisLocation]: ...
    @property
    def Next(self) -> TextAnalysisLocation: ...
    @Next.setter
    def Next(self, value: TextAnalysisLocation) -> TextAnalysisLocation: ...
    @property
    def NonCompoundCandidate(self) -> CandidateWord: ...
    @property
    def Previous(self) -> TextAnalysisLocation: ...
    @Previous.setter
    def Previous(self, value: TextAnalysisLocation) -> TextAnalysisLocation: ...
    @property
    def Shadows(self) -> List_1[TextAnalysisLocation]: ...
    @property
    def Token(self) -> IAnalysisToken: ...
    @property
    def TokenIndex(self) -> int: ...
    def AnalysisStep1AnalyzeNonCompoundValidity(self) -> None: ...
    def AnalysisStep2AnalyzeCompoundValidity(self) -> None: ...
    def AnalysisStep3RunDisplayAnalysisWithoutShadowingInformationSoThatAllValidMatchesAreDisplayedAndCanBeAccountedForInYieldingToUpcomingCompounds(self) -> None: ...
    def AnalysisStep4SetInitialShadowingAndRecalculateDisplayWordsReturnTrueOnChanges(self) -> bool: ...
    def AnalysisStep5UpdateShadowingAndRecalculateDisplayWordsReturnTrueOnChanges(self) -> bool: ...
    def ForwardList(self, length: int = ...) -> List_1[TextAnalysisLocation]: ...
    def IsInflectingWord(self) -> bool: ...
    def IsNextLocationInflectingWord(self) -> bool: ...
    def RunDisplayAnalysisAndUpdateDisplayWordsPassTrueIfThereWereChanges(self) -> bool: ...
    def ToString(self) -> str: ...
    def UpdateShadowing(self) -> None: ...


class WordExclusion:
    @property
    def Index(self) -> int: ...
    @property
    def Word(self) -> str: ...
    @staticmethod
    def AtIndex(exclusion: str, index: int) -> WordExclusion: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def ExcludesAllWordsExcludedBy(self, other: WordExclusion) -> bool: ...
    def ExcludesFormAtIndex(self, form: str, index: int) -> bool: ...
    @staticmethod
    def FromReader(reader: JsonReader) -> WordExclusion: ...
    @staticmethod
    def FromString(value: str) -> WordExclusion: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Global(exclusion: str) -> WordExclusion: ...
    def ToDict(self) -> Dictionary_2[str, typing.Any]: ...
    def ToString(self) -> str: ...


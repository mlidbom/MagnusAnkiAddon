import typing, clr
from System import IEquatable_1
from System.Collections.Generic import List_1
from JAStudio.Core.Domain import Token
from JAStudio.Core.Ports import IJapaneseNlpProvider

class TokenizationResult(IEquatable_1[TokenizationResult]):
    def __init__(self, Text: str, Tokens: List_1[Token], TokenCount: int, UniqueBaseForms: int) -> None: ...
    @property
    def Text(self) -> str: ...
    @Text.setter
    def Text(self, value: str) -> str: ...
    @property
    def TokenCount(self) -> int: ...
    @TokenCount.setter
    def TokenCount(self, value: int) -> int: ...
    @property
    def Tokens(self) -> List_1[Token]: ...
    @Tokens.setter
    def Tokens(self, value: List_1[Token]) -> List_1[Token]: ...
    @property
    def UniqueBaseForms(self) -> int: ...
    @UniqueBaseForms.setter
    def UniqueBaseForms(self, value: int) -> int: ...
    def Deconstruct(self, Text: clr.Reference[str], Tokens: clr.Reference[List_1[Token]], TokenCount: clr.Reference[int], UniqueBaseForms: clr.Reference[int]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: TokenizationResult, right: TokenizationResult) -> bool: ...
    def __ne__(self, left: TokenizationResult, right: TokenizationResult) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: TokenizationResult) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class TokenizerService:
    def __init__(self, nlpProvider: IJapaneseNlpProvider) -> None: ...
    def Analyze(self, text: str) -> TokenizationResult: ...
    def ExtractVerbs(self, text: str) -> List_1[Token]: ...


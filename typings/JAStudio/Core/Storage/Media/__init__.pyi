import typing, clr, abc
from System import IEquatable_1, Guid
from JAStudio.Core.Note import NoteId, KanjiNote
from System.Collections.Generic import List_1, IReadOnlyCollection_1, IReadOnlyList_1
from JAStudio.Core.TaskRunners import TaskRunner
from JAStudio.Core.Note.Sentences import SentenceNote
from JAStudio.Core.Note.Vocabulary import VocabNote
from JAStudio.Core.Note.NoteFields import MediaType

class AlreadyStoredFile(IEquatable_1[AlreadyStoredFile]):
    def __init__(self, Existing: MediaAttachment, NoteId: NoteId) -> None: ...
    @property
    def Existing(self) -> MediaAttachment: ...
    @Existing.setter
    def Existing(self, value: MediaAttachment) -> MediaAttachment: ...
    @property
    def NoteId(self) -> NoteId: ...
    @NoteId.setter
    def NoteId(self, value: NoteId) -> NoteId: ...
    def Deconstruct(self, Existing: clr.Reference[MediaAttachment], NoteId: clr.Reference[NoteId]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: AlreadyStoredFile, right: AlreadyStoredFile) -> bool: ...
    def __ne__(self, left: AlreadyStoredFile, right: AlreadyStoredFile) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: AlreadyStoredFile) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class AudioAttachment(MediaAttachment, IEquatable_1[AudioAttachment]):
    def __init__(self) -> None: ...
    @property
    def Copyright(self) -> CopyrightStatus: ...
    @Copyright.setter
    def Copyright(self, value: CopyrightStatus) -> CopyrightStatus: ...
    @property
    def FilePath(self) -> str: ...
    @FilePath.setter
    def FilePath(self, value: str) -> str: ...
    @property
    def Id(self) -> MediaFileId: ...
    @Id.setter
    def Id(self, value: MediaFileId) -> MediaFileId: ...
    @property
    def NoteIds(self) -> List_1[NoteId]: ...
    @NoteIds.setter
    def NoteIds(self, value: List_1[NoteId]) -> List_1[NoteId]: ...
    @property
    def NoteSourceTag(self) -> SourceTag: ...
    @NoteSourceTag.setter
    def NoteSourceTag(self, value: SourceTag) -> SourceTag: ...
    @property
    def OriginalFileName(self) -> str: ...
    @OriginalFileName.setter
    def OriginalFileName(self, value: str) -> str: ...
    @property
    def Tts(self) -> TtsInfo: ...
    @Tts.setter
    def Tts(self, value: TtsInfo) -> TtsInfo: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: AudioAttachment, right: AudioAttachment) -> bool: ...
    def __ne__(self, left: AudioAttachment, right: AudioAttachment) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: AudioAttachment) -> bool:...
        @typing.overload
        def __call__(self, other: MediaAttachment) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class CopyrightStatus(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : CopyrightStatus # 0
    Commercial : CopyrightStatus # 1
    Free : CopyrightStatus # 2


class ImageAttachment(MediaAttachment, IEquatable_1[ImageAttachment]):
    def __init__(self) -> None: ...
    @property
    def Copyright(self) -> CopyrightStatus: ...
    @Copyright.setter
    def Copyright(self, value: CopyrightStatus) -> CopyrightStatus: ...
    @property
    def FilePath(self) -> str: ...
    @FilePath.setter
    def FilePath(self, value: str) -> str: ...
    @property
    def Id(self) -> MediaFileId: ...
    @Id.setter
    def Id(self, value: MediaFileId) -> MediaFileId: ...
    @property
    def NoteIds(self) -> List_1[NoteId]: ...
    @NoteIds.setter
    def NoteIds(self, value: List_1[NoteId]) -> List_1[NoteId]: ...
    @property
    def NoteSourceTag(self) -> SourceTag: ...
    @NoteSourceTag.setter
    def NoteSourceTag(self, value: SourceTag) -> SourceTag: ...
    @property
    def OriginalFileName(self) -> str: ...
    @OriginalFileName.setter
    def OriginalFileName(self, value: str) -> str: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: ImageAttachment, right: ImageAttachment) -> bool: ...
    def __ne__(self, left: ImageAttachment, right: ImageAttachment) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: ImageAttachment) -> bool:...
        @typing.overload
        def __call__(self, other: MediaAttachment) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class KanjiImportRule(IEquatable_1[KanjiImportRule]):
    def __init__(self, Prefix: SourceTag, Field: KanjiMediaField, TargetDirectory: str, Copyright: CopyrightStatus) -> None: ...
    @property
    def Copyright(self) -> CopyrightStatus: ...
    @Copyright.setter
    def Copyright(self, value: CopyrightStatus) -> CopyrightStatus: ...
    @property
    def Field(self) -> KanjiMediaField: ...
    @Field.setter
    def Field(self, value: KanjiMediaField) -> KanjiMediaField: ...
    @property
    def Prefix(self) -> SourceTag: ...
    @Prefix.setter
    def Prefix(self, value: SourceTag) -> SourceTag: ...
    @property
    def TargetDirectory(self) -> str: ...
    @TargetDirectory.setter
    def TargetDirectory(self, value: str) -> str: ...
    def Deconstruct(self, Prefix: clr.Reference[SourceTag], Field: clr.Reference[KanjiMediaField], TargetDirectory: clr.Reference[str], Copyright: clr.Reference[CopyrightStatus]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: KanjiImportRule, right: KanjiImportRule) -> bool: ...
    def __ne__(self, left: KanjiImportRule, right: KanjiImportRule) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: KanjiImportRule) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class KanjiMediaField(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Audio : KanjiMediaField # 0
    Image : KanjiMediaField # 1


class MediaAttachment(IEquatable_1[MediaAttachment], abc.ABC):
    @property
    def Copyright(self) -> CopyrightStatus: ...
    @Copyright.setter
    def Copyright(self, value: CopyrightStatus) -> CopyrightStatus: ...
    @property
    def FilePath(self) -> str: ...
    @FilePath.setter
    def FilePath(self, value: str) -> str: ...
    @property
    def Id(self) -> MediaFileId: ...
    @Id.setter
    def Id(self, value: MediaFileId) -> MediaFileId: ...
    @property
    def NoteIds(self) -> List_1[NoteId]: ...
    @NoteIds.setter
    def NoteIds(self, value: List_1[NoteId]) -> List_1[NoteId]: ...
    @property
    def NoteSourceTag(self) -> SourceTag: ...
    @NoteSourceTag.setter
    def NoteSourceTag(self, value: SourceTag) -> SourceTag: ...
    @property
    def OriginalFileName(self) -> str: ...
    @OriginalFileName.setter
    def OriginalFileName(self, value: str) -> str: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: MediaAttachment, right: MediaAttachment) -> bool: ...
    def __ne__(self, left: MediaAttachment, right: MediaAttachment) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: MediaAttachment) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class MediaFileId(IEquatable_1[MediaFileId]):
    def __init__(self, Value: Guid) -> None: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def Value(self) -> Guid: ...
    @Value.setter
    def Value(self, value: Guid) -> Guid: ...
    def Deconstruct(self, Value: clr.Reference[Guid]) -> None: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def New() -> MediaFileId: ...
    def __eq__(self, left: MediaFileId, right: MediaFileId) -> bool: ...
    def __ne__(self, left: MediaFileId, right: MediaFileId) -> bool: ...
    @staticmethod
    def Parse(value: str) -> MediaFileId: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(value: str, result: clr.Reference[MediaFileId]) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: MediaFileId) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class MediaFileIndex:
    def __init__(self, mediaRoot: str, taskRunner: TaskRunner) -> None: ...
    @property
    def All(self) -> IReadOnlyCollection_1[MediaAttachment]: ...
    @property
    def Count(self) -> int: ...
    def Build(self) -> None: ...
    def Contains(self, id: MediaFileId) -> bool: ...
    def ContainsByOriginalFileName(self, originalFileName: str) -> bool: ...
    def GetNoteMedia(self, noteId: NoteId) -> NoteMedia: ...
    def Register(self, attachment: MediaAttachment) -> None: ...
    def TryGetAttachment(self, id: MediaFileId) -> MediaAttachment: ...
    def TryGetByOriginalFileName(self, originalFileName: str) -> MediaAttachment: ...
    def TryGetInfo(self, id: MediaFileId) -> MediaFileInfo: ...
    def TryResolve(self, id: MediaFileId) -> str: ...


class MediaFileInfo(IEquatable_1[MediaFileInfo]):
    def __init__(self, Id: MediaFileId, FullPath: str, OriginalFileName: str, Extension: str) -> None: ...
    @property
    def Extension(self) -> str: ...
    @Extension.setter
    def Extension(self, value: str) -> str: ...
    @property
    def FullPath(self) -> str: ...
    @FullPath.setter
    def FullPath(self, value: str) -> str: ...
    @property
    def Id(self) -> MediaFileId: ...
    @Id.setter
    def Id(self, value: MediaFileId) -> MediaFileId: ...
    @property
    def OriginalFileName(self) -> str: ...
    @OriginalFileName.setter
    def OriginalFileName(self, value: str) -> str: ...
    def Deconstruct(self, Id: clr.Reference[MediaFileId], FullPath: clr.Reference[str], OriginalFileName: clr.Reference[str], Extension: clr.Reference[str]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: MediaFileInfo, right: MediaFileInfo) -> bool: ...
    def __ne__(self, left: MediaFileInfo, right: MediaFileInfo) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: MediaFileInfo) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class MediaImportAnalyzer:
    def __init__(self, ankiMediaDir: str, index: MediaFileIndex) -> None: ...
    def AnalyzeKanji(self, notes: IReadOnlyList_1[KanjiNote], rules: IReadOnlyList_1[KanjiImportRule]) -> MediaImportPlan: ...
    def AnalyzeSentences(self, notes: IReadOnlyList_1[SentenceNote], rules: IReadOnlyList_1[SentenceImportRule]) -> MediaImportPlan: ...
    def AnalyzeVocab(self, notes: IReadOnlyList_1[VocabNote], rules: IReadOnlyList_1[VocabImportRule]) -> MediaImportPlan: ...
    def IsAlreadyStored(self, originalFileName: str) -> bool: ...


class MediaImportExecutor:
    def __init__(self, storageService: MediaStorageService, taskRunner: TaskRunner) -> None: ...
    def Execute(self, plan: MediaImportPlan) -> None: ...


class MediaImportPlan:
    def __init__(self) -> None: ...
    @property
    def AlreadyStored(self) -> List_1[AlreadyStoredFile]: ...
    @property
    def FilesToImport(self) -> List_1[PlannedFileImport]: ...
    @property
    def Missing(self) -> List_1[MissingFile]: ...


class MediaImportRulePersistence:
    def __init__(self) -> None: ...
    @staticmethod
    def Load() -> PersistedImportRules: ...
    @staticmethod
    def Save(rules: PersistedImportRules) -> None: ...


class MediaImportRuleSet:
    def __init__(self, vocabRules: List_1[VocabImportRule], sentenceRules: List_1[SentenceImportRule], kanjiRules: List_1[KanjiImportRule]) -> None: ...
    def TryResolveKanji(self, sourceTag: SourceTag, field: KanjiMediaField) -> KanjiImportRule: ...
    def TryResolveSentence(self, sourceTag: SourceTag, field: SentenceMediaField) -> SentenceImportRule: ...
    def TryResolveVocab(self, sourceTag: SourceTag, field: VocabMediaField) -> VocabImportRule: ...


class MediaStorageService:
    def __init__(self, mediaRoot: str, index: MediaFileIndex) -> None: ...
    def AddNoteIdToExisting(self, existing: MediaAttachment, noteId: NoteId) -> None: ...
    def Exists(self, id: MediaFileId) -> bool: ...
    def StoreFile(self, sourceFilePath: str, targetDirectory: str, sourceTag: SourceTag, originalFileName: str, noteId: NoteId, mediaType: MediaType, copyright: CopyrightStatus, tts: TtsInfo = ...) -> MediaFileId: ...
    def TryResolve(self, id: MediaFileId) -> str: ...


class MissingFile(IEquatable_1[MissingFile]):
    def __init__(self, FileName: str, NoteId: NoteId, FieldName: str) -> None: ...
    @property
    def FieldName(self) -> str: ...
    @FieldName.setter
    def FieldName(self, value: str) -> str: ...
    @property
    def FileName(self) -> str: ...
    @FileName.setter
    def FileName(self, value: str) -> str: ...
    @property
    def NoteId(self) -> NoteId: ...
    @NoteId.setter
    def NoteId(self, value: NoteId) -> NoteId: ...
    def Deconstruct(self, FileName: clr.Reference[str], NoteId: clr.Reference[NoteId], FieldName: clr.Reference[str]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: MissingFile, right: MissingFile) -> bool: ...
    def __ne__(self, left: MissingFile, right: MissingFile) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: MissingFile) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class NoteMedia(IEquatable_1[NoteMedia]):
    def __init__(self, Audio: IReadOnlyList_1[AudioAttachment], Images: IReadOnlyList_1[ImageAttachment]) -> None: ...
    @property
    def Audio(self) -> IReadOnlyList_1[AudioAttachment]: ...
    @Audio.setter
    def Audio(self, value: IReadOnlyList_1[AudioAttachment]) -> IReadOnlyList_1[AudioAttachment]: ...
    @classmethod
    @property
    def Empty(cls) -> NoteMedia: ...
    @property
    def Images(self) -> IReadOnlyList_1[ImageAttachment]: ...
    @Images.setter
    def Images(self, value: IReadOnlyList_1[ImageAttachment]) -> IReadOnlyList_1[ImageAttachment]: ...
    def Deconstruct(self, Audio: clr.Reference[IReadOnlyList_1[AudioAttachment]], Images: clr.Reference[IReadOnlyList_1[ImageAttachment]]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: NoteMedia, right: NoteMedia) -> bool: ...
    def __ne__(self, left: NoteMedia, right: NoteMedia) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: NoteMedia) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class PersistedImportRules:
    def __init__(self) -> None: ...
    @property
    def KanjiRules(self) -> List_1[KanjiImportRule]: ...
    @KanjiRules.setter
    def KanjiRules(self, value: List_1[KanjiImportRule]) -> List_1[KanjiImportRule]: ...
    @property
    def SentenceRules(self) -> List_1[SentenceImportRule]: ...
    @SentenceRules.setter
    def SentenceRules(self, value: List_1[SentenceImportRule]) -> List_1[SentenceImportRule]: ...
    @property
    def VocabRules(self) -> List_1[VocabImportRule]: ...
    @VocabRules.setter
    def VocabRules(self, value: List_1[VocabImportRule]) -> List_1[VocabImportRule]: ...


class PlannedFileImport(IEquatable_1[PlannedFileImport]):
    def __init__(self, SourcePath: str, TargetDirectory: str, Copyright: CopyrightStatus, SourceTag: SourceTag, OriginalFileName: str, NoteId: NoteId, MediaType: MediaType) -> None: ...
    @property
    def Copyright(self) -> CopyrightStatus: ...
    @Copyright.setter
    def Copyright(self, value: CopyrightStatus) -> CopyrightStatus: ...
    @property
    def MediaType(self) -> MediaType: ...
    @MediaType.setter
    def MediaType(self, value: MediaType) -> MediaType: ...
    @property
    def NoteId(self) -> NoteId: ...
    @NoteId.setter
    def NoteId(self, value: NoteId) -> NoteId: ...
    @property
    def OriginalFileName(self) -> str: ...
    @OriginalFileName.setter
    def OriginalFileName(self, value: str) -> str: ...
    @property
    def SourcePath(self) -> str: ...
    @SourcePath.setter
    def SourcePath(self, value: str) -> str: ...
    @property
    def SourceTag(self) -> SourceTag: ...
    @SourceTag.setter
    def SourceTag(self, value: SourceTag) -> SourceTag: ...
    @property
    def TargetDirectory(self) -> str: ...
    @TargetDirectory.setter
    def TargetDirectory(self, value: str) -> str: ...
    def Deconstruct(self, SourcePath: clr.Reference[str], TargetDirectory: clr.Reference[str], Copyright: clr.Reference[CopyrightStatus], SourceTag: clr.Reference[SourceTag], OriginalFileName: clr.Reference[str], NoteId: clr.Reference[NoteId], MediaType: clr.Reference[MediaType]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: PlannedFileImport, right: PlannedFileImport) -> bool: ...
    def __ne__(self, left: PlannedFileImport, right: PlannedFileImport) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: PlannedFileImport) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class SentenceImportRule(IEquatable_1[SentenceImportRule]):
    def __init__(self, Prefix: SourceTag, Field: SentenceMediaField, TargetDirectory: str, Copyright: CopyrightStatus) -> None: ...
    @property
    def Copyright(self) -> CopyrightStatus: ...
    @Copyright.setter
    def Copyright(self, value: CopyrightStatus) -> CopyrightStatus: ...
    @property
    def Field(self) -> SentenceMediaField: ...
    @Field.setter
    def Field(self, value: SentenceMediaField) -> SentenceMediaField: ...
    @property
    def Prefix(self) -> SourceTag: ...
    @Prefix.setter
    def Prefix(self, value: SourceTag) -> SourceTag: ...
    @property
    def TargetDirectory(self) -> str: ...
    @TargetDirectory.setter
    def TargetDirectory(self, value: str) -> str: ...
    def Deconstruct(self, Prefix: clr.Reference[SourceTag], Field: clr.Reference[SentenceMediaField], TargetDirectory: clr.Reference[str], Copyright: clr.Reference[CopyrightStatus]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: SentenceImportRule, right: SentenceImportRule) -> bool: ...
    def __ne__(self, left: SentenceImportRule, right: SentenceImportRule) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: SentenceImportRule) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class SentenceMediaField(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Audio : SentenceMediaField # 0
    Screenshot : SentenceMediaField # 1


class SidecarSerializer(abc.ABC):
    AudioSidecarExtension : str
    AudioSidecarGlob : str
    ImageSidecarExtension : str
    ImageSidecarGlob : str
    @staticmethod
    def BuildAudioSidecarPath(mediaFilePath: str) -> str: ...
    @staticmethod
    def BuildImageSidecarPath(mediaFilePath: str) -> str: ...
    @staticmethod
    def DeserializeAudio(json: str) -> AudioAttachment: ...
    @staticmethod
    def DeserializeImage(json: str) -> ImageAttachment: ...
    @staticmethod
    def IsSidecarFile(filePath: str) -> bool: ...
    @staticmethod
    def ReadAudioSidecar(sidecarPath: str) -> AudioAttachment: ...
    @staticmethod
    def ReadImageSidecar(sidecarPath: str) -> ImageAttachment: ...
    @staticmethod
    def SerializeAudio(attachment: AudioAttachment) -> str: ...
    @staticmethod
    def SerializeImage(attachment: ImageAttachment) -> str: ...
    @staticmethod
    def WriteAudioSidecar(sidecarPath: str, attachment: AudioAttachment) -> None: ...
    @staticmethod
    def WriteImageSidecar(sidecarPath: str, attachment: ImageAttachment) -> None: ...


class SourceTag(IEquatable_1[SourceTag]):
    @property
    def Segments(self) -> IReadOnlyList_1[str]: ...
    def Contains(self, descendant: SourceTag) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsContainedIn(self, ancestor: SourceTag) -> bool: ...
    def __eq__(self, left: SourceTag, right: SourceTag) -> bool: ...
    def __ne__(self, left: SourceTag, right: SourceTag) -> bool: ...
    @staticmethod
    def Parse(value: str) -> SourceTag: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: SourceTag) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class TtsInfo(IEquatable_1[TtsInfo]):
    def __init__(self, Engine: str, Voice: str, Version: str) -> None: ...
    @property
    def Engine(self) -> str: ...
    @Engine.setter
    def Engine(self, value: str) -> str: ...
    @property
    def Version(self) -> str: ...
    @Version.setter
    def Version(self, value: str) -> str: ...
    @property
    def Voice(self) -> str: ...
    @Voice.setter
    def Voice(self, value: str) -> str: ...
    def Deconstruct(self, Engine: clr.Reference[str], Voice: clr.Reference[str], Version: clr.Reference[str]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: TtsInfo, right: TtsInfo) -> bool: ...
    def __ne__(self, left: TtsInfo, right: TtsInfo) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: TtsInfo) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class VocabImportRule(IEquatable_1[VocabImportRule]):
    def __init__(self, Prefix: SourceTag, Field: VocabMediaField, TargetDirectory: str, Copyright: CopyrightStatus) -> None: ...
    @property
    def Copyright(self) -> CopyrightStatus: ...
    @Copyright.setter
    def Copyright(self, value: CopyrightStatus) -> CopyrightStatus: ...
    @property
    def Field(self) -> VocabMediaField: ...
    @Field.setter
    def Field(self, value: VocabMediaField) -> VocabMediaField: ...
    @property
    def Prefix(self) -> SourceTag: ...
    @Prefix.setter
    def Prefix(self, value: SourceTag) -> SourceTag: ...
    @property
    def TargetDirectory(self) -> str: ...
    @TargetDirectory.setter
    def TargetDirectory(self, value: str) -> str: ...
    def Deconstruct(self, Prefix: clr.Reference[SourceTag], Field: clr.Reference[VocabMediaField], TargetDirectory: clr.Reference[str], Copyright: clr.Reference[CopyrightStatus]) -> None: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: VocabImportRule, right: VocabImportRule) -> bool: ...
    def __ne__(self, left: VocabImportRule, right: VocabImportRule) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: VocabImportRule) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class VocabMediaField(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    AudioFirst : VocabMediaField # 0
    AudioSecond : VocabMediaField # 1
    AudioTts : VocabMediaField # 2
    Image : VocabMediaField # 3
    UserImage : VocabMediaField # 4


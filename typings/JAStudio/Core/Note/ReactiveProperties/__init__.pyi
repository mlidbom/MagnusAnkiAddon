import typing, abc
from System.Collections.Generic import List_1, IEnumerable_1, Dictionary_2
from System import IDisposable, IObservable_1, Func_1, Array_1, IObserver_1, Action_1, Action, Func_2
from JAStudio.Core.Note.NoteFields import IObjectSerializer_1

class AudioProperty:
    def __init__(self, field: StringProperty) -> None: ...
    def AudioFilesPaths(self) -> List_1[str]: ...
    def FirstAudioFilePath(self) -> str: ...
    def HasAudio(self) -> bool: ...
    def RawValue(self) -> str: ...
    def SetRawValue(self, value: str) -> None: ...
    def ToString(self) -> str: ...


class Computed_GenericClasses(abc.ABCMeta):
    Generic_Computed_GenericClasses_Computed_1_T = typing.TypeVar('Generic_Computed_GenericClasses_Computed_1_T')
    def __getitem__(self, types : typing.Type[Generic_Computed_GenericClasses_Computed_1_T]) -> typing.Type[Computed_1[Generic_Computed_GenericClasses_Computed_1_T]]: ...

Computed : Computed_GenericClasses

Computed_1_T = typing.TypeVar('Computed_1_T')
class Computed_1(typing.Generic[Computed_1_T], IDisposable, IObservable_1[Computed_1_T]):
    @typing.overload
    def __init__(self, compute: Func_1[Computed_1_T], sources: Array_1[IObservable_1[typing.Any]]) -> None: ...
    @typing.overload
    def __init__(self, compute: Func_1[Computed_1_T], sources: IEnumerable_1[IObservable_1[typing.Any]]) -> None: ...
    @property
    def Value(self) -> Computed_1_T: ...
    def Dispose(self) -> None: ...
    def Subscribe(self, observer: IObserver_1[Computed_1_T]) -> IDisposable: ...
    def ToString(self) -> str: ...


class FallbackHtmlStrippedProperty:
    def __init__(self, primaryField: StringProperty, fallbackField: StringProperty) -> None: ...
    def Get(self) -> str: ...


class ObservableExtensions(abc.ABC):
    # Skipped AsUntyped due to it being static, abstract and generic.

    AsUntyped : AsUntyped_MethodGroup
    class AsUntyped_MethodGroup:
        def __getitem__(self, t:typing.Type[AsUntyped_1_T1]) -> AsUntyped_1[AsUntyped_1_T1]: ...

        AsUntyped_1_T1 = typing.TypeVar('AsUntyped_1_T1')
        class AsUntyped_1(typing.Generic[AsUntyped_1_T1]):
            AsUntyped_1_T = ObservableExtensions.AsUntyped_MethodGroup.AsUntyped_1_T1
            def __call__(self, source: IObservable_1[AsUntyped_1_T]) -> IObservable_1[typing.Any]:...


    # Skipped Subscribe due to it being static, abstract and generic.

    Subscribe : Subscribe_MethodGroup
    class Subscribe_MethodGroup:
        def __getitem__(self, t:typing.Type[Subscribe_1_T1]) -> Subscribe_1[Subscribe_1_T1]: ...

        Subscribe_1_T1 = typing.TypeVar('Subscribe_1_T1')
        class Subscribe_1(typing.Generic[Subscribe_1_T1]):
            Subscribe_1_T = ObservableExtensions.Subscribe_MethodGroup.Subscribe_1_T1
            @typing.overload
            def __call__(self, source: IObservable_1[Subscribe_1_T], onNext: Action_1[Subscribe_1_T]) -> IDisposable:...
            @typing.overload
            def __call__(self, source: IObservable_1[Subscribe_1_T], onNext: Action) -> IDisposable:...




class Property_GenericClasses(abc.ABCMeta):
    Generic_Property_GenericClasses_Property_1_T = typing.TypeVar('Generic_Property_GenericClasses_Property_1_T')
    def __getitem__(self, types : typing.Type[Generic_Property_GenericClasses_Property_1_T]) -> typing.Type[Property_1[Generic_Property_GenericClasses_Property_1_T]]: ...

Property : Property_GenericClasses

Property_1_T = typing.TypeVar('Property_1_T')
class Property_1(typing.Generic[Property_1_T], IDisposable, IObservable_1[Property_1_T]):
    def __init__(self, initialValue: Property_1_T = ...) -> None: ...
    @property
    def Value(self) -> Property_1_T: ...
    @Value.setter
    def Value(self, value: Property_1_T) -> Property_1_T: ...
    def Dispose(self) -> None: ...
    def SetSilently(self, value: Property_1_T) -> None: ...
    def Subscribe(self, observer: IObserver_1[Property_1_T]) -> IDisposable: ...
    def ToString(self) -> str: ...


class PropertyBag(IDisposable):
    def __init__(self) -> None: ...
    @property
    def AnyChanged(self) -> IObservable_1[typing.Any]: ...
    def Dispose(self) -> None: ...
    def Int(self, fieldKey: str, defaultValue: int = ...) -> Property_1[int]: ...
    def LoadFromDictionary(self, fields: Dictionary_2[str, str]) -> None: ...
    def Silently(self, action: Action) -> None: ...
    def String(self, fieldKey: str) -> StringProperty: ...
    def ToDictionary(self) -> Dictionary_2[str, str]: ...
    # Skipped Register due to it being static, abstract and generic.

    Register : Register_MethodGroup
    class Register_MethodGroup:
        def __getitem__(self, t:typing.Type[Register_1_T1]) -> Register_1[Register_1_T1]: ...

        Register_1_T1 = typing.TypeVar('Register_1_T1')
        class Register_1(typing.Generic[Register_1_T1]):
            Register_1_T = PropertyBag.Register_MethodGroup.Register_1_T1
            def __call__(self, fieldKey: str, deserialize: Func_2[str, Register_1_T], serialize: Func_2[Register_1_T, str], defaultValue: Register_1_T = ...) -> Property_1[Register_1_T]:...




class SentenceQuestionProperty:
    def __init__(self, userField: StringProperty, sourceField: StringProperty) -> None: ...
    WordBreakTag : str
    def SplitTokenWithWordBreakTag(self, section: str) -> None: ...
    def WithInvisibleSpace(self) -> str: ...
    def WithoutInvisibleSpace(self) -> str: ...


class SerializedObjectProperty_GenericClasses(abc.ABCMeta):
    Generic_SerializedObjectProperty_GenericClasses_SerializedObjectProperty_1_T = typing.TypeVar('Generic_SerializedObjectProperty_GenericClasses_SerializedObjectProperty_1_T')
    def __getitem__(self, types : typing.Type[Generic_SerializedObjectProperty_GenericClasses_SerializedObjectProperty_1_T]) -> typing.Type[SerializedObjectProperty_1[Generic_SerializedObjectProperty_GenericClasses_SerializedObjectProperty_1_T]]: ...

SerializedObjectProperty : SerializedObjectProperty_GenericClasses

SerializedObjectProperty_1_T = typing.TypeVar('SerializedObjectProperty_1_T')
class SerializedObjectProperty_1(typing.Generic[SerializedObjectProperty_1_T]):
    def __init__(self, field: StringProperty, serializer: IObjectSerializer_1[SerializedObjectProperty_1_T]) -> None: ...
    def Get(self) -> SerializedObjectProperty_1_T: ...
    def Save(self) -> None: ...
    def Set(self, value: SerializedObjectProperty_1_T) -> None: ...
    def ToString(self) -> str: ...


class Signal(IDisposable, IObservable_1[typing.Any]):
    def __init__(self) -> None: ...
    def Dispose(self) -> None: ...
    def Fire(self) -> None: ...
    def Subscribe(self, observer: IObserver_1[typing.Any]) -> IDisposable: ...


class StringProperty(Property_1[str]):
    def __init__(self, initialValue: str = ...) -> None: ...
    @property
    def Value(self) -> str: ...
    @Value.setter
    def Value(self, value: str) -> str: ...
    def Empty(self) -> None: ...
    def HasValue(self) -> bool: ...
    def Set(self, value: str) -> None: ...


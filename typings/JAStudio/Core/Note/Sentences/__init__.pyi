import typing
from JAStudio.Core.Note import SentenceNote, VocabNote, NoteId
from JAStudio.Core.Note.ReactiveProperties import StringProperty
from System.Collections.Generic import List_1, HashSet_1, IEnumerable_1
from JAStudio.Core.Note.Sentences.Serialization import ParsedWordSerializer, ParsingResultSerializer
from JAStudio.Core.LanguageServices.JanomeEx.WordExtraction.Matches import Match
from JAStudio.Core.LanguageServices.JanomeEx.WordExtraction import TextAnalysis, WordExclusion
from System import Action

class CachingSentenceConfigurationField:
    def __init__(self, sentence: SentenceNote, field: StringProperty) -> None: ...
    Field : StringProperty
    @property
    def Configuration(self) -> SentenceConfiguration: ...
    @property
    def HiddenMatches(self) -> WordExclusionSet: ...
    @property
    def HighlightedWords(self) -> List_1[str]: ...
    @property
    def IncorrectMatches(self) -> WordExclusionSet: ...
    def AddHighlightedWord(self, vocab: str) -> None: ...
    def HighlightedVocab(self) -> HashSet_1[VocabNote]: ...
    def RemoveHighlightedWord(self, word: str) -> None: ...
    def ResetHighlightedWords(self) -> None: ...
    def SetValueDirectlyTestsOnly(self, configuration: SentenceConfiguration) -> None: ...


class ParsedMatch:
    def __init__(self, variant: str, startIndex: int, isDisplayed: bool, word: str, vocabId: NoteId) -> None: ...
    Serializer : ParsedWordSerializer
    @property
    def EndIndex(self) -> int: ...
    @property
    def IsDisplayed(self) -> bool: ...
    @IsDisplayed.setter
    def IsDisplayed(self, value: bool) -> bool: ...
    @property
    def ParsedForm(self) -> str: ...
    @ParsedForm.setter
    def ParsedForm(self, value: str) -> str: ...
    @property
    def StartIndex(self) -> int: ...
    @StartIndex.setter
    def StartIndex(self, value: int) -> int: ...
    @property
    def Variant(self) -> str: ...
    @Variant.setter
    def Variant(self, value: str) -> str: ...
    @property
    def VocabId(self) -> NoteId: ...
    @VocabId.setter
    def VocabId(self, value: NoteId) -> NoteId: ...
    @staticmethod
    def FromMatch(match: Match) -> ParsedMatch: ...
    def ToString(self) -> str: ...


class ParsingResult:
    def __init__(self, words: List_1[ParsedMatch], sentence: str, parserVersion: str) -> None: ...
    Serializer : ParsingResultSerializer
    @property
    def MatchedVocabIds(self) -> HashSet_1[NoteId]: ...
    @property
    def ParsedWords(self) -> List_1[ParsedMatch]: ...
    @property
    def ParserVersion(self) -> str: ...
    @property
    def Sentence(self) -> str: ...
    @staticmethod
    def FromAnalysis(analysis: TextAnalysis) -> ParsingResult: ...
    def ParsedWordsStrings(self) -> List_1[str]: ...


class SentenceConfiguration:
    def __init__(self, highlightedWords: List_1[str], incorrectMatches: WordExclusionSet, hiddenMatches: WordExclusionSet) -> None: ...
    @property
    def HiddenMatches(self) -> WordExclusionSet: ...
    @property
    def HighlightedWords(self) -> List_1[str]: ...
    @property
    def IncorrectMatches(self) -> WordExclusionSet: ...
    @staticmethod
    def Empty() -> SentenceConfiguration: ...
    @staticmethod
    def FromHiddenMatches(hiddenMatches: List_1[WordExclusion]) -> SentenceConfiguration: ...
    @staticmethod
    def FromIncorrectMatches(incorrectMatches: List_1[WordExclusion]) -> SentenceConfiguration: ...
    @staticmethod
    def FromValues(highlighted: List_1[str], incorrectMatches: List_1[WordExclusion], hiddenMatches: List_1[WordExclusion]) -> SentenceConfiguration: ...
    def ToString(self) -> str: ...


class SentenceUserProperties:
    def __init__(self, comments: StringProperty, answer: StringProperty, question: StringProperty) -> None: ...
    @property
    def Answer(self) -> StringProperty: ...
    @property
    def Comments(self) -> StringProperty: ...
    @property
    def Question(self) -> StringProperty: ...


class WordExclusionSet:
    def __init__(self, saveCallback: Action, exclusions: List_1[WordExclusion]) -> None: ...
    def Add(self, exclusion: WordExclusion) -> None: ...
    def AddGlobal(self, vocab: str) -> None: ...
    def ExcludesAtIndex(self, word: str, index: int) -> bool: ...
    def Get(self) -> IEnumerable_1[WordExclusion]: ...
    def IsEmpty(self) -> bool: ...
    def Remove(self, exclusion: WordExclusion) -> None: ...
    def RemoveString(self, toRemove: str) -> None: ...
    def Reset(self) -> None: ...
    def ToString(self) -> str: ...
    def Words(self) -> HashSet_1[str]: ...
    # Skipped Empty due to it being static, abstract and generic.

    Empty : Empty_MethodGroup
    class Empty_MethodGroup:
        @typing.overload
        def __call__(self) -> WordExclusionSet:...
        @typing.overload
        def __call__(self, saveCallback: Action) -> WordExclusionSet:...


